#define OP_CODE_R 1
#define OP_CODE_J 2
#define OP_CODE_I 3
#define OP_CODE_REGIMM 4
#define OP_CODE_OTHERS 5

// Branches

#define OP_J		 2
#define OP_JAL		 3
#define OP_BEQ		 4
#define OP_BNE		 5
#define OP_BLEZ		 6
#define OP_BGTZ		 7

// REGIMM Branches

#define OP_BLTZ		 0
#define OP_BGEZ		 1
#define OP_BLTZAL	16
#define OP_BGEZAL	17

// OP_CODE_I

#define OP_ADDI		 8
#define OP_ADDIU	 9
#define OP_SLTI		10
#define OP_SLTIU	11
#define OP_ANDI		12
#define OP_ORI		13
#define OP_XORI		14
#define OP_LUI		15

#define OP_LB		32
#define OP_LH		33
#define OP_LWL		34
#define OP_LW		35
#define OP_LBU		36
#define OP_LHU		37
#define OP_LWR		38
#define OP_SB		40
#define OP_SH		41
#define OP_SWL		42
#define OP_SW		43
#define OP_SWR		46

#define OP_LB		32
#define OP_LH		33
#define OP_LWL		34
#define OP_LW		35
#define OP_LBU		36
#define OP_LHU		37
#define OP_LWR		38
#define OP_SB		40
#define OP_SH		41
#define OP_SWL		42
#define OP_SW		43

// OP_CODE_R

#define OP_SLL		 0
#define OP_SRL		 2
#define OP_SRA		 3
#define OP_SLLV		 4
#define OP_SRLV		 6
#define OP_SRAV		 7
#define OP_JR		 8
#define OP_JALR		 9
#define OP_MOVZ		10
#define OP_MOVN		11
#define OP_MFHI		16
#define OP_MTHI		17
#define OP_MFLO		18
#define OP_MTLO		19
#define OP_MULT		24
#define OP_MULTU	25
#define OP_DIV		26
#define OP_DIVU		27
#define OP_ADD		32
#define OP_ADDU		33
#define OP_SUB		34
#define OP_SUBU		35
#define OP_AND		36
#define OP_OR		37
#define OP_XOR		38
#define OP_NOR		39
#define OP_SLT		42
#define OP_SLTU		43

struct CPU{};

int3 CPU.checkType(int32 op) {
	int3 ret;
	if(op == 0)
		ret = OP_CODE_R;
	else if(op == 1)
		ret = OP_CODE_REGIMM;
%CHECK_TYPE
	else
		ret = OP_CODE_OTHERS;
	return ret;
}

int32 CPU.function(secure int32[32] reg, secure int32 inst, secure int32 pc
%HILO_REG
	) {
	int32 op = inst >> 26;
	int32 rt = ((inst << 11)>>27);
	int32 rs = ((inst << 6) >> 27);
	int32 rd = ((inst << 16)>>27);
	int32 shamt = ((inst << 21)>>27);
	int32 reg_rs, reg_rt, reg_rd;
	int32 unsignExt = inst & 0xffff;
	int32 zeroExt = unsignExt;
	int32 funct = inst & 0x3f;
	// int32 regimm = rt;	// Use rt for faster but more opaque code
	int32 newpc;

	if (unsignExt &0x00008000 != 0)
		unsignExt = unsignExt | 0xffff0000;

	reg_rs = reg[rs];
	reg_rt = reg[rt];
	reg_rd = reg[rd];
	newpc = pc + 4;


	int3 op_type = this.checkType(op);
%ACTIONS
	return newpc;
}
%OP_ADDI
	MISSING TRAP
	reg_rt = reg_rs + unsignExt;
%OP_ADDIU
	reg_rt = reg_rs + unsignExt;
%OP_SLTI
	MISSING
%OP_SLTIU
	MISSING
%OP_ANDI
	reg_rt = reg_rs & zeroExt;
%OP_ORI
	reg_rt = reg_rs | zeroExt;
%OP_XORI
	reg_rt = reg_rs ^ zeroExt;
%OP_LUI
	reg_rt = zeroExt << 16;
%OP_SLL
	MISSING
%OP_SRL
	MISSING
%OP_SRA
	MISSING
%OP_SLLV
	MISSING
%OP_SRLV
	MISSING
%OP_SRAV
	MISSING
%OP_MOVZ
	if(reg_rt == 0) reg_rd = reg_rs;
%OP_MOVN
	if(reg_rt != 0) reg_rd = reg_rs;
%OP_MFHI
	MISSING
%OP_MTHI
	MISSING
%OP_MFLO
	MISSING
%OP_MTLO
	MISSING
%OP_MULT
	MISSING
%OP_MLTU
	MISSING
%OP_DIV
	MISSING
%OP_DIVU
	MISSING
%OP_ADD
	MISSING TRAP
	reg_rd = reg_rs + reg_rt;
%OP_ADDU
	reg_rd = reg_rs + reg_rt;
%OP_SUB
	MISSING TRAP
	reg_rd = reg_rs - reg_rt;
%OP_SUBU
	reg_rd = reg_rs - reg_rt;
%OP_AND
	reg_rd = reg_rs & reg_rt;
%OP_OR
	reg_rd = reg_rs | reg_rt;
%OP_XOR
	reg_rd = reg_rs ^ reg_rt;
%OP_NOR
	reg_rd = ~(reg_rs | reg_rt);
%OP_SLT
	if(reg_rs < reg_rt) reg_rd = 1; else reg_rd = 0;
%OP_SLTU
	if((unsigned)reg_rs < (unsigned)reg_rt) reg_rd = 1; else reg_rd = 0;
%OP_J
	newpc = (newpc&0xf0000000) | ((inst<<2)&0xffffffc);
%OP_JAL
	reg[31] = newpc + 4;
	newpc = (newpc&0xf0000000) | ((inst<<2)&0xffffffc);
%OP_JR
	/* This is fine as a FUNCT instruction, it just doesn't touch rd */
	newpc = reg_rs;
%OP_JALR
	/* This is fine as FUNCT instruction */
	reg_rd = newpc + 4;
	newpc = reg_rs;
%OP_BNE
	if(reg_rs != reg_rt)
		newpc = newpc + (unsignExt<<2);
%OP_BEQ
	if(reg_rs == reg_rt)
		newpc = newpc + (unsignExt<<2);
%OP_BLEZ
    if(reg_rs <= 0)
    	newpc = newpc + (unsignExt<<2);
%OP_BGTZ
	if(reg_rs > 0)
		newpc = newpc + (unsignExt<<2);
%OP_BGEZ
	if(reg_rs >= 0)
		newpc = newpc + (unsignExt<<2);
%OP_BLTZ
	if(reg_rs < 0)
		newpc = newpc + (unsignExt<<2);
%OP_BLTZAL
	if(reg_rs < 0) {
		reg[31] = newpc + 4;
		newpc = newpc + (unsignExt<<2);
	}
%OP_BGEZAL
	if(reg_rs >= 0) {
		reg[31] = newpc + 4;
		newpc = newpc + (unsignExt<<2);
	}
%OP_LB
	MISSING
%OP_LH
	MISSING
%OP_LWL
	MISSING
%OP_LW
	MISSING
%OP_LBU
	MISSING
%OP_LHU
	MISSING
%OP_LWR
	MISSING
%OP_SB
	MISSING
%OP_SH
	MISSING
%OP_SWL
	MISSING
%OP_SW
	MISSING
%OP_SWR
	MISSING