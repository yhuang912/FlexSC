#define OP_CODE_R 1
#define OP_CODE_I 2
#define OP_CODE_REGIMM 3
#define OP_CODE_OTHERS 4

// Branches

#define OP_J		 2
#define OP_JAL		 3
#define OP_BEQ		 4
#define OP_BNE		 5
#define OP_BLEZ		 6
#define OP_BGTZ		 7

// REGIMM Branches

#define OP_BLTZ		 0
#define OP_BGEZ		 1

// OP_CODE_I

#define OP_ADDI		 8
#define OP_ADDIU	 9
#define OP_SLTI		10
#define OP_SLTIU	11
#define OP_ANDI		12
#define OP_ORI		13
#define OP_XORI		14
#define OP_LUI		15

#define OP_LB		32
#define OP_LH		33
#define OP_LWL		34
#define OP_LW		35
#define OP_LBU		36
#define OP_LHU		37
#define OP_LWR		38
#define OP_SB		40
#define OP_SH		41
#define OP_SWL		42
#define OP_SW		43

// OP_CODE_R

#define OP_SLL		 0
#define OP_SRL		 2
#define OP_SRA		 3
#define OP_SLLV		 4
#define OP_SRLV		 6
#define OP_SRAV		 7
#define OP_JR		 8
#define OP_JALR		 9
#define OP_MOVZ		10
#define OP_MOVN		11
#define OP_MULT		24
#define OP_MULTU	25
#define OP_DIV		26
#define OP_DIVU		27
#define OP_ADD		32
#define OP_ADDU		33
#define OP_SUB		34
#define OP_SUBU		35
#define OP_AND		36
#define OP_OR		37
#define OP_XOR		38
#define OP_NOR		39
#define OP_SLT		42
#define OP_SLTU		43

struct CPU{};

int2 CPU.checkType(int32 opcode) {
	int2 ret;
	if(opcode == 0)
		ret = OP_CODE_R;
%CHECK_TYPE
	else
		ret = OP_CODE_OTHERS:
	return ret;
}

int32 CPU.function(secure int32[32] reg, secure int32 inst, secure int32 pc
%HILO_REG
	) {
	int32 op = inst >> 26;
	int32 rt = ((inst << 11)>>27);
	int32 rs = ((inst << 6) >> 27);
	int32 rd = ((inst << 16)>>27);
	int32 shamt = ((inst << 21)>>27);
	int32 reg_rs, reg_rt, reg_rd;
	int32 unsignExt = inst & 0xffff;
	int32 zeroExt = unsignExt;
	int32 funct = inst & 0x3f;

	if (unsignExt &0x00008000 != 0)
		unsignExt = unsignExt | 0xffff0000;

	reg_rs = reg[rs];
	reg_rt = reg[rt];
	reg_rd = reg[rd];
	newpc = pc + 4;


	int2 op_type = this.checkType(op);
%ACTIONS
	return pc;
}
%OP_ADDIU
	reg_rt = reg_rs + unsignExt;
%OP_ANDI
	reg_rt = reg_rs & zeroExt;
%OP_LUI
	reg_rt = zeroExt << 16;
%OP_ADDU
	reg_rd = reg_rs + reg_rt;
%OP_XOR
	reg_rd = reg_rs ^ reg_rt;
%OP_SLT
	if(reg_rs < reg_rt) reg_rd = 1; else reg_rd = 0;
%OP_SUBU
	reg_rd = reg_rs - reg_rt;
%OP_OR
	reg_rd = reg_rs | reg_rt;
%OP_J
	newpc = (newpc&0xf0000000) | ((inst<<2)&0xffffffc);
%OP_JAL
	newpc = (newpc&0xf0000000) | ((inst<<2)&0xffffffc);
	reg_31 = newpc + 4;
%OP_JR
	newpc = reg_rs;
%OP_BNE
	if(reg_rs != reg_rt)
		newpc = newpc + (unsignExt<<2);
%OP_BEQ
	if(reg_rs == reg_rt)
		newpc = newpc + (unsignExt<<2);
