package compiledlib;
import java.security.SecureRandom;
import oram.SecureArray;
import oram.CircuitOram;
import flexsc.Mode;
import flexsc.Party;
import flexsc.CompEnv;
import java.util.BitSet;
import circuits.arithmetic.IntegerLib;
import circuits.arithmetic.FloatLib;
import util.Utils;
import gc.regular.GCEva;
import gc.regular.GCGen;
import gc.GCSignal;
import java.util.Arrays;
import java.util.Random;
import flexsc.IWritable;
import flexsc.Comparator;
import java.lang.reflect.Array;
public class Dijkstra<t__T> {
	public SecureArray<t__T> graph;
	public SecureArray<t__T> dis;

	public CompEnv<t__T> env;
	public IntegerLib<t__T> intLib;
	public FloatLib<t__T> floatLib;

	public Dijkstra(CompEnv<t__T> env, SecureArray<t__T> graph, SecureArray<t__T> dis) throws Exception {
		this.env = env;
		this.intLib = new IntegerLib<t__T>(env);
		this.floatLib = new FloatLib<t__T>(env, 24, 8);
		this.graph = graph;
		this.dis = dis;
	}

	public void funct() throws Exception {
		int i = 0;
		PriorityQueue<t__T> pq;
		t__T[] zero = env.inputOfAlice(Utils.fromInt(0, 32));
		t__T traversingNode = env.inputOfAlice(false);
		t__T[] next = env.inputOfAlice(Utils.fromInt(0, 32));
		t__T[] currentDis = env.inputOfAlice(Utils.fromInt(0, 32));
		Pair<t__T, Int<t__T>, Int<t__T>> t = new Pair<t__T, Int<t__T>, Int<t__T>>(env, new Int<t__T>(env), new Int<t__T>(env));
		SecureArray<t__T> e = new SecureArray<t__T>(env, 3, 32);
		for(int _j_2 = 0; _j_2 < 3; ++_j_2) {
			e[_j_2] = env.inputOfAlice(Utils.fromInt(0, 32));
		}
		t__T[] dist = env.inputOfAlice(Utils.fromInt(0, 32));
		t__T[] key1 = env.inputOfAlice(Utils.fromInt(0, 32));
		t__T[] val1 = env.inputOfAlice(Utils.fromInt(0, 32));
		int f_tmp_0 = 0;
		int __tmp0 = f_tmp_0;
		i = __tmp0;
		int f_tmp_1 = 100;
		int __tmp1 = f_tmp_1;
		boolean f_tmp_2 = i < __tmp1;
		boolean __tmp2 = f_tmp_2;
		while(__tmp2) {
			int f_tmp_3 = 100000;
			int __tmp3 = f_tmp_3;
			SecureArray<t__T> f_tmp_4 = this.dis;
			SecureArray<t__T> __tmp4 = f_tmp_4;
			t__T[] f_tmp_5 = env.inputOfAlice(Utils.fromInt(i, 32));
			t__T[] f_tmp_6 = env.inputOfAlice(Utils.fromInt(__tmp3, 32));
			__tmp4.write(f_tmp_5,f_tmp_6);
			int f_tmp_7 = 1;
			int __tmp5 = f_tmp_7;
			int f_tmp_8 = i + __tmp5;
			int __tmp6 = f_tmp_8;
			i = __tmp6;
			int f_tmp_9 = 100;
			__tmp1 = f_tmp_9;
			boolean f_tmp_10 = i < __tmp1;
			__tmp2 = f_tmp_10;
		}
		int f_tmp_11 = 0;
		int __tmp7 = f_tmp_11;
		zero = env.inputOfAlice(Utils.fromInt(__tmp7, 32));
		boolean f_tmp_12 = true;
		t__T __tmp8 = env.inputOfAlice(f_tmp_12);
		pq.push(zero, zero, __tmp8);
		int f_tmp_14 = 0;
		int __tmp10 = f_tmp_14;
		SecureArray<t__T> f_tmp_15 = this.dis;
		SecureArray<t__T> __tmp11 = f_tmp_15;
		int f_tmp_16 = 0;
		int __tmp12 = f_tmp_16;
		t__T[] f_tmp_17 = env.inputOfAlice(Utils.fromInt(__tmp12, 32));
		t__T[] f_tmp_18 = env.inputOfAlice(Utils.fromInt(__tmp10, 32));
		__tmp11.write(f_tmp_17,f_tmp_18);
		boolean f_tmp_19 = false;
		boolean __tmp13 = f_tmp_19;
		traversingNode = env.inputOfAlice(__tmp13);
		int f_tmp_20 = 0;
		int __tmp14 = f_tmp_20;
		next = env.inputOfAlice(Utils.fromInt(__tmp14, 32));
		int f_tmp_21 = 0;
		int __tmp15 = f_tmp_21;
		i = __tmp15;
		int f_tmp_22 = 2;
		int __tmp16 = f_tmp_22;
		int f_tmp_23 = 100;
		int __tmp17 = f_tmp_23;
		int f_tmp_24 = __tmp16 * __tmp17;
		int __tmp18 = f_tmp_24;
		boolean f_tmp_25 = i < __tmp18;
		boolean __tmp19 = f_tmp_25;
		while(__tmp19) {
			t__T f_tmp_26 = intLib.not(traversingNode);
			t__T __tmp21 = f_tmp_26;
			Pair<t__T, Int<t__T>, Int<t__T>> f_tmp_27 = new Pair<t__T, Int<t__T>, Int<t__T>>(env, new Int<t__T>(env), new Int<t__T>(env)).newObj(pq.pop(__tmp21));
			Pair<t__T, Int<t__T>, Int<t__T>> __tmp22 = f_tmp_27;
			Pair<t__T, Int<t__T>, Int<t__T>> __tmp23 = new Pair<t__T, Int<t__T>, Int<t__T>>(env, new Int<t__T>(env), new Int<t__T>(env)).newObj(intLib.mux(t.getBits(), __tmp22.getBits(),__tmp21));
			t = __tmp23;
			SecureArray<t__T> f_tmp_29 = this.dis;
			SecureArray<t__T> __tmp24 = f_tmp_29;
			Int<t__T> f_tmp_30 = t.second;
			Int<t__T> __tmp25 = f_tmp_30;
			t__T[] f_tmp_31 = __tmp25.data;
			t__T[] __tmp26 = f_tmp_31;
			t__T[] f_tmp_32 = __tmp24.read(__tmp26);
			t__T[] __tmp27 = f_tmp_32;
			Int<t__T> f_tmp_33 = t.first;
			Int<t__T> __tmp28 = f_tmp_33;
			t__T[] f_tmp_34 = __tmp28.data;
			t__T[] __tmp29 = f_tmp_34;
			t__T f_tmp_35 = intLib.geq(__tmp27, __tmp29);
			t__T __tmp30 = f_tmp_35;
			t__T f_tmp_36 = intLib.and(__tmp21,__tmp30);
			t__T __tmp31 = f_tmp_36;
			boolean f_tmp_37 = true;
			boolean __tmp32 = f_tmp_37;
			t__T f_tmp_39 = env.inputOfAlice(__tmp32);
			t__T __tmp33 = intLib.mux(traversingNode, f_tmp_39,__tmp31);
			traversingNode = __tmp33;
			Int<t__T> f_tmp_40 = t.second;
			Int<t__T> __tmp34 = f_tmp_40;
			t__T[] f_tmp_41 = __tmp34.data;
			t__T[] __tmp35 = f_tmp_41;
			t__T[] __tmp36 = intLib.mux(next, __tmp35,__tmp31);
			next = __tmp36;
			Int<t__T> f_tmp_43 = t.first;
			Int<t__T> __tmp37 = f_tmp_43;
			t__T[] f_tmp_44 = __tmp37.data;
			t__T[] __tmp38 = f_tmp_44;
			SecureArray<t__T> f_tmp_45 = this.dis;
			SecureArray<t__T> __tmp39 = f_tmp_45;
			Int<t__T> f_tmp_46 = t.second;
			Int<t__T> __tmp40 = f_tmp_46;
			t__T[] f_tmp_47 = __tmp40.data;
			t__T[] __tmp41 = f_tmp_47;
			t__T[] f_tmp_48 = __tmp39.read(__tmp41);
			t__T[] __tmp42 = f_tmp_48;
			t__T[] __tmp43 = intLib.mux(__tmp42, __tmp38,__tmp31);
			__tmp39.write(__tmp41,__tmp43);
			Int<t__T> f_tmp_50 = t.first;
			Int<t__T> __tmp44 = f_tmp_50;
			t__T[] f_tmp_51 = __tmp44.data;
			t__T[] __tmp45 = f_tmp_51;
			t__T[] __tmp46 = intLib.mux(currentDis, __tmp45,__tmp31);
			currentDis = __tmp46;
			t__T f_tmp_53 = intLib.not(__tmp21);
			t__T __tmp47 = f_tmp_53;
			SecureArray<t__T> f_tmp_54 = this.graph;
			SecureArray<t__T> __tmp48 = f_tmp_54;
			t__T[][] f_tmp_55 = __tmp48.read(next);
			t__T[][] __tmp49 = f_tmp_55;
			SecureArray<t__T> __tmp50 = intLib.mux(e.getBits(), __tmp49.getBits(),__tmp47);
			e = __tmp50;
			int f_tmp_57 = 1;
			int __tmp51 = f_tmp_57;
			t__T[] f_tmp_59 = env.inputOfAlice(Utils.fromInt(__tmp51, 32));
			t__T[] f_tmp_58 = e.read(f_tmp_59);
			t__T[] __tmp52 = f_tmp_58;
			t__T[] __tmp53 = intLib.mux(next, __tmp52,__tmp47);
			next = __tmp53;
			int f_tmp_61 = 0;
			int __tmp54 = f_tmp_61;
			int f_tmp_62 = 1;
			int __tmp55 = f_tmp_62;
			int f_tmp_63 = __tmp54 - __tmp55;
			int __tmp56 = f_tmp_63;
			t__T[] f_tmp_65 = env.inputOfAlice(Utils.fromInt(__tmp56, 32));
			t__T f_tmp_64 = intLib.eq(next, f_tmp_65);
			t__T __tmp57 = f_tmp_64;
			t__T f_tmp_66 = intLib.and(__tmp47,__tmp57);
			t__T __tmp58 = f_tmp_66;
			boolean f_tmp_67 = false;
			boolean __tmp59 = f_tmp_67;
			t__T f_tmp_69 = env.inputOfAlice(__tmp59);
			t__T __tmp60 = intLib.mux(traversingNode, f_tmp_69,__tmp58);
			traversingNode = __tmp60;
			t__T f_tmp_70 = intLib.not(__tmp57);
			t__T __tmp61 = f_tmp_70;
			t__T f_tmp_71 = intLib.and(__tmp47,__tmp61);
			t__T __tmp62 = f_tmp_71;
			int f_tmp_72 = 2;
			int __tmp63 = f_tmp_72;
			t__T[] f_tmp_74 = env.inputOfAlice(Utils.fromInt(__tmp63, 32));
			t__T[] f_tmp_73 = e.read(f_tmp_74);
			t__T[] __tmp64 = f_tmp_73;
			t__T[] f_tmp_75 = intLib.add(currentDis,__tmp64);
			t__T[] __tmp65 = f_tmp_75;
			t__T[] __tmp66 = intLib.mux(dist, __tmp65,__tmp62);
			dist = __tmp66;
			t__T[] __tmp67 = intLib.mux(key1, dist,__tmp62);
			key1 = __tmp67;
			int f_tmp_78 = 0;
			int __tmp68 = f_tmp_78;
			t__T[] f_tmp_80 = env.inputOfAlice(Utils.fromInt(__tmp68, 32));
			t__T[] f_tmp_79 = e.read(f_tmp_80);
			t__T[] __tmp69 = f_tmp_79;
			t__T[] __tmp70 = intLib.mux(val1, __tmp69,__tmp62);
			val1 = __tmp70;
			pq.push(key1, val1, __tmp62);
			int f_tmp_83 = 1;
			int __tmp72 = f_tmp_83;
			int f_tmp_84 = i + __tmp72;
			int __tmp73 = f_tmp_84;
			i = __tmp73;
			int f_tmp_85 = 2;
			__tmp16 = f_tmp_85;
			int f_tmp_86 = 100;
			__tmp17 = f_tmp_86;
			int f_tmp_87 = __tmp16 * __tmp17;
			__tmp18 = f_tmp_87;
			boolean f_tmp_88 = i < __tmp18;
			__tmp19 = f_tmp_88;
		}

	}
}
