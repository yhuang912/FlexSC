package compiledlib.avltree;
import java.security.SecureRandom;
import oram.SecureArray;
import oram.CircuitOram;
import flexsc.Mode;
import flexsc.Party;
import flexsc.CompEnv;
import java.util.BitSet;
import circuits.arithmetic.IntegerLib;
import util.Utils;
import gc.regular.GCEva;
import gc.regular.GCGen;
import gc.GCSignal;
import java.util.Arrays;
import java.util.Random;
import flexsc.IWritable;
import flexsc.Comparator;
import java.lang.reflect.Array;
public class AVLTree<K extends IWritable<K,Boolean>, V extends IWritable<V,Boolean>> {
	public CircuitOram<Boolean> poram;
	public Boolean[] total;
	public AVLId root;
	public IntStack IDs;

	private CompEnv<Boolean> env;
	private IntegerLib<Boolean> lib;
	private K factoryK;
	private V factoryV;
	private int m;

	public AVLTree(CompEnv<Boolean> env, IntegerLib<Boolean> lib, int m, K factoryK, V factoryV, CircuitOram<Boolean> poram, IntStack IDs) throws Exception {
		this.env = env;
		this.lib = lib;
		this.m = m;
		this.factoryK = factoryK;
		this.factoryV = factoryV;
		this.poram = poram;
		this.total = env.inputOfAlice(Utils.fromInt(0, m));
		this.root = new AVLId(env, lib, m);
		this.IDs = IDs;
	}

	public void init() throws Exception {
		int i = 0;
		int f_tmp_46 = 0;
		int __tmp41 = f_tmp_46;
		Boolean[] f_tmp_47 = env.inputOfAlice(Utils.fromInt(__tmp41, m));
		this.total = f_tmp_47;
		Boolean[] f_tmp_48 = lib.randBools(m);
		Boolean[] __tmp42 = f_tmp_48;
		int f_tmp_49 = 0;
		int __tmp43 = f_tmp_49;
		AVLId f_tmp_50 = new AVLId(env, lib, m);
		f_tmp_50.pos = __tmp42;
		f_tmp_50.id = env.inputOfAlice(Utils.fromInt(__tmp43, m));
		AVLId __tmp44 = f_tmp_50;
		this.root = __tmp44;
		int f_tmp_51 = 1;
		int __tmp45 = f_tmp_51;
		i = __tmp45;
		int f_tmp_52 = 1;
		int __tmp46 = f_tmp_52;
		int f_tmp_53 = __tmp46 << m;
		int __tmp47 = f_tmp_53;
		boolean f_tmp_54 = i < __tmp47;
		boolean __tmp48 = f_tmp_54;
		while(__tmp48) {
			boolean f_tmp_55 = false;
			boolean __tmp49 = f_tmp_55;
			boolean f_tmp_56 = true;
			Boolean __tmp51 = env.inputOfAlice(f_tmp_56);
			IntStack f_tmp_57 = this.IDs;
			IntStack __tmp50 = f_tmp_57;
			Boolean[] f_tmp_58 = __tmp50.stack_op(env.inputOfAlice(Utils.fromInt(i, m)), env.inputOfAlice(__tmp49), __tmp51);
			Boolean[] __tmp52 = f_tmp_58;
			int f_tmp_59 = 1;
			int __tmp53 = f_tmp_59;
			int f_tmp_60 = i + __tmp53;
			int __tmp54 = f_tmp_60;
			i = __tmp54;
			int f_tmp_61 = 1;
			__tmp46 = f_tmp_61;
			int f_tmp_62 = __tmp46 << m;
			__tmp47 = f_tmp_62;
			boolean f_tmp_63 = i < __tmp47;
			__tmp48 = f_tmp_63;
		}

	}
	public void insert(K key, V value, FUNC_1_INTsecure_T1_T1<K> cmp) throws Exception {
		AVLNode<K, V> tnodes = new AVLNode<K, V>(env, lib, m, factoryK, factoryV);
		AVLNode<K, V> p = new AVLNode<K, V>(env, lib, m, factoryK, factoryV);
		AVLId now = new AVLId(env, lib, m);
		AVLId go = new AVLId(env, lib, m);
		AVLId a = new AVLId(env, lib, m);
		AVLId b = new AVLId(env, lib, m);
		AVLId c = new AVLId(env, lib, m);
		AVLId[] left = (AVLId[])Array.newInstance((Class<AVLId>)(new AVLId(env, lib, m).getClass()), ((3)*(m))/(2));
		K[] keys = (K[])Array.newInstance((Class<K>)factoryK.getClass(), ((3)*(m))/(2));
		V[] values = (V[])Array.newInstance((Class<V>)factoryV.getClass(), ((3)*(m))/(2));
		Boolean[][] depth = new Boolean[((3)*(m))/(2)][];
		Boolean[][] ids = new Boolean[((3)*(m))/(2)][];
		Boolean[][] cres = new Boolean[((3)*(m))/(2)][];
		Boolean[] ind = env.inputOfAlice(Utils.fromInt(0, 2));
		Boolean[] id = env.inputOfAlice(Utils.fromInt(0, m));
		Boolean[] pos = env.inputOfAlice(Utils.fromInt(0, m));
		Boolean[] hpos = env.inputOfAlice(Utils.fromInt(0, m));
		K k = factoryK.newObj(null);
		K kp = factoryK.newObj(null);
		V v = factoryV.newObj(null);
		V vp = factoryV.newObj(null);
		Boolean[] dl = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dr = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId lf = new AVLId(env, lib, m);
		AVLId rf = new AVLId(env, lib, m);
		int i = 0;
		Boolean[] nowDepth = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] ld = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] rd = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dc = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dap = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dbp = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId nid = new AVLId(env, lib, m);
		AVLId next = new AVLId(env, lib, m);
		AVLId ll = new AVLId(env, lib, m);
		AVLId rr = new AVLId(env, lib, m);
		AVLId l = new AVLId(env, lib, m);
		Boolean[] dp = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId f_tmp_64 = this.root;
		AVLId __tmp55 = f_tmp_64;
		now = __tmp55;
		int f_tmp_65 = 0;
		int __tmp56 = f_tmp_65;
		ind = env.inputOfAlice(Utils.fromInt(__tmp56, 2));
		Boolean[] __tmp57 = now.pos;
		Boolean[] __tmp58 = now.id;
		id = __tmp58;
		pos = __tmp57;
		int f_tmp_66 = 0;
		int __tmp59 = f_tmp_66;
		Boolean[] f_tmp_68 = env.inputOfAlice(Utils.fromInt(__tmp59, m));
		Boolean f_tmp_67 = lib.eq(id, f_tmp_68);
		Boolean __tmp60 = f_tmp_67;
		int f_tmp_69 = 0;
		int __tmp61 = f_tmp_69;
		Boolean[] f_tmp_71 = env.inputOfAlice(Utils.fromInt(__tmp61, 2));
		Boolean[] f_tmp_70 = lib.mux(ind, f_tmp_71,__tmp60);
		Boolean[] __tmp62 = f_tmp_70;
		ind = __tmp62;
		Boolean f_tmp_72 = lib.not(__tmp60);
		Boolean __tmp63 = f_tmp_72;
		AVLId f_tmp_73 = new AVLId(env, lib, m);
		f_tmp_73.pos = pos;
		f_tmp_73.id = id;
		AVLId __tmp64 = f_tmp_73;
		now = __tmp64;
		int f_tmp_74 = 0;
		int __tmp65 = f_tmp_74;
		i = __tmp65;
		int f_tmp_75 = 3;
		int __tmp66 = f_tmp_75;
		int f_tmp_76 = __tmp66 * m;
		int __tmp67 = f_tmp_76;
		int f_tmp_77 = 2;
		int __tmp68 = f_tmp_77;
		int f_tmp_78 = __tmp67 / __tmp68;
		int __tmp69 = f_tmp_78;
		boolean f_tmp_79 = i < __tmp69;
		boolean __tmp70 = f_tmp_79;
		while(__tmp70) {
			ids[i]=ind;
			int f_tmp_80 = 0;
			int __tmp71 = f_tmp_80;
			Boolean[] f_tmp_82 = env.inputOfAlice(Utils.fromInt(__tmp71, 2));
			Boolean f_tmp_81 = lib.eq(ind, f_tmp_82);
			Boolean __tmp72 = f_tmp_81;
			Boolean[] __tmp73 = now.pos;
			Boolean[] __tmp74 = now.id;
			Boolean[] f_tmp_83 = lib.mux(id, __tmp74,__tmp72);
			Boolean[] __tmp75 = f_tmp_83;
			id = __tmp75;
			Boolean[] f_tmp_84 = lib.mux(pos, __tmp73,__tmp72);
			Boolean[] __tmp76 = f_tmp_84;
			pos = __tmp76;
			CircuitOram<Boolean> f_tmp_85 = this.poram;
			CircuitOram<Boolean> __tmp77 = f_tmp_85;
			AVLNode<K, V> f_tmp_86 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV).newObj(__tmp77.conditionalReadAndRemove(id, pos, __tmp72));
			AVLNode<K, V> __tmp78 = f_tmp_86;
			AVLNode<K, V> f_tmp_87 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV).newObj(lib.mux(tnodes.getBits(), __tmp78.getBits(),__tmp72));
			AVLNode<K, V> __tmp79 = f_tmp_87;
			tnodes = __tmp79;
			boolean f_tmp_88 = false;
			boolean __tmp80 = f_tmp_88;
			IntStack f_tmp_89 = this.IDs;
			IntStack __tmp81 = f_tmp_89;
			Boolean[] f_tmp_90 = __tmp81.stack_op(id, env.inputOfAlice(__tmp80), __tmp72);
			Boolean[] __tmp82 = f_tmp_90;
			AVLId __tmp83 = tnodes.left;
			Boolean[] __tmp84 = tnodes.rDepth;
			AVLId __tmp85 = tnodes.right;
			V __tmp86 = tnodes.value;
			K __tmp87 = tnodes.key;
			Boolean[] __tmp88 = tnodes.lDepth;
			K f_tmp_91 = keys[i];
			K __tmp89 = f_tmp_91;
			K f_tmp_92 = this.factoryK.newObj(
					lib.mux(
							__tmp89.getBits(),
							__tmp87.getBits(),__tmp72));
			K __tmp90 = f_tmp_92;
			keys[i]=__tmp90;
			V f_tmp_93 = values[i];
			V __tmp91 = f_tmp_93;
			V f_tmp_94 = this.factoryV.newObj(lib.mux(__tmp91.getBits(), __tmp86.getBits(),__tmp72));
			V __tmp92 = f_tmp_94;
			values[i]=__tmp92;
			Boolean[] f_tmp_95 = lib.mux(ld, __tmp88,__tmp72);
			Boolean[] __tmp93 = f_tmp_95;
			ld = __tmp93;
			Boolean[] f_tmp_96 = lib.mux(rd, __tmp84,__tmp72);
			Boolean[] __tmp94 = f_tmp_96;
			rd = __tmp94;
			AVLId f_tmp_97 = new AVLId(env, lib, m).newObj(lib.mux(lf.getBits(), __tmp83.getBits(),__tmp72));
			AVLId __tmp95 = f_tmp_97;
			lf = __tmp95;
			AVLId f_tmp_98 = new AVLId(env, lib, m).newObj(lib.mux(rf.getBits(), __tmp85.getBits(),__tmp72));
			AVLId __tmp96 = f_tmp_98;
			rf = __tmp96;
			Boolean f_tmp_99 = lib.not(__tmp72);
			Boolean __tmp97 = f_tmp_99;
			int f_tmp_100 = 1;
			int __tmp98 = f_tmp_100;
			Boolean[] f_tmp_102 = env.inputOfAlice(Utils.fromInt(__tmp98, 2));
			Boolean f_tmp_101 = lib.eq(ind, f_tmp_102);
			Boolean __tmp99 = f_tmp_101;
			Boolean f_tmp_103 = lib.and(__tmp97,__tmp99);
			Boolean __tmp100 = f_tmp_103;
			K f_tmp_104 = keys[i];
			K __tmp101 = f_tmp_104;
			K f_tmp_105 = this.factoryK.newObj(lib.mux(__tmp101.getBits(), key.getBits(),__tmp100));
			K __tmp102 = f_tmp_105;
			keys[i]=__tmp102;
			V f_tmp_106 = values[i];
			V __tmp103 = f_tmp_106;
			V f_tmp_107 = this.factoryV.newObj(lib.mux(__tmp103.getBits(), value.getBits(),__tmp100));
			V __tmp104 = f_tmp_107;
			values[i]=__tmp104;
			int f_tmp_108 = 0;
			int __tmp105 = f_tmp_108;
			int f_tmp_109 = 1;
			int __tmp106 = f_tmp_109;
			int f_tmp_110 = __tmp105 - __tmp106;
			int __tmp107 = f_tmp_110;
			Boolean[] f_tmp_111 = depth[i];
			Boolean[] __tmp108 = f_tmp_111;
			Boolean[] f_tmp_113 = env.inputOfAlice(Utils.fromInt(__tmp107, (m)+(1)));
			Boolean[] f_tmp_112 = lib.mux(__tmp108, f_tmp_113,__tmp100);
			Boolean[] __tmp109 = f_tmp_112;
			depth[i]=__tmp109;
			Boolean[] f_tmp_114 = lib.randBools(m);
			Boolean[] __tmp110 = f_tmp_114;
			int f_tmp_115 = 0;
			int __tmp111 = f_tmp_115;
			AVLId f_tmp_116 = new AVLId(env, lib, m);
			f_tmp_116.pos = __tmp110;
			f_tmp_116.id = env.inputOfAlice(Utils.fromInt(__tmp111, m));
			AVLId __tmp112 = f_tmp_116;
			AVLId f_tmp_117 = left[i];
			AVLId __tmp113 = f_tmp_117;
			AVLId f_tmp_118 = new AVLId(env, lib, m).newObj(lib.mux(__tmp113.getBits(), __tmp112.getBits(),__tmp100));
			AVLId __tmp114 = f_tmp_118;
			left[i]=__tmp114;
			int f_tmp_119 = 2;
			int __tmp115 = f_tmp_119;
			Boolean[] f_tmp_121 = env.inputOfAlice(Utils.fromInt(__tmp115, 2));
			Boolean[] f_tmp_120 = lib.mux(ind, f_tmp_121,__tmp100);
			Boolean[] __tmp116 = f_tmp_120;
			ind = __tmp116;
			Boolean f_tmp_122 = lib.not(__tmp99);
			Boolean __tmp117 = f_tmp_122;
			Boolean f_tmp_123 = lib.and(__tmp97,__tmp117);
			Boolean __tmp118 = f_tmp_123;
			int f_tmp_124 = 0;
			int __tmp119 = f_tmp_124;
			int f_tmp_125 = 1;
			int __tmp120 = f_tmp_125;
			int f_tmp_126 = __tmp119 - __tmp120;
			int __tmp121 = f_tmp_126;
			Boolean[] f_tmp_127 = depth[i];
			Boolean[] __tmp122 = f_tmp_127;
			Boolean[] f_tmp_129 = env.inputOfAlice(Utils.fromInt(__tmp121, (m)+(1)));
			Boolean[] f_tmp_128 = lib.mux(__tmp122, f_tmp_129,__tmp118);
			Boolean[] __tmp123 = f_tmp_128;
			depth[i]=__tmp123;
			int f_tmp_130 = 1;
			int __tmp124 = f_tmp_130;
			int f_tmp_131 = i - __tmp124;
			int __tmp125 = f_tmp_131;
			K f_tmp_132 = keys[__tmp125];
			K __tmp126 = f_tmp_132;
			K f_tmp_133 = keys[i];
			K __tmp127 = f_tmp_133;
			K f_tmp_134 = this.factoryK.newObj(lib.mux(__tmp127.getBits(), __tmp126.getBits(),__tmp118));
			K __tmp128 = f_tmp_134;
			keys[i]=__tmp128;
			K f_tmp_135 = keys[i];
			K __tmp129 = f_tmp_135;
			Boolean[] f_tmp_136 = cmp.calc(__tmp129, key);
			Boolean[] __tmp130 = f_tmp_136;
			cres[i]=__tmp130;
			int f_tmp_137 = 0;
			int __tmp131 = f_tmp_137;
			Boolean[] f_tmp_139 = env.inputOfAlice(Utils.fromInt(__tmp131, 2));
			Boolean f_tmp_138 = lib.eq(ind, f_tmp_139);
			Boolean __tmp132 = f_tmp_138;
			Boolean[] f_tmp_140 = cres[i];
			Boolean[] __tmp133 = f_tmp_140;
			int f_tmp_141 = 0;
			int __tmp134 = f_tmp_141;
			Boolean[] f_tmp_143 = env.inputOfAlice(Utils.fromInt(__tmp134, 2));
			Boolean f_tmp_142 = lib.not(lib.leq(__tmp133, f_tmp_143));
			Boolean __tmp135 = f_tmp_142;
			Boolean f_tmp_144 = lib.and(__tmp132,__tmp135);
			Boolean __tmp136 = f_tmp_144;
			Boolean[] f_tmp_145 = depth[i];
			Boolean[] __tmp137 = f_tmp_145;
			Boolean[] f_tmp_146 = lib.mux(__tmp137, dr,__tmp136);
			Boolean[] __tmp138 = f_tmp_146;
			depth[i]=__tmp138;
			AVLId f_tmp_147 = new AVLId(env, lib, m).newObj(lib.mux(go.getBits(), lf.getBits(),__tmp136));
			AVLId __tmp139 = f_tmp_147;
			go = __tmp139;
			AVLId f_tmp_148 = left[i];
			AVLId __tmp140 = f_tmp_148;
			AVLId f_tmp_149 = new AVLId(env, lib, m).newObj(lib.mux(__tmp140.getBits(), rf.getBits(),__tmp136));
			AVLId __tmp141 = f_tmp_149;
			left[i]=__tmp141;
			Boolean f_tmp_150 = lib.not(__tmp135);
			Boolean __tmp142 = f_tmp_150;
			Boolean f_tmp_151 = lib.and(__tmp132,__tmp142);
			Boolean __tmp143 = f_tmp_151;
			Boolean[] f_tmp_152 = depth[i];
			Boolean[] __tmp144 = f_tmp_152;
			Boolean[] f_tmp_153 = lib.mux(__tmp144, dl,__tmp143);
			Boolean[] __tmp145 = f_tmp_153;
			depth[i]=__tmp145;
			AVLId f_tmp_154 = new AVLId(env, lib, m).newObj(lib.mux(go.getBits(), rf.getBits(),__tmp143));
			AVLId __tmp146 = f_tmp_154;
			go = __tmp146;
			AVLId f_tmp_155 = left[i];
			AVLId __tmp147 = f_tmp_155;
			AVLId f_tmp_156 = new AVLId(env, lib, m).newObj(lib.mux(__tmp147.getBits(), lf.getBits(),__tmp143));
			AVLId __tmp148 = f_tmp_156;
			left[i]=__tmp148;
			AVLId f_tmp_157 = new AVLId(env, lib, m).newObj(lib.mux(now.getBits(), go.getBits(),__tmp132));
			AVLId __tmp149 = f_tmp_157;
			now = __tmp149;
			Boolean[] f_tmp_158 = now.id;
			Boolean[] __tmp150 = f_tmp_158;
			int f_tmp_159 = 0;
			int __tmp151 = f_tmp_159;
			Boolean[] f_tmp_161 = env.inputOfAlice(Utils.fromInt(__tmp151, m));
			Boolean f_tmp_160 = lib.eq(__tmp150, f_tmp_161);
			Boolean __tmp152 = f_tmp_160;
			Boolean f_tmp_162 = lib.and(__tmp132,__tmp152);
			Boolean __tmp153 = f_tmp_162;
			int f_tmp_163 = 1;
			int __tmp154 = f_tmp_163;
			Boolean[] f_tmp_165 = env.inputOfAlice(Utils.fromInt(__tmp154, 2));
			Boolean[] f_tmp_164 = lib.mux(ind, f_tmp_165,__tmp153);
			Boolean[] __tmp155 = f_tmp_164;
			ind = __tmp155;
			Boolean f_tmp_166 = lib.not(__tmp152);
			Boolean __tmp156 = f_tmp_166;
			Boolean f_tmp_167 = lib.and(__tmp132,__tmp156);
			Boolean __tmp157 = f_tmp_167;
			Boolean f_tmp_168 = lib.not(__tmp132);
			Boolean __tmp158 = f_tmp_168;
			int f_tmp_169 = 1;
			int __tmp159 = f_tmp_169;
			int f_tmp_170 = i + __tmp159;
			int __tmp160 = f_tmp_170;
			i = __tmp160;
			int f_tmp_171 = 3;
			__tmp66 = f_tmp_171;
			int f_tmp_172 = __tmp66 * m;
			__tmp67 = f_tmp_172;
			int f_tmp_173 = 2;
			__tmp68 = f_tmp_173;
			int f_tmp_174 = __tmp67 / __tmp68;
			__tmp69 = f_tmp_174;
			boolean f_tmp_175 = i < __tmp69;
			__tmp70 = f_tmp_175;
		}
		int f_tmp_176 = 0;
		int __tmp161 = f_tmp_176;
		int f_tmp_177 = 1;
		int __tmp162 = f_tmp_177;
		int f_tmp_178 = __tmp161 - __tmp162;
		int __tmp163 = f_tmp_178;
		nowDepth = env.inputOfAlice(Utils.fromInt(__tmp163, (m)+(1)));
		Boolean[] f_tmp_179 = lib.randBools(m);
		Boolean[] __tmp164 = f_tmp_179;
		int f_tmp_180 = 0;
		int __tmp165 = f_tmp_180;
		AVLId f_tmp_181 = new AVLId(env, lib, m);
		f_tmp_181.pos = __tmp164;
		f_tmp_181.id = env.inputOfAlice(Utils.fromInt(__tmp165, m));
		AVLId __tmp166 = f_tmp_181;
		nid = __tmp166;
		int f_tmp_182 = 3;
		int __tmp167 = f_tmp_182;
		int f_tmp_183 = __tmp167 * m;
		int __tmp168 = f_tmp_183;
		int f_tmp_184 = 2;
		int __tmp169 = f_tmp_184;
		int f_tmp_185 = __tmp168 / __tmp169;
		int __tmp170 = f_tmp_185;
		int f_tmp_186 = 1;
		int __tmp171 = f_tmp_186;
		int f_tmp_187 = __tmp170 - __tmp171;
		int __tmp172 = f_tmp_187;
		i = __tmp172;
		int f_tmp_188 = 0;
		int __tmp173 = f_tmp_188;
		boolean f_tmp_189 = i >= __tmp173;
		boolean __tmp174 = f_tmp_189;
		while(__tmp174) {
			Boolean[] f_tmp_190 = ids[i];
			Boolean[] __tmp175 = f_tmp_190;
			int f_tmp_191 = 0;
			int __tmp176 = f_tmp_191;
			Boolean[] f_tmp_193 = env.inputOfAlice(Utils.fromInt(__tmp176, 2));
			Boolean f_tmp_192 = lib.eq(__tmp175, f_tmp_193);
			Boolean __tmp177 = f_tmp_192;
			int f_tmp_194 = 0;
			int __tmp178 = f_tmp_194;
			boolean f_tmp_195 = true;
			boolean __tmp179 = f_tmp_195;
			IntStack f_tmp_196 = this.IDs;
			IntStack __tmp180 = f_tmp_196;
			Boolean[] f_tmp_197 = __tmp180.stack_op(env.inputOfAlice(Utils.fromInt(__tmp178, m)), env.inputOfAlice(__tmp179), __tmp177);
			Boolean[] __tmp181 = f_tmp_197;
			Boolean[] f_tmp_198 = lib.mux(id, __tmp181,__tmp177);
			Boolean[] __tmp182 = f_tmp_198;
			id = __tmp182;
			Boolean[] f_tmp_199 = lib.randBools(m);
			Boolean[] __tmp183 = f_tmp_199;
			Boolean[] f_tmp_200 = lib.mux(pos, __tmp183,__tmp177);
			Boolean[] __tmp184 = f_tmp_200;
			pos = __tmp184;
			Boolean[] f_tmp_201 = lib.mux(hpos, pos,__tmp177);
			Boolean[] __tmp185 = f_tmp_201;
			hpos = __tmp185;
			AVLId f_tmp_202 = new AVLId(env, lib, m);
			f_tmp_202.pos = pos;
			f_tmp_202.id = id;
			AVLId __tmp186 = f_tmp_202;
			AVLId f_tmp_203 = new AVLId(env, lib, m).newObj(lib.mux(next.getBits(), __tmp186.getBits(),__tmp177));
			AVLId __tmp187 = f_tmp_203;
			next = __tmp187;
			Boolean[] f_tmp_204 = cres[i];
			Boolean[] __tmp188 = f_tmp_204;
			int f_tmp_205 = 0;
			int __tmp189 = f_tmp_205;
			Boolean[] f_tmp_207 = env.inputOfAlice(Utils.fromInt(__tmp189, 2));
			Boolean f_tmp_206 = lib.geq(__tmp188, f_tmp_207);
			Boolean __tmp190 = f_tmp_206;
			Boolean f_tmp_208 = lib.and(__tmp177,__tmp190);
			Boolean __tmp191 = f_tmp_208;
			Boolean[] f_tmp_209 = lib.mux(ld, nowDepth,__tmp191);
			Boolean[] __tmp192 = f_tmp_209;
			ld = __tmp192;
			Boolean[] f_tmp_210 = depth[i];
			Boolean[] __tmp193 = f_tmp_210;
			Boolean[] f_tmp_211 = lib.mux(rd, __tmp193,__tmp191);
			Boolean[] __tmp194 = f_tmp_211;
			rd = __tmp194;
			AVLId f_tmp_212 = new AVLId(env, lib, m).newObj(lib.mux(ll.getBits(), nid.getBits(),__tmp191));
			AVLId __tmp195 = f_tmp_212;
			ll = __tmp195;
			AVLId f_tmp_213 = left[i];
			AVLId __tmp196 = f_tmp_213;
			AVLId f_tmp_214 = new AVLId(env, lib, m).newObj(lib.mux(rr.getBits(), __tmp196.getBits(),__tmp191));
			AVLId __tmp197 = f_tmp_214;
			rr = __tmp197;
			Boolean f_tmp_215 = lib.not(__tmp190);
			Boolean __tmp198 = f_tmp_215;
			Boolean f_tmp_216 = lib.and(__tmp177,__tmp198);
			Boolean __tmp199 = f_tmp_216;
			Boolean[] f_tmp_217 = depth[i];
			Boolean[] __tmp200 = f_tmp_217;
			Boolean[] f_tmp_218 = lib.mux(ld, __tmp200,__tmp199);
			Boolean[] __tmp201 = f_tmp_218;
			ld = __tmp201;
			Boolean[] f_tmp_219 = lib.mux(rd, nowDepth,__tmp199);
			Boolean[] __tmp202 = f_tmp_219;
			rd = __tmp202;
			AVLId f_tmp_220 = left[i];
			AVLId __tmp203 = f_tmp_220;
			AVLId f_tmp_221 = new AVLId(env, lib, m).newObj(lib.mux(ll.getBits(), __tmp203.getBits(),__tmp199));
			AVLId __tmp204 = f_tmp_221;
			ll = __tmp204;
			AVLId f_tmp_222 = new AVLId(env, lib, m).newObj(lib.mux(rr.getBits(), nid.getBits(),__tmp199));
			AVLId __tmp205 = f_tmp_222;
			rr = __tmp205;
			AVLId f_tmp_223 = new AVLId(env, lib, m).newObj(lib.mux(nid.getBits(), next.getBits(),__tmp177));
			AVLId __tmp206 = f_tmp_223;
			nid = __tmp206;
			V f_tmp_224 = values[i];
			V __tmp207 = f_tmp_224;
			K f_tmp_225 = keys[i];
			K __tmp208 = f_tmp_225;
			AVLNode<K, V> f_tmp_226 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV);
			f_tmp_226.left = ll;
			f_tmp_226.rDepth = rd;
			f_tmp_226.right = rr;
			f_tmp_226.value = __tmp207;
			f_tmp_226.key = __tmp208;
			f_tmp_226.lDepth = ld;
			AVLNode<K, V> __tmp209 = f_tmp_226;
			CircuitOram<Boolean> f_tmp_227 = this.poram;
			CircuitOram<Boolean> __tmp210 = f_tmp_227;
			__tmp210.conditionalPutBack(id, pos, __tmp209.getBits(), __tmp177);
			Boolean[] f_tmp_229 = depth[i];
			Boolean[] __tmp212 = f_tmp_229;
			Boolean f_tmp_230 = lib.not(lib.leq(__tmp212, nowDepth));
			Boolean __tmp213 = f_tmp_230;
			Boolean f_tmp_231 = lib.and(__tmp177,__tmp213);
			Boolean __tmp214 = f_tmp_231;
			Boolean[] f_tmp_232 = depth[i];
			Boolean[] __tmp215 = f_tmp_232;
			Boolean[] f_tmp_233 = lib.mux(nowDepth, __tmp215,__tmp214);
			Boolean[] __tmp216 = f_tmp_233;
			nowDepth = __tmp216;
			Boolean f_tmp_234 = lib.not(__tmp213);
			Boolean __tmp217 = f_tmp_234;
			Boolean f_tmp_235 = lib.and(__tmp177,__tmp217);
			Boolean __tmp218 = f_tmp_235;
			int f_tmp_236 = 1;
			int __tmp219 = f_tmp_236;
			Boolean[] f_tmp_238 = env.inputOfAlice(Utils.fromInt(__tmp219, (m)+(1)));
			Boolean[] f_tmp_237 = lib.add(nowDepth,f_tmp_238);
			Boolean[] __tmp220 = f_tmp_237;
			Boolean[] f_tmp_239 = lib.mux(nowDepth, __tmp220,__tmp177);
			Boolean[] __tmp221 = f_tmp_239;
			nowDepth = __tmp221;
			Boolean[] f_tmp_240 = lib.sub(rd,ld);
			Boolean[] __tmp222 = f_tmp_240;
			int f_tmp_241 = 2;
			int __tmp223 = f_tmp_241;
			Boolean[] f_tmp_243 = env.inputOfAlice(Utils.fromInt(__tmp223, (m)+(1)));
			Boolean f_tmp_242 = lib.geq(__tmp222, f_tmp_243);
			Boolean __tmp224 = f_tmp_242;
			Boolean f_tmp_244 = lib.and(__tmp177,__tmp224);
			Boolean __tmp225 = f_tmp_244;
			Boolean[] __tmp226 = nid.pos;
			Boolean[] __tmp227 = nid.id;
			Boolean[] f_tmp_245 = lib.mux(id, __tmp227,__tmp225);
			Boolean[] __tmp228 = f_tmp_245;
			id = __tmp228;
			Boolean[] f_tmp_246 = lib.mux(pos, __tmp226,__tmp225);
			Boolean[] __tmp229 = f_tmp_246;
			pos = __tmp229;
			CircuitOram<Boolean> f_tmp_247 = this.poram;
			CircuitOram<Boolean> __tmp230 = f_tmp_247;
			AVLNode<K, V> f_tmp_248 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV).newObj(__tmp230.conditionalReadAndRemove(id, pos, __tmp225));
			AVLNode<K, V> __tmp231 = f_tmp_248;
			AVLNode<K, V> f_tmp_249 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV).newObj(lib.mux(tnodes.getBits(), __tmp231.getBits(),__tmp225));
			AVLNode<K, V> __tmp232 = f_tmp_249;
			tnodes = __tmp232;
			boolean f_tmp_250 = false;
			boolean __tmp233 = f_tmp_250;
			IntStack f_tmp_251 = this.IDs;
			IntStack __tmp234 = f_tmp_251;
			Boolean[] f_tmp_252 = __tmp234.stack_op(id, env.inputOfAlice(__tmp233), __tmp225);
			Boolean[] __tmp235 = f_tmp_252;
			AVLId __tmp236 = tnodes.left;
			Boolean[] __tmp237 = tnodes.rDepth;
			AVLId __tmp238 = tnodes.right;
			V __tmp239 = tnodes.value;
			K __tmp240 = tnodes.key;
			Boolean[] __tmp241 = tnodes.lDepth;
			K f_tmp_253 = this.factoryK.newObj(lib.mux(k.getBits(), __tmp240.getBits(),__tmp225));
			K __tmp242 = f_tmp_253;
			k = __tmp242;
			V f_tmp_254 = this.factoryV.newObj(lib.mux(v.getBits(), __tmp239.getBits(),__tmp225));
			V __tmp243 = f_tmp_254;
			v = __tmp243;
			Boolean[] f_tmp_255 = lib.mux(dc, __tmp241,__tmp225);
			Boolean[] __tmp244 = f_tmp_255;
			dc = __tmp244;
			AVLId f_tmp_256 = new AVLId(env, lib, m).newObj(lib.mux(c.getBits(), __tmp236.getBits(),__tmp225));
			AVLId __tmp245 = f_tmp_256;
			c = __tmp245;
			AVLId f_tmp_257 = new AVLId(env, lib, m).newObj(lib.mux(l.getBits(), __tmp238.getBits(),__tmp225));
			AVLId __tmp246 = f_tmp_257;
			l = __tmp246;
			Boolean[] __tmp247 = l.pos;
			Boolean[] __tmp248 = l.id;
			Boolean[] f_tmp_258 = lib.mux(id, __tmp248,__tmp225);
			Boolean[] __tmp249 = f_tmp_258;
			id = __tmp249;
			Boolean[] f_tmp_259 = lib.mux(pos, __tmp247,__tmp225);
			Boolean[] __tmp250 = f_tmp_259;
			pos = __tmp250;
			CircuitOram<Boolean> f_tmp_260 = this.poram;
			CircuitOram<Boolean> __tmp251 = f_tmp_260;
			AVLNode<K, V> f_tmp_261 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV).newObj(__tmp251.conditionalReadAndRemove(id, pos, __tmp225));
			AVLNode<K, V> __tmp252 = f_tmp_261;
			AVLNode<K, V> f_tmp_262 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV).newObj(lib.mux(p.getBits(), __tmp252.getBits(),__tmp225));
			AVLNode<K, V> __tmp253 = f_tmp_262;
			p = __tmp253;
			boolean f_tmp_263 = false;
			boolean __tmp254 = f_tmp_263;
			IntStack f_tmp_264 = this.IDs;
			IntStack __tmp255 = f_tmp_264;
			Boolean[] f_tmp_265 = __tmp255.stack_op(id, env.inputOfAlice(__tmp254), __tmp225);
			Boolean[] __tmp256 = f_tmp_265;
			AVLId __tmp257 = p.left;
			Boolean[] __tmp258 = p.rDepth;
			AVLId __tmp259 = p.right;
			V __tmp260 = p.value;
			K __tmp261 = p.key;
			Boolean[] __tmp262 = p.lDepth;
			K f_tmp_266 = this.factoryK.newObj(lib.mux(kp.getBits(), __tmp261.getBits(),__tmp225));
			K __tmp263 = f_tmp_266;
			kp = __tmp263;
			V f_tmp_267 = this.factoryV.newObj(lib.mux(vp.getBits(), __tmp260.getBits(),__tmp225));
			V __tmp264 = f_tmp_267;
			vp = __tmp264;
			Boolean[] f_tmp_268 = lib.mux(dap, __tmp262,__tmp225);
			Boolean[] __tmp265 = f_tmp_268;
			dap = __tmp265;
			Boolean[] f_tmp_269 = lib.mux(dbp, __tmp258,__tmp225);
			Boolean[] __tmp266 = f_tmp_269;
			dbp = __tmp266;
			AVLId f_tmp_270 = new AVLId(env, lib, m).newObj(lib.mux(a.getBits(), __tmp257.getBits(),__tmp225));
			AVLId __tmp267 = f_tmp_270;
			a = __tmp267;
			AVLId f_tmp_271 = new AVLId(env, lib, m).newObj(lib.mux(b.getBits(), __tmp259.getBits(),__tmp225));
			AVLId __tmp268 = f_tmp_271;
			b = __tmp268;
			int f_tmp_272 = 0;
			int __tmp269 = f_tmp_272;
			boolean f_tmp_273 = true;
			boolean __tmp270 = f_tmp_273;
			IntStack f_tmp_274 = this.IDs;
			IntStack __tmp271 = f_tmp_274;
			Boolean[] f_tmp_275 = __tmp271.stack_op(env.inputOfAlice(Utils.fromInt(__tmp269, m)), env.inputOfAlice(__tmp270), __tmp225);
			Boolean[] __tmp272 = f_tmp_275;
			Boolean[] f_tmp_276 = lib.mux(id, __tmp272,__tmp225);
			Boolean[] __tmp273 = f_tmp_276;
			id = __tmp273;
			Boolean[] f_tmp_277 = lib.randBools(m);
			Boolean[] __tmp274 = f_tmp_277;
			Boolean[] f_tmp_278 = lib.mux(pos, __tmp274,__tmp225);
			Boolean[] __tmp275 = f_tmp_278;
			pos = __tmp275;
			Boolean[] f_tmp_279 = lib.mux(hpos, pos,__tmp225);
			Boolean[] __tmp276 = f_tmp_279;
			hpos = __tmp276;
			AVLNode<K, V> f_tmp_280 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV);
			f_tmp_280.left = c;
			f_tmp_280.rDepth = dap;
			f_tmp_280.right = a;
			f_tmp_280.value = v;
			f_tmp_280.key = k;
			f_tmp_280.lDepth = dc;
			AVLNode<K, V> __tmp277 = f_tmp_280;
			CircuitOram<Boolean> f_tmp_281 = this.poram;
			CircuitOram<Boolean> __tmp278 = f_tmp_281;
			__tmp278.conditionalPutBack(id, pos, __tmp277.getBits(), __tmp225);
			Boolean[] f_tmp_283 = lib.mux(dp, dc,__tmp225);
			Boolean[] __tmp280 = f_tmp_283;
			dp = __tmp280;
			Boolean f_tmp_284 = lib.not(lib.leq(dap, dp));
			Boolean __tmp281 = f_tmp_284;
			Boolean f_tmp_285 = lib.and(__tmp225,__tmp281);
			Boolean __tmp282 = f_tmp_285;
			Boolean[] f_tmp_286 = lib.mux(dp, dap,__tmp282);
			Boolean[] __tmp283 = f_tmp_286;
			dp = __tmp283;
			Boolean f_tmp_287 = lib.not(__tmp281);
			Boolean __tmp284 = f_tmp_287;
			Boolean f_tmp_288 = lib.and(__tmp225,__tmp284);
			Boolean __tmp285 = f_tmp_288;
			int f_tmp_289 = 1;
			int __tmp286 = f_tmp_289;
			Boolean[] f_tmp_291 = env.inputOfAlice(Utils.fromInt(__tmp286, (m)+(1)));
			Boolean[] f_tmp_290 = lib.add(dp,f_tmp_291);
			Boolean[] __tmp287 = f_tmp_290;
			Boolean[] f_tmp_292 = lib.mux(dp, __tmp287,__tmp225);
			Boolean[] __tmp288 = f_tmp_292;
			dp = __tmp288;
			AVLId f_tmp_293 = new AVLId(env, lib, m);
			f_tmp_293.pos = pos;
			f_tmp_293.id = id;
			AVLId __tmp289 = f_tmp_293;
			AVLId f_tmp_294 = new AVLId(env, lib, m).newObj(lib.mux(next.getBits(), __tmp289.getBits(),__tmp225));
			AVLId __tmp290 = f_tmp_294;
			next = __tmp290;
			int f_tmp_295 = 0;
			int __tmp291 = f_tmp_295;
			boolean f_tmp_296 = true;
			boolean __tmp292 = f_tmp_296;
			IntStack f_tmp_297 = this.IDs;
			IntStack __tmp293 = f_tmp_297;
			Boolean[] f_tmp_298 = __tmp293.stack_op(env.inputOfAlice(Utils.fromInt(__tmp291, m)), env.inputOfAlice(__tmp292), __tmp225);
			Boolean[] __tmp294 = f_tmp_298;
			Boolean[] f_tmp_299 = lib.mux(id, __tmp294,__tmp225);
			Boolean[] __tmp295 = f_tmp_299;
			id = __tmp295;
			Boolean[] f_tmp_300 = lib.randBools(m);
			Boolean[] __tmp296 = f_tmp_300;
			Boolean[] f_tmp_301 = lib.mux(pos, __tmp296,__tmp225);
			Boolean[] __tmp297 = f_tmp_301;
			pos = __tmp297;
			Boolean[] f_tmp_302 = lib.mux(hpos, pos,__tmp225);
			Boolean[] __tmp298 = f_tmp_302;
			hpos = __tmp298;
			AVLNode<K, V> f_tmp_303 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV);
			f_tmp_303.left = next;
			f_tmp_303.rDepth = dbp;
			f_tmp_303.right = b;
			f_tmp_303.value = vp;
			f_tmp_303.key = kp;
			f_tmp_303.lDepth = dp;
			AVLNode<K, V> __tmp299 = f_tmp_303;
			CircuitOram<Boolean> f_tmp_304 = this.poram;
			CircuitOram<Boolean> __tmp300 = f_tmp_304;
			__tmp300.conditionalPutBack(id, pos, __tmp299.getBits(), __tmp225);
			AVLId f_tmp_306 = new AVLId(env, lib, m);
			f_tmp_306.id = pos;
			AVLId __tmp302 = f_tmp_306;
			AVLId f_tmp_307 = new AVLId(env, lib, m).newObj(lib.mux(nid.getBits(), __tmp302.getBits(),__tmp225));
			AVLId __tmp303 = f_tmp_307;
			nid = __tmp303;
			Boolean[] f_tmp_308 = lib.mux(nowDepth, dp,__tmp225);
			Boolean[] __tmp304 = f_tmp_308;
			nowDepth = __tmp304;
			Boolean f_tmp_309 = lib.not(__tmp224);
			Boolean __tmp305 = f_tmp_309;
			Boolean f_tmp_310 = lib.and(__tmp177,__tmp305);
			Boolean __tmp306 = f_tmp_310;
			Boolean[] f_tmp_311 = lib.sub(ld,rd);
			Boolean[] __tmp307 = f_tmp_311;
			int f_tmp_312 = 2;
			int __tmp308 = f_tmp_312;
			Boolean[] f_tmp_314 = env.inputOfAlice(Utils.fromInt(__tmp308, (m)+(1)));
			Boolean f_tmp_313 = lib.geq(__tmp307, f_tmp_314);
			Boolean __tmp309 = f_tmp_313;
			Boolean f_tmp_315 = lib.and(__tmp306,__tmp309);
			Boolean __tmp310 = f_tmp_315;
			Boolean[] __tmp311 = nid.pos;
			Boolean[] __tmp312 = nid.id;
			Boolean[] f_tmp_316 = lib.mux(id, __tmp312,__tmp310);
			Boolean[] __tmp313 = f_tmp_316;
			id = __tmp313;
			Boolean[] f_tmp_317 = lib.mux(pos, __tmp311,__tmp310);
			Boolean[] __tmp314 = f_tmp_317;
			pos = __tmp314;
			CircuitOram<Boolean> f_tmp_318 = this.poram;
			CircuitOram<Boolean> __tmp315 = f_tmp_318;
			AVLNode<K, V> f_tmp_319 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV).newObj(__tmp315.conditionalReadAndRemove(id, pos, __tmp310));
			AVLNode<K, V> __tmp316 = f_tmp_319;
			AVLNode<K, V> f_tmp_320 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV).newObj(lib.mux(tnodes.getBits(), __tmp316.getBits(),__tmp310));
			AVLNode<K, V> __tmp317 = f_tmp_320;
			tnodes = __tmp317;
			boolean f_tmp_321 = false;
			boolean __tmp318 = f_tmp_321;
			IntStack f_tmp_322 = this.IDs;
			IntStack __tmp319 = f_tmp_322;
			Boolean[] f_tmp_323 = __tmp319.stack_op(id, env.inputOfAlice(__tmp318), __tmp310);
			Boolean[] __tmp320 = f_tmp_323;
			AVLId __tmp321 = tnodes.left;
			Boolean[] __tmp322 = tnodes.rDepth;
			AVLId __tmp323 = tnodes.right;
			V __tmp324 = tnodes.value;
			K __tmp325 = tnodes.key;
			Boolean[] __tmp326 = tnodes.lDepth;
			K f_tmp_324 = this.factoryK.newObj(lib.mux(k.getBits(), __tmp325.getBits(),__tmp310));
			K __tmp327 = f_tmp_324;
			k = __tmp327;
			V f_tmp_325 = this.factoryV.newObj(lib.mux(v.getBits(), __tmp324.getBits(),__tmp310));
			V __tmp328 = f_tmp_325;
			v = __tmp328;
			Boolean[] f_tmp_326 = lib.mux(dc, __tmp322,__tmp310);
			Boolean[] __tmp329 = f_tmp_326;
			dc = __tmp329;
			AVLId f_tmp_327 = new AVLId(env, lib, m).newObj(lib.mux(c.getBits(), __tmp323.getBits(),__tmp310));
			AVLId __tmp330 = f_tmp_327;
			c = __tmp330;
			AVLId f_tmp_328 = new AVLId(env, lib, m).newObj(lib.mux(l.getBits(), __tmp321.getBits(),__tmp310));
			AVLId __tmp331 = f_tmp_328;
			l = __tmp331;
			Boolean[] __tmp332 = l.pos;
			Boolean[] __tmp333 = l.id;
			Boolean[] f_tmp_329 = lib.mux(id, __tmp333,__tmp310);
			Boolean[] __tmp334 = f_tmp_329;
			id = __tmp334;
			Boolean[] f_tmp_330 = lib.mux(pos, __tmp332,__tmp310);
			Boolean[] __tmp335 = f_tmp_330;
			pos = __tmp335;
			CircuitOram<Boolean> f_tmp_331 = this.poram;
			CircuitOram<Boolean> __tmp336 = f_tmp_331;
			AVLNode<K, V> f_tmp_332 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV).newObj(__tmp336.conditionalReadAndRemove(id, pos, __tmp310));
			AVLNode<K, V> __tmp337 = f_tmp_332;
			AVLNode<K, V> f_tmp_333 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV).newObj(lib.mux(p.getBits(), __tmp337.getBits(),__tmp310));
			AVLNode<K, V> __tmp338 = f_tmp_333;
			p = __tmp338;
			boolean f_tmp_334 = false;
			boolean __tmp339 = f_tmp_334;
			IntStack f_tmp_335 = this.IDs;
			IntStack __tmp340 = f_tmp_335;
			Boolean[] f_tmp_336 = __tmp340.stack_op(id, env.inputOfAlice(__tmp339), __tmp310);
			Boolean[] __tmp341 = f_tmp_336;
			AVLId __tmp342 = p.left;
			Boolean[] __tmp343 = p.rDepth;
			AVLId __tmp344 = p.right;
			V __tmp345 = p.value;
			K __tmp346 = p.key;
			Boolean[] __tmp347 = p.lDepth;
			K f_tmp_337 = this.factoryK.newObj(lib.mux(kp.getBits(), __tmp346.getBits(),__tmp310));
			K __tmp348 = f_tmp_337;
			kp = __tmp348;
			V f_tmp_338 = this.factoryV.newObj(lib.mux(vp.getBits(), __tmp345.getBits(),__tmp310));
			V __tmp349 = f_tmp_338;
			vp = __tmp349;
			Boolean[] f_tmp_339 = lib.mux(dap, __tmp347,__tmp310);
			Boolean[] __tmp350 = f_tmp_339;
			dap = __tmp350;
			Boolean[] f_tmp_340 = lib.mux(dbp, __tmp343,__tmp310);
			Boolean[] __tmp351 = f_tmp_340;
			dbp = __tmp351;
			AVLId f_tmp_341 = new AVLId(env, lib, m).newObj(lib.mux(a.getBits(), __tmp342.getBits(),__tmp310));
			AVLId __tmp352 = f_tmp_341;
			a = __tmp352;
			AVLId f_tmp_342 = new AVLId(env, lib, m).newObj(lib.mux(b.getBits(), __tmp344.getBits(),__tmp310));
			AVLId __tmp353 = f_tmp_342;
			b = __tmp353;
			int f_tmp_343 = 0;
			int __tmp354 = f_tmp_343;
			boolean f_tmp_344 = true;
			boolean __tmp355 = f_tmp_344;
			IntStack f_tmp_345 = this.IDs;
			IntStack __tmp356 = f_tmp_345;
			Boolean[] f_tmp_346 = __tmp356.stack_op(env.inputOfAlice(Utils.fromInt(__tmp354, m)), env.inputOfAlice(__tmp355), __tmp310);
			Boolean[] __tmp357 = f_tmp_346;
			Boolean[] f_tmp_347 = lib.mux(id, __tmp357,__tmp310);
			Boolean[] __tmp358 = f_tmp_347;
			id = __tmp358;
			Boolean[] f_tmp_348 = lib.randBools(m);
			Boolean[] __tmp359 = f_tmp_348;
			Boolean[] f_tmp_349 = lib.mux(pos, __tmp359,__tmp310);
			Boolean[] __tmp360 = f_tmp_349;
			pos = __tmp360;
			Boolean[] f_tmp_350 = lib.mux(hpos, pos,__tmp310);
			Boolean[] __tmp361 = f_tmp_350;
			hpos = __tmp361;
			AVLNode<K, V> f_tmp_351 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV);
			f_tmp_351.left = b;
			f_tmp_351.rDepth = dc;
			f_tmp_351.right = c;
			f_tmp_351.value = v;
			f_tmp_351.key = k;
			f_tmp_351.lDepth = dbp;
			AVLNode<K, V> __tmp362 = f_tmp_351;
			CircuitOram<Boolean> f_tmp_352 = this.poram;
			CircuitOram<Boolean> __tmp363 = f_tmp_352;
			__tmp363.conditionalPutBack(id, pos, __tmp362.getBits(), __tmp310);
			Boolean[] f_tmp_354 = lib.mux(dp, dc,__tmp310);
			Boolean[] __tmp365 = f_tmp_354;
			dp = __tmp365;
			Boolean f_tmp_355 = lib.not(lib.leq(dbp, dp));
			Boolean __tmp366 = f_tmp_355;
			Boolean f_tmp_356 = lib.and(__tmp310,__tmp366);
			Boolean __tmp367 = f_tmp_356;
			Boolean[] f_tmp_357 = lib.mux(dp, dbp,__tmp367);
			Boolean[] __tmp368 = f_tmp_357;
			dp = __tmp368;
			Boolean f_tmp_358 = lib.not(__tmp366);
			Boolean __tmp369 = f_tmp_358;
			Boolean f_tmp_359 = lib.and(__tmp310,__tmp369);
			Boolean __tmp370 = f_tmp_359;
			int f_tmp_360 = 1;
			int __tmp371 = f_tmp_360;
			Boolean[] f_tmp_362 = env.inputOfAlice(Utils.fromInt(__tmp371, (m)+(1)));
			Boolean[] f_tmp_361 = lib.add(dp,f_tmp_362);
			Boolean[] __tmp372 = f_tmp_361;
			Boolean[] f_tmp_363 = lib.mux(dp, __tmp372,__tmp310);
			Boolean[] __tmp373 = f_tmp_363;
			dp = __tmp373;
			AVLId f_tmp_364 = new AVLId(env, lib, m);
			f_tmp_364.pos = pos;
			f_tmp_364.id = id;
			AVLId __tmp374 = f_tmp_364;
			AVLId f_tmp_365 = new AVLId(env, lib, m).newObj(lib.mux(next.getBits(), __tmp374.getBits(),__tmp310));
			AVLId __tmp375 = f_tmp_365;
			next = __tmp375;
			int f_tmp_366 = 0;
			int __tmp376 = f_tmp_366;
			boolean f_tmp_367 = true;
			boolean __tmp377 = f_tmp_367;
			IntStack f_tmp_368 = this.IDs;
			IntStack __tmp378 = f_tmp_368;
			Boolean[] f_tmp_369 = __tmp378.stack_op(env.inputOfAlice(Utils.fromInt(__tmp376, m)), env.inputOfAlice(__tmp377), __tmp310);
			Boolean[] __tmp379 = f_tmp_369;
			Boolean[] f_tmp_370 = lib.mux(id, __tmp379,__tmp310);
			Boolean[] __tmp380 = f_tmp_370;
			id = __tmp380;
			Boolean[] f_tmp_371 = lib.randBools(m);
			Boolean[] __tmp381 = f_tmp_371;
			Boolean[] f_tmp_372 = lib.mux(pos, __tmp381,__tmp310);
			Boolean[] __tmp382 = f_tmp_372;
			pos = __tmp382;
			Boolean[] f_tmp_373 = lib.mux(hpos, pos,__tmp310);
			Boolean[] __tmp383 = f_tmp_373;
			hpos = __tmp383;
			AVLNode<K, V> f_tmp_374 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV);
			f_tmp_374.left = a;
			f_tmp_374.rDepth = dp;
			f_tmp_374.right = next;
			f_tmp_374.value = vp;
			f_tmp_374.key = kp;
			f_tmp_374.lDepth = dap;
			AVLNode<K, V> __tmp384 = f_tmp_374;
			CircuitOram<Boolean> f_tmp_375 = this.poram;
			CircuitOram<Boolean> __tmp385 = f_tmp_375;
			__tmp385.conditionalPutBack(id, pos, __tmp384.getBits(), __tmp310);
			AVLId f_tmp_377 = new AVLId(env, lib, m);
			f_tmp_377.pos = pos;
			f_tmp_377.id = id;
			AVLId __tmp387 = f_tmp_377;
			AVLId f_tmp_378 = new AVLId(env, lib, m).newObj(lib.mux(nid.getBits(), __tmp387.getBits(),__tmp310));
			AVLId __tmp388 = f_tmp_378;
			nid = __tmp388;
			Boolean[] f_tmp_379 = lib.mux(nowDepth, dp,__tmp310);
			Boolean[] __tmp389 = f_tmp_379;
			nowDepth = __tmp389;
			Boolean f_tmp_380 = lib.not(__tmp309);
			Boolean __tmp390 = f_tmp_380;
			Boolean f_tmp_381 = lib.and(__tmp306,__tmp390);
			Boolean __tmp391 = f_tmp_381;
			Boolean f_tmp_382 = lib.not(__tmp177);
			Boolean __tmp392 = f_tmp_382;
			int f_tmp_383 = 1;
			int __tmp393 = f_tmp_383;
			int f_tmp_384 = i - __tmp393;
			int __tmp394 = f_tmp_384;
			i = __tmp394;
			int f_tmp_385 = 0;
			__tmp173 = f_tmp_385;
			boolean f_tmp_386 = i >= __tmp173;
			__tmp174 = f_tmp_386;
		}
		this.root = nid;

	}
	public V search(K key, V value, FUNC_1_INTsecure_T1_T1<K> cmp) throws Exception {
		AVLNode<K, V> tnodes = new AVLNode<K, V>(env, lib, m, factoryK, factoryV);
		AVLNode<K, V> p = new AVLNode<K, V>(env, lib, m, factoryK, factoryV);
		AVLId now = new AVLId(env, lib, m);
		AVLId go = new AVLId(env, lib, m);
		AVLId a = new AVLId(env, lib, m);
		AVLId b = new AVLId(env, lib, m);
		AVLId c = new AVLId(env, lib, m);
		AVLId[] left = (AVLId[])Array.newInstance((Class<AVLId>)(new AVLId(env, lib, m).getClass()), ((3)*(m))/(2));
		K[] keys = (K[])Array.newInstance((Class<K>)factoryK.getClass(), ((3)*(m))/(2));
		V[] values = (V[])Array.newInstance((Class<V>)factoryV.getClass(), ((3)*(m))/(2));
		Boolean[][] depth = new Boolean[((3)*(m))/(2)][];
		Boolean[][] ids = new Boolean[((3)*(m))/(2)][];
		Boolean[][] cres = new Boolean[((3)*(m))/(2)][];
		Boolean[] ind = env.inputOfAlice(Utils.fromInt(0, 2));
		Boolean[] id = env.inputOfAlice(Utils.fromInt(0, m));
		Boolean[] pos = env.inputOfAlice(Utils.fromInt(0, m));
		K k = factoryK.newObj(null);
		K kp = factoryK.newObj(null);
		V v = factoryV.newObj(null);
		V vp = factoryV.newObj(null);
		Boolean[] dl = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dr = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId lf = new AVLId(env, lib, m);
		AVLId rf = new AVLId(env, lib, m);
		V ret = factoryV.newObj(null);
		int i = 0;
		Boolean[] nowDepth = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] ld = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] rd = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId nid = new AVLId(env, lib, m);
		AVLId next = new AVLId(env, lib, m);
		AVLId ll = new AVLId(env, lib, m);
		AVLId rr = new AVLId(env, lib, m);
		Boolean[] hpos = env.inputOfAlice(Utils.fromInt(0, m));
		AVLId f_tmp_387 = this.root;
		AVLId __tmp395 = f_tmp_387;
		now = __tmp395;
		int f_tmp_388 = 0;
		int __tmp396 = f_tmp_388;
		ind = env.inputOfAlice(Utils.fromInt(__tmp396, 2));
		int f_tmp_389 = 0;
		int __tmp397 = f_tmp_389;
		i = __tmp397;
		int f_tmp_390 = 3;
		int __tmp398 = f_tmp_390;
		int f_tmp_391 = __tmp398 * m;
		int __tmp399 = f_tmp_391;
		int f_tmp_392 = 2;
		int __tmp400 = f_tmp_392;
		int f_tmp_393 = __tmp399 / __tmp400;
		int __tmp401 = f_tmp_393;
		boolean f_tmp_394 = i < __tmp401;
		boolean __tmp402 = f_tmp_394;
		while(__tmp402) {
			ids[i]=ind;
			int f_tmp_395 = 0;
			int __tmp403 = f_tmp_395;
			Boolean[] f_tmp_397 = env.inputOfAlice(Utils.fromInt(__tmp403, 2));
			Boolean f_tmp_396 = lib.eq(ind, f_tmp_397);
			Boolean __tmp404 = f_tmp_396;
			Boolean[] __tmp405 = now.pos;
			Boolean[] __tmp406 = now.id;
			Boolean[] f_tmp_398 = lib.mux(id, __tmp406,__tmp404);
			Boolean[] __tmp407 = f_tmp_398;
			id = __tmp407;
			Boolean[] f_tmp_399 = lib.mux(pos, __tmp405,__tmp404);
			Boolean[] __tmp408 = f_tmp_399;
			pos = __tmp408;
			CircuitOram<Boolean> f_tmp_400 = this.poram;
			CircuitOram<Boolean> __tmp409 = f_tmp_400;
			AVLNode<K, V> f_tmp_401 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV).newObj(__tmp409.conditionalReadAndRemove(id, pos, __tmp404));
			AVLNode<K, V> __tmp410 = f_tmp_401;
			AVLNode<K, V> f_tmp_402 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV).newObj(lib.mux(tnodes.getBits(), __tmp410.getBits(),__tmp404));
			AVLNode<K, V> __tmp411 = f_tmp_402;
			tnodes = __tmp411;
			boolean f_tmp_403 = false;
			boolean __tmp412 = f_tmp_403;
			IntStack f_tmp_404 = this.IDs;
			IntStack __tmp413 = f_tmp_404;
			Boolean[] f_tmp_405 = __tmp413.stack_op(id, env.inputOfAlice(__tmp412), __tmp404);
			Boolean[] __tmp414 = f_tmp_405;
			AVLId __tmp415 = tnodes.left;
			Boolean[] __tmp416 = tnodes.rDepth;
			AVLId __tmp417 = tnodes.right;
			V __tmp418 = tnodes.value;
			K __tmp419 = tnodes.key;
			Boolean[] __tmp420 = tnodes.lDepth;
			K f_tmp_406 = keys[i];
			K __tmp421 = f_tmp_406;
			K f_tmp_407 = this.factoryK.newObj(lib.mux(__tmp421.getBits(), __tmp419.getBits(),__tmp404));
			K __tmp422 = f_tmp_407;
			keys[i]=__tmp422;
			V f_tmp_408 = values[i];
			V __tmp423 = f_tmp_408;
			V f_tmp_409 = this.factoryV.newObj(lib.mux(__tmp423.getBits(), __tmp418.getBits(),__tmp404));
			V __tmp424 = f_tmp_409;
			values[i]=__tmp424;
			Boolean[] f_tmp_410 = lib.mux(ld, __tmp420,__tmp404);
			Boolean[] __tmp425 = f_tmp_410;
			ld = __tmp425;
			Boolean[] f_tmp_411 = lib.mux(rd, __tmp416,__tmp404);
			Boolean[] __tmp426 = f_tmp_411;
			rd = __tmp426;
			AVLId f_tmp_412 = new AVLId(env, lib, m).newObj(lib.mux(lf.getBits(), __tmp415.getBits(),__tmp404));
			AVLId __tmp427 = f_tmp_412;
			lf = __tmp427;
			AVLId f_tmp_413 = new AVLId(env, lib, m).newObj(lib.mux(rf.getBits(), __tmp417.getBits(),__tmp404));
			AVLId __tmp428 = f_tmp_413;
			rf = __tmp428;
			Boolean f_tmp_414 = lib.not(__tmp404);
			Boolean __tmp429 = f_tmp_414;
			int f_tmp_415 = 0;
			int __tmp430 = f_tmp_415;
			int f_tmp_416 = 1;
			int __tmp431 = f_tmp_416;
			int f_tmp_417 = __tmp430 - __tmp431;
			int __tmp432 = f_tmp_417;
			Boolean[] f_tmp_418 = depth[i];
			Boolean[] __tmp433 = f_tmp_418;
			Boolean[] f_tmp_420 = env.inputOfAlice(Utils.fromInt(__tmp432, (m)+(1)));
			Boolean[] f_tmp_419 = lib.mux(__tmp433, f_tmp_420,__tmp429);
			Boolean[] __tmp434 = f_tmp_419;
			depth[i]=__tmp434;
			int f_tmp_421 = 1;
			int __tmp435 = f_tmp_421;
			int f_tmp_422 = i - __tmp435;
			int __tmp436 = f_tmp_422;
			K f_tmp_423 = keys[__tmp436];
			K __tmp437 = f_tmp_423;
			K f_tmp_424 = keys[i];
			K __tmp438 = f_tmp_424;
			K f_tmp_425 = this.factoryK.newObj(lib.mux(__tmp438.getBits(), __tmp437.getBits(),__tmp429));
			K __tmp439 = f_tmp_425;
			keys[i]=__tmp439;
			K f_tmp_426 = keys[i];
			K __tmp440 = f_tmp_426;
			Boolean[] f_tmp_427 = cmp.calc(__tmp440, key);
			Boolean[] __tmp441 = f_tmp_427;
			cres[i]=__tmp441;
			int f_tmp_428 = 0;
			int __tmp442 = f_tmp_428;
			Boolean[] f_tmp_430 = env.inputOfAlice(Utils.fromInt(__tmp442, 2));
			Boolean f_tmp_429 = lib.eq(ind, f_tmp_430);
			Boolean __tmp443 = f_tmp_429;
			Boolean[] f_tmp_431 = cres[i];
			Boolean[] __tmp444 = f_tmp_431;
			int f_tmp_432 = 0;
			int __tmp445 = f_tmp_432;
			Boolean[] f_tmp_434 = env.inputOfAlice(Utils.fromInt(__tmp445, 2));
			Boolean f_tmp_433 = lib.not(lib.leq(__tmp444, f_tmp_434));
			Boolean __tmp446 = f_tmp_433;
			Boolean f_tmp_435 = lib.and(__tmp443,__tmp446);
			Boolean __tmp447 = f_tmp_435;
			Boolean[] f_tmp_436 = depth[i];
			Boolean[] __tmp448 = f_tmp_436;
			Boolean[] f_tmp_437 = lib.mux(__tmp448, dr,__tmp447);
			Boolean[] __tmp449 = f_tmp_437;
			depth[i]=__tmp449;
			AVLId f_tmp_438 = new AVLId(env, lib, m).newObj(lib.mux(go.getBits(), lf.getBits(),__tmp447));
			AVLId __tmp450 = f_tmp_438;
			go = __tmp450;
			AVLId f_tmp_439 = left[i];
			AVLId __tmp451 = f_tmp_439;
			AVLId f_tmp_440 = new AVLId(env, lib, m).newObj(lib.mux(__tmp451.getBits(), rf.getBits(),__tmp447));
			AVLId __tmp452 = f_tmp_440;
			left[i]=__tmp452;
			Boolean f_tmp_441 = lib.not(__tmp446);
			Boolean __tmp453 = f_tmp_441;
			Boolean f_tmp_442 = lib.and(__tmp443,__tmp453);
			Boolean __tmp454 = f_tmp_442;
			Boolean[] f_tmp_443 = depth[i];
			Boolean[] __tmp455 = f_tmp_443;
			Boolean[] f_tmp_444 = lib.mux(__tmp455, dl,__tmp454);
			Boolean[] __tmp456 = f_tmp_444;
			depth[i]=__tmp456;
			AVLId f_tmp_445 = new AVLId(env, lib, m).newObj(lib.mux(go.getBits(), rf.getBits(),__tmp454));
			AVLId __tmp457 = f_tmp_445;
			go = __tmp457;
			AVLId f_tmp_446 = left[i];
			AVLId __tmp458 = f_tmp_446;
			AVLId f_tmp_447 = new AVLId(env, lib, m).newObj(lib.mux(__tmp458.getBits(), lf.getBits(),__tmp454));
			AVLId __tmp459 = f_tmp_447;
			left[i]=__tmp459;
			Boolean[] f_tmp_448 = cres[i];
			Boolean[] __tmp460 = f_tmp_448;
			int f_tmp_449 = 0;
			int __tmp461 = f_tmp_449;
			Boolean[] f_tmp_451 = env.inputOfAlice(Utils.fromInt(__tmp461, 2));
			Boolean f_tmp_450 = lib.eq(__tmp460, f_tmp_451);
			Boolean __tmp462 = f_tmp_450;
			Boolean f_tmp_452 = lib.and(__tmp443,__tmp462);
			Boolean __tmp463 = f_tmp_452;
			V f_tmp_453 = this.factoryV.newObj(lib.mux(ret.getBits(), value.getBits(),__tmp463));
			V __tmp464 = f_tmp_453;
			ret = __tmp464;
			int f_tmp_454 = 1;
			int __tmp465 = f_tmp_454;
			Boolean[] f_tmp_456 = env.inputOfAlice(Utils.fromInt(__tmp465, 2));
			Boolean[] f_tmp_455 = lib.mux(ind, f_tmp_456,__tmp463);
			Boolean[] __tmp466 = f_tmp_455;
			ind = __tmp466;
			Boolean f_tmp_457 = lib.not(__tmp462);
			Boolean __tmp467 = f_tmp_457;
			Boolean f_tmp_458 = lib.and(__tmp443,__tmp467);
			Boolean __tmp468 = f_tmp_458;
			AVLId f_tmp_459 = new AVLId(env, lib, m).newObj(lib.mux(now.getBits(), go.getBits(),__tmp443));
			AVLId __tmp469 = f_tmp_459;
			now = __tmp469;
			Boolean[] f_tmp_460 = now.id;
			Boolean[] __tmp470 = f_tmp_460;
			int f_tmp_461 = 0;
			int __tmp471 = f_tmp_461;
			Boolean[] f_tmp_463 = env.inputOfAlice(Utils.fromInt(__tmp471, m));
			Boolean f_tmp_462 = lib.eq(__tmp470, f_tmp_463);
			Boolean __tmp472 = f_tmp_462;
			Boolean f_tmp_464 = lib.and(__tmp443,__tmp472);
			Boolean __tmp473 = f_tmp_464;
			int f_tmp_465 = 1;
			int __tmp474 = f_tmp_465;
			Boolean[] f_tmp_467 = env.inputOfAlice(Utils.fromInt(__tmp474, 2));
			Boolean[] f_tmp_466 = lib.mux(ind, f_tmp_467,__tmp473);
			Boolean[] __tmp475 = f_tmp_466;
			ind = __tmp475;
			Boolean f_tmp_468 = lib.not(__tmp472);
			Boolean __tmp476 = f_tmp_468;
			Boolean f_tmp_469 = lib.and(__tmp443,__tmp476);
			Boolean __tmp477 = f_tmp_469;
			Boolean f_tmp_470 = lib.not(__tmp443);
			Boolean __tmp478 = f_tmp_470;
			int f_tmp_471 = 1;
			int __tmp479 = f_tmp_471;
			int f_tmp_472 = i + __tmp479;
			int __tmp480 = f_tmp_472;
			i = __tmp480;
			int f_tmp_473 = 3;
			__tmp398 = f_tmp_473;
			int f_tmp_474 = __tmp398 * m;
			__tmp399 = f_tmp_474;
			int f_tmp_475 = 2;
			__tmp400 = f_tmp_475;
			int f_tmp_476 = __tmp399 / __tmp400;
			__tmp401 = f_tmp_476;
			boolean f_tmp_477 = i < __tmp401;
			__tmp402 = f_tmp_477;
		}
		int f_tmp_478 = 0;
		int __tmp481 = f_tmp_478;
		int f_tmp_479 = 1;
		int __tmp482 = f_tmp_479;
		int f_tmp_480 = __tmp481 - __tmp482;
		int __tmp483 = f_tmp_480;
		nowDepth = env.inputOfAlice(Utils.fromInt(__tmp483, (m)+(1)));
		nid = now;
		int f_tmp_481 = 3;
		int __tmp484 = f_tmp_481;
		int f_tmp_482 = __tmp484 * m;
		int __tmp485 = f_tmp_482;
		int f_tmp_483 = 2;
		int __tmp486 = f_tmp_483;
		int f_tmp_484 = __tmp485 / __tmp486;
		int __tmp487 = f_tmp_484;
		int f_tmp_485 = 1;
		int __tmp488 = f_tmp_485;
		int f_tmp_486 = __tmp487 - __tmp488;
		int __tmp489 = f_tmp_486;
		i = __tmp489;
		int f_tmp_487 = 0;
		int __tmp490 = f_tmp_487;
		boolean f_tmp_488 = i >= __tmp490;
		boolean __tmp491 = f_tmp_488;
		while(__tmp491) {
			Boolean[] f_tmp_489 = ids[i];
			Boolean[] __tmp492 = f_tmp_489;
			int f_tmp_490 = 0;
			int __tmp493 = f_tmp_490;
			Boolean[] f_tmp_492 = env.inputOfAlice(Utils.fromInt(__tmp493, 2));
			Boolean f_tmp_491 = lib.eq(__tmp492, f_tmp_492);
			Boolean __tmp494 = f_tmp_491;
			int f_tmp_493 = 0;
			int __tmp495 = f_tmp_493;
			boolean f_tmp_494 = true;
			boolean __tmp496 = f_tmp_494;
			IntStack f_tmp_495 = this.IDs;
			IntStack __tmp497 = f_tmp_495;
			Boolean[] f_tmp_496 = __tmp497.stack_op(env.inputOfAlice(Utils.fromInt(__tmp495, m)), env.inputOfAlice(__tmp496), __tmp494);
			Boolean[] __tmp498 = f_tmp_496;
			Boolean[] f_tmp_497 = lib.mux(id, __tmp498,__tmp494);
			Boolean[] __tmp499 = f_tmp_497;
			id = __tmp499;
			Boolean[] f_tmp_498 = lib.randBools(m);
			Boolean[] __tmp500 = f_tmp_498;
			Boolean[] f_tmp_499 = lib.mux(pos, __tmp500,__tmp494);
			Boolean[] __tmp501 = f_tmp_499;
			pos = __tmp501;
			Boolean[] f_tmp_500 = lib.mux(hpos, pos,__tmp494);
			Boolean[] __tmp502 = f_tmp_500;
			hpos = __tmp502;
			AVLId f_tmp_501 = new AVLId(env, lib, m);
			f_tmp_501.pos = pos;
			f_tmp_501.id = id;
			AVLId __tmp503 = f_tmp_501;
			AVLId f_tmp_502 = new AVLId(env, lib, m).newObj(lib.mux(next.getBits(), __tmp503.getBits(),__tmp494));
			AVLId __tmp504 = f_tmp_502;
			next = __tmp504;
			Boolean[] f_tmp_503 = cres[i];
			Boolean[] __tmp505 = f_tmp_503;
			int f_tmp_504 = 0;
			int __tmp506 = f_tmp_504;
			Boolean[] f_tmp_506 = env.inputOfAlice(Utils.fromInt(__tmp506, 2));
			Boolean f_tmp_505 = lib.geq(__tmp505, f_tmp_506);
			Boolean __tmp507 = f_tmp_505;
			Boolean f_tmp_507 = lib.and(__tmp494,__tmp507);
			Boolean __tmp508 = f_tmp_507;
			Boolean[] f_tmp_508 = lib.mux(ld, nowDepth,__tmp508);
			Boolean[] __tmp509 = f_tmp_508;
			ld = __tmp509;
			Boolean[] f_tmp_509 = depth[i];
			Boolean[] __tmp510 = f_tmp_509;
			Boolean[] f_tmp_510 = lib.mux(rd, __tmp510,__tmp508);
			Boolean[] __tmp511 = f_tmp_510;
			rd = __tmp511;
			AVLId f_tmp_511 = new AVLId(env, lib, m).newObj(lib.mux(ll.getBits(), nid.getBits(),__tmp508));
			AVLId __tmp512 = f_tmp_511;
			ll = __tmp512;
			AVLId f_tmp_512 = left[i];
			AVLId __tmp513 = f_tmp_512;
			AVLId f_tmp_513 = new AVLId(env, lib, m).newObj(lib.mux(rr.getBits(), __tmp513.getBits(),__tmp508));
			AVLId __tmp514 = f_tmp_513;
			rr = __tmp514;
			Boolean f_tmp_514 = lib.not(__tmp507);
			Boolean __tmp515 = f_tmp_514;
			Boolean f_tmp_515 = lib.and(__tmp494,__tmp515);
			Boolean __tmp516 = f_tmp_515;
			Boolean[] f_tmp_516 = depth[i];
			Boolean[] __tmp517 = f_tmp_516;
			Boolean[] f_tmp_517 = lib.mux(ld, __tmp517,__tmp516);
			Boolean[] __tmp518 = f_tmp_517;
			ld = __tmp518;
			Boolean[] f_tmp_518 = lib.mux(rd, nowDepth,__tmp516);
			Boolean[] __tmp519 = f_tmp_518;
			rd = __tmp519;
			AVLId f_tmp_519 = left[i];
			AVLId __tmp520 = f_tmp_519;
			AVLId f_tmp_520 = new AVLId(env, lib, m).newObj(lib.mux(ll.getBits(), __tmp520.getBits(),__tmp516));
			AVLId __tmp521 = f_tmp_520;
			ll = __tmp521;
			AVLId f_tmp_521 = new AVLId(env, lib, m).newObj(lib.mux(rr.getBits(), nid.getBits(),__tmp516));
			AVLId __tmp522 = f_tmp_521;
			rr = __tmp522;
			AVLId f_tmp_522 = new AVLId(env, lib, m).newObj(lib.mux(nid.getBits(), next.getBits(),__tmp494));
			AVLId __tmp523 = f_tmp_522;
			nid = __tmp523;
			V f_tmp_523 = values[i];
			V __tmp524 = f_tmp_523;
			K f_tmp_524 = keys[i];
			K __tmp525 = f_tmp_524;
			AVLNode<K, V> f_tmp_525 = new AVLNode<K, V>(env, lib, m, factoryK, factoryV);
			f_tmp_525.left = ll;
			f_tmp_525.rDepth = rd;
			f_tmp_525.right = rr;
			f_tmp_525.value = __tmp524;
			f_tmp_525.key = __tmp525;
			f_tmp_525.lDepth = ld;
			AVLNode<K, V> __tmp526 = f_tmp_525;
			CircuitOram<Boolean> f_tmp_526 = this.poram;
			CircuitOram<Boolean> __tmp527 = f_tmp_526;
			__tmp527.conditionalPutBack(id, pos, __tmp526.getBits(), __tmp494);
			Boolean[] f_tmp_528 = depth[i];
			Boolean[] __tmp529 = f_tmp_528;
			Boolean f_tmp_529 = lib.not(lib.leq(__tmp529, nowDepth));
			Boolean __tmp530 = f_tmp_529;
			Boolean f_tmp_530 = lib.and(__tmp494,__tmp530);
			Boolean __tmp531 = f_tmp_530;
			Boolean[] f_tmp_531 = depth[i];
			Boolean[] __tmp532 = f_tmp_531;
			Boolean[] f_tmp_532 = lib.mux(nowDepth, __tmp532,__tmp531);
			Boolean[] __tmp533 = f_tmp_532;
			nowDepth = __tmp533;
			Boolean f_tmp_533 = lib.not(__tmp530);
			Boolean __tmp534 = f_tmp_533;
			Boolean f_tmp_534 = lib.and(__tmp494,__tmp534);
			Boolean __tmp535 = f_tmp_534;
			int f_tmp_535 = 1;
			int __tmp536 = f_tmp_535;
			Boolean[] f_tmp_537 = env.inputOfAlice(Utils.fromInt(__tmp536, (m)+(1)));
			Boolean[] f_tmp_536 = lib.add(nowDepth,f_tmp_537);
			Boolean[] __tmp537 = f_tmp_536;
			Boolean[] f_tmp_538 = lib.mux(nowDepth, __tmp537,__tmp494);
			Boolean[] __tmp538 = f_tmp_538;
			nowDepth = __tmp538;
			Boolean f_tmp_539 = lib.not(__tmp494);
			Boolean __tmp539 = f_tmp_539;
			int f_tmp_540 = 1;
			int __tmp540 = f_tmp_540;
			int f_tmp_541 = i - __tmp540;
			int __tmp541 = f_tmp_541;
			i = __tmp541;
			int f_tmp_542 = 0;
			__tmp490 = f_tmp_542;
			boolean f_tmp_543 = i >= __tmp490;
			__tmp491 = f_tmp_543;
		}
		this.root = nid;
		return ret;
	}
}
