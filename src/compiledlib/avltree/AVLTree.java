package compiledlib.avltree;
import java.security.SecureRandom;

import oram.CircuitOram;
import oram.SecureArray;
import flexsc.Mode;
import flexsc.Party;
import flexsc.CompEnv;

import java.util.BitSet;

import circuits.arithmetic.IntegerLib;
import circuits.arithmetic.FloatLib;
import util.Utils;
import gc.regular.GCEva;
import gc.regular.GCGen;
import gc.GCSignal;

import java.util.Arrays;
import java.util.Random;

import flexsc.IWritable;
import flexsc.Comparator;

import java.lang.reflect.Array;
public class AVLTree<K extends IWritable<K,Boolean>, V extends IWritable<V,Boolean>> {
	public CircuitOram<Boolean> poram;
	public Boolean[] total;
	public AVLId root;

	public CompEnv<Boolean> env;
	public IntegerLib<Boolean> intLib;
	public FloatLib<Boolean> floatLib;
	private K factoryK;
	private V factoryV;
	private int m;

	public AVLTree(CompEnv<Boolean> env, int m, K factoryK, V factoryV, CircuitOram<Boolean> poram) throws Exception {
		this.env = env;
		this.intLib = new IntegerLib<Boolean>(env);
		this.floatLib = new FloatLib<Boolean>(env, 24, 8);
		this.m = m;
		this.factoryK = factoryK;
		this.factoryV = factoryV;
		this.poram = poram;
		this.total = env.inputOfAlice(Utils.fromInt(0, 32));
		this.root = new AVLId(env, m);
	}

	public void init() throws Exception {
		int f_tmp_0 = 0;
		int __tmp17 = f_tmp_0;
		Boolean[] f_tmp_1 = env.inputOfAlice(Utils.fromInt(__tmp17, 32));
		this.total = f_tmp_1;
		Boolean[] f_tmp_2 = intLib.randBools(m);
		Boolean[] __tmp18 = f_tmp_2;
		int f_tmp_3 = 0;
		int __tmp19 = f_tmp_3;
		AVLId f_tmp_4 = new AVLId(env, m);
		f_tmp_4.pos = __tmp18;
		f_tmp_4.id = env.inputOfAlice(Utils.fromInt(__tmp19, 32));
		AVLId __tmp20 = f_tmp_4;
		this.root = __tmp20;

	}
	public void insert(K key, V value, FUNC_1_INTsecure_T1_T1<K> cmp) throws Exception {
		AVLNode<K, V> tnodes = new AVLNode<K, V>(env, m, factoryK, factoryV);
		AVLNode<K, V> p = new AVLNode<K, V>(env, m, factoryK, factoryV);
		AVLId now = new AVLId(env, m);
		AVLId go = new AVLId(env, m);
		AVLId a = new AVLId(env, m);
		AVLId b = new AVLId(env, m);
		AVLId c = new AVLId(env, m);
		AVLId[] left = (AVLId[])Array.newInstance((Class<AVLId>)(new AVLId(env, m).getClass()), ((3)*(m))/(2));
		for(int _j_2 = 0; _j_2 < ((3)*(m))/(2); ++_j_2) {
			left[_j_2] = new AVLId(env, m);
		}
		K[] keys = (K[])Array.newInstance((Class<K>)factoryK.getClass(), ((3)*(m))/(2));
		for(int _j_2 = 0; _j_2 < ((3)*(m))/(2); ++_j_2) {
			keys[_j_2] = factoryK.newObj(null);
		}
		V[] values = (V[])Array.newInstance((Class<V>)factoryV.getClass(), ((3)*(m))/(2));
		for(int _j_2 = 0; _j_2 < ((3)*(m))/(2); ++_j_2) {
			values[_j_2] = factoryV.newObj(null);
		}
		Boolean[][] depth = new Boolean[((3)*(m))/(2)][];
		for(int _j_2 = 0; _j_2 < ((3)*(m))/(2); ++_j_2) {
			depth[_j_2] = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		}
		Boolean[][] ids = new Boolean[((3)*(m))/(2)][];
		for(int _j_2 = 0; _j_2 < ((3)*(m))/(2); ++_j_2) {
			ids[_j_2] = env.inputOfAlice(Utils.fromInt(0, 2));
		}
		Boolean[][] cres = new Boolean[((3)*(m))/(2)][];
		for(int _j_2 = 0; _j_2 < ((3)*(m))/(2); ++_j_2) {
			cres[_j_2] = env.inputOfAlice(Utils.fromInt(0, 2));
		}
		Boolean[] ind = env.inputOfAlice(Utils.fromInt(0, 2));
		Boolean[] id = env.inputOfAlice(Utils.fromInt(0, 32));
		Boolean[] oid = env.inputOfAlice(Utils.fromInt(0, 32));
		Boolean[] pos = intLib.randBools(m);
		Boolean[] hpos = env.inputOfAlice(Utils.fromInt(0, m));
		K k = factoryK.newObj(null);
		K kp = factoryK.newObj(null);
		V v = factoryV.newObj(null);
		V vp = factoryV.newObj(null);
		AVLId lf = new AVLId(env, m);
		AVLId rf = new AVLId(env, m);
		int i = 0;
		int pre = 0;
		Boolean[] nowDepth = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] ld = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] rd = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dc = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dap = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dbp = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId nid = new AVLId(env, m);
		AVLId next = new AVLId(env, m);
		AVLId ll = new AVLId(env, m);
		AVLId rr = new AVLId(env, m);
		AVLId l = new AVLId(env, m);
		AVLNode<K, V> nowInsertNode = new AVLNode<K, V>(env, m, factoryK, factoryV);
		Boolean RDgeqLD = env.inputOfAlice(false);
		Boolean LDgeqRD = env.inputOfAlice(false);
		Boolean execute = env.inputOfAlice(false);
		AVLNode<K, V> insertNode = new AVLNode<K, V>(env, m, factoryK, factoryV);
		Boolean[] dp = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId f_tmp_5 = this.root;
		AVLId __tmp21 = f_tmp_5;
		now = __tmp21;
		int f_tmp_6 = 0;
		int __tmp22 = f_tmp_6;
		ind = env.inputOfAlice(Utils.fromInt(__tmp22, 2));
		Boolean[] __tmp23 = now.pos;
		Boolean[] __tmp24 = now.id;
		id = __tmp24;
		pos = __tmp23;
		int f_tmp_7 = 0;
		int __tmp25 = f_tmp_7;
		Boolean[] f_tmp_9 = env.inputOfAlice(Utils.fromInt(__tmp25, 32));
		Boolean f_tmp_8 = intLib.eq(id, f_tmp_9);
		Boolean __tmp26 = f_tmp_8;
		int f_tmp_10 = 1;
		int __tmp27 = f_tmp_10;
		Boolean[] f_tmp_12 = env.inputOfAlice(Utils.fromInt(__tmp27, 2));
		Boolean[] f_tmp_11 = intLib.mux(ind, f_tmp_12,__tmp26);
		Boolean[] __tmp28 = f_tmp_11;
		ind = __tmp28;
		Boolean f_tmp_13 = intLib.not(__tmp26);
		Boolean __tmp29 = f_tmp_13;
		AVLId f_tmp_14 = new AVLId(env, m);
		f_tmp_14.pos = pos;
		f_tmp_14.id = id;
		AVLId __tmp30 = f_tmp_14;
		now = __tmp30;
		int f_tmp_15 = 0;
		int __tmp31 = f_tmp_15;
		i = __tmp31;
		int f_tmp_16 = 3;
		int __tmp32 = f_tmp_16;
		int f_tmp_17 = __tmp32 * m;
		int __tmp33 = f_tmp_17;
		int f_tmp_18 = 2;
		int __tmp34 = f_tmp_18;
		int f_tmp_19 = __tmp33 / __tmp34;
		int __tmp35 = f_tmp_19;
		boolean f_tmp_20 = i < __tmp35;
		boolean __tmp36 = f_tmp_20;
		while(__tmp36) {
			ids[i]=ind;
			int f_tmp_21 = 1;
			int __tmp37 = f_tmp_21;
			int f_tmp_22 = i - __tmp37;
			int __tmp38 = f_tmp_22;
			pre = __tmp38;
			int f_tmp_23 = 0;
			int __tmp39 = f_tmp_23;
			boolean f_tmp_24 = i == __tmp39;
			boolean __tmp40 = f_tmp_24;
			if(__tmp40) {
				int f_tmp_25 = 0;
				int __tmp41 = f_tmp_25;
				pre = __tmp41;
			} else {
			}
			int f_tmp_26 = 0;
			int __tmp42 = f_tmp_26;
			Boolean[] f_tmp_28 = env.inputOfAlice(Utils.fromInt(__tmp42, 2));
			Boolean f_tmp_27 = intLib.eq(ind, f_tmp_28);
			Boolean __tmp43 = f_tmp_27;
			Boolean[] __tmp44 = now.pos;
			Boolean[] __tmp45 = now.id;
			Boolean[] f_tmp_29 = intLib.mux(id, __tmp45,__tmp43);
			Boolean[] __tmp46 = f_tmp_29;
			id = __tmp46;
			Boolean[] f_tmp_30 = intLib.mux(pos, __tmp44,__tmp43);
			Boolean[] __tmp47 = f_tmp_30;
			pos = __tmp47;
			CircuitOram<Boolean> f_tmp_31 = this.poram;
			CircuitOram<Boolean> __tmp48 = f_tmp_31;
			AVLNode<K, V> f_tmp_32 = new AVLNode<K, V>(env, m, factoryK, factoryV).newObj(__tmp48.conditionalReadAndRemove(id, pos, __tmp43));
			AVLNode<K, V> __tmp49 = f_tmp_32;
			AVLNode<K, V> f_tmp_33 = new AVLNode<K, V>(env, m, factoryK, factoryV).newObj(intLib.mux(tnodes.getBits(), __tmp49.getBits(),__tmp43));
			AVLNode<K, V> __tmp50 = f_tmp_33;
			tnodes = __tmp50;
			AVLId __tmp51 = tnodes.left;
			Boolean[] __tmp52 = tnodes.rDepth;
			AVLId __tmp53 = tnodes.right;
			V __tmp54 = tnodes.value;
			K __tmp55 = tnodes.key;
			Boolean[] __tmp56 = tnodes.lDepth;
			K f_tmp_34 = keys[i];
			K __tmp57 = f_tmp_34;
			K f_tmp_35 = this.factoryK.newObj(intLib.mux(__tmp57.getBits(), __tmp55.getBits(),__tmp43));
			K __tmp58 = f_tmp_35;
			keys[i]=__tmp58;
			V f_tmp_36 = values[i];
			V __tmp59 = f_tmp_36;
			V f_tmp_37 = this.factoryV.newObj(intLib.mux(__tmp59.getBits(), __tmp54.getBits(),__tmp43));
			V __tmp60 = f_tmp_37;
			values[i]=__tmp60;
			Boolean[] f_tmp_38 = intLib.mux(ld, __tmp56,__tmp43);
			Boolean[] __tmp61 = f_tmp_38;
			ld = __tmp61;
			Boolean[] f_tmp_39 = intLib.mux(rd, __tmp52,__tmp43);
			Boolean[] __tmp62 = f_tmp_39;
			rd = __tmp62;
			AVLId f_tmp_40 = new AVLId(env, m).newObj(intLib.mux(lf.getBits(), __tmp51.getBits(),__tmp43));
			AVLId __tmp63 = f_tmp_40;
			lf = __tmp63;
			AVLId f_tmp_41 = new AVLId(env, m).newObj(intLib.mux(rf.getBits(), __tmp53.getBits(),__tmp43));
			AVLId __tmp64 = f_tmp_41;
			rf = __tmp64;
			Boolean f_tmp_42 = intLib.not(__tmp43);
			Boolean __tmp65 = f_tmp_42;
			int f_tmp_43 = 1;
			int __tmp66 = f_tmp_43;
			Boolean[] f_tmp_45 = env.inputOfAlice(Utils.fromInt(__tmp66, 2));
			Boolean f_tmp_44 = intLib.eq(ind, f_tmp_45);
			Boolean __tmp67 = f_tmp_44;
			Boolean f_tmp_46 = intLib.and(__tmp65,__tmp67);
			Boolean __tmp68 = f_tmp_46;
			K f_tmp_47 = keys[i];
			K __tmp69 = f_tmp_47;
			K f_tmp_48 = this.factoryK.newObj(intLib.mux(__tmp69.getBits(), key.getBits(),__tmp68));
			K __tmp70 = f_tmp_48;
			keys[i]=__tmp70;
			V f_tmp_49 = values[i];
			V __tmp71 = f_tmp_49;
			V f_tmp_50 = this.factoryV.newObj(intLib.mux(__tmp71.getBits(), value.getBits(),__tmp68));
			V __tmp72 = f_tmp_50;
			values[i]=__tmp72;
			int f_tmp_51 = 0;
			int __tmp73 = f_tmp_51;
			int f_tmp_52 = 1;
			int __tmp74 = f_tmp_52;
			int f_tmp_53 = __tmp73 - __tmp74;
			int __tmp75 = f_tmp_53;
			Boolean[] f_tmp_54 = depth[i];
			Boolean[] __tmp76 = f_tmp_54;
			Boolean[] f_tmp_56 = env.inputOfAlice(Utils.fromInt(__tmp75, (m)+(1)));
			Boolean[] f_tmp_55 = intLib.mux(__tmp76, f_tmp_56,__tmp68);
			Boolean[] __tmp77 = f_tmp_55;
			depth[i]=__tmp77;
			Boolean[] f_tmp_57 = intLib.randBools(m);
			Boolean[] __tmp78 = f_tmp_57;
			int f_tmp_58 = 0;
			int __tmp79 = f_tmp_58;
			AVLId f_tmp_59 = new AVLId(env, m);
			f_tmp_59.pos = __tmp78;
			f_tmp_59.id = env.inputOfAlice(Utils.fromInt(__tmp79, 32));
			AVLId __tmp80 = f_tmp_59;
			AVLId f_tmp_60 = left[i];
			AVLId __tmp81 = f_tmp_60;
			AVLId f_tmp_61 = new AVLId(env, m).newObj(intLib.mux(__tmp81.getBits(), __tmp80.getBits(),__tmp68));
			AVLId __tmp82 = f_tmp_61;
			left[i]=__tmp82;
			int f_tmp_62 = 2;
			int __tmp83 = f_tmp_62;
			Boolean[] f_tmp_64 = env.inputOfAlice(Utils.fromInt(__tmp83, 2));
			Boolean[] f_tmp_63 = intLib.mux(ind, f_tmp_64,__tmp68);
			Boolean[] __tmp84 = f_tmp_63;
			ind = __tmp84;
			Boolean f_tmp_65 = intLib.not(__tmp67);
			Boolean __tmp85 = f_tmp_65;
			Boolean f_tmp_66 = intLib.and(__tmp65,__tmp85);
			Boolean __tmp86 = f_tmp_66;
			int f_tmp_67 = 0;
			int __tmp87 = f_tmp_67;
			int f_tmp_68 = 1;
			int __tmp88 = f_tmp_68;
			int f_tmp_69 = __tmp87 - __tmp88;
			int __tmp89 = f_tmp_69;
			Boolean[] f_tmp_70 = depth[i];
			Boolean[] __tmp90 = f_tmp_70;
			Boolean[] f_tmp_72 = env.inputOfAlice(Utils.fromInt(__tmp89, (m)+(1)));
			Boolean[] f_tmp_71 = intLib.mux(__tmp90, f_tmp_72,__tmp86);
			Boolean[] __tmp91 = f_tmp_71;
			depth[i]=__tmp91;
			K f_tmp_73 = keys[pre];
			K __tmp92 = f_tmp_73;
			K f_tmp_74 = keys[i];
			K __tmp93 = f_tmp_74;
			K f_tmp_75 = this.factoryK.newObj(intLib.mux(__tmp93.getBits(), __tmp92.getBits(),__tmp86));
			K __tmp94 = f_tmp_75;
			keys[i]=__tmp94;
			K f_tmp_76 = keys[i];
			K __tmp95 = f_tmp_76;
			Boolean[] f_tmp_77 = cmp.calc(__tmp95, key);
			Boolean[] __tmp96 = f_tmp_77;
			cres[i]=__tmp96;
			int f_tmp_78 = 0;
			int __tmp97 = f_tmp_78;
			Boolean[] f_tmp_80 = env.inputOfAlice(Utils.fromInt(__tmp97, 2));
			Boolean f_tmp_79 = intLib.eq(ind, f_tmp_80);
			Boolean __tmp98 = f_tmp_79;
			Boolean[] f_tmp_81 = cres[i];
			Boolean[] __tmp99 = f_tmp_81;
			int f_tmp_82 = 0;
			int __tmp100 = f_tmp_82;
			Boolean[] f_tmp_84 = env.inputOfAlice(Utils.fromInt(__tmp100, 2));
			Boolean f_tmp_83 = intLib.not(intLib.leq(__tmp99, f_tmp_84));
			Boolean __tmp101 = f_tmp_83;
			Boolean f_tmp_85 = intLib.and(__tmp98,__tmp101);
			Boolean __tmp102 = f_tmp_85;
			Boolean[] f_tmp_86 = depth[i];
			Boolean[] __tmp103 = f_tmp_86;
			Boolean[] f_tmp_87 = intLib.mux(__tmp103, rd,__tmp102);
			Boolean[] __tmp104 = f_tmp_87;
			depth[i]=__tmp104;
			AVLId f_tmp_88 = new AVLId(env, m).newObj(intLib.mux(go.getBits(), lf.getBits(),__tmp102));
			AVLId __tmp105 = f_tmp_88;
			go = __tmp105;
			AVLId f_tmp_89 = left[i];
			AVLId __tmp106 = f_tmp_89;
			AVLId f_tmp_90 = new AVLId(env, m).newObj(intLib.mux(__tmp106.getBits(), rf.getBits(),__tmp102));
			AVLId __tmp107 = f_tmp_90;
			left[i]=__tmp107;
			Boolean f_tmp_91 = intLib.not(__tmp101);
			Boolean __tmp108 = f_tmp_91;
			Boolean f_tmp_92 = intLib.and(__tmp98,__tmp108);
			Boolean __tmp109 = f_tmp_92;
			Boolean[] f_tmp_93 = depth[i];
			Boolean[] __tmp110 = f_tmp_93;
			Boolean[] f_tmp_94 = intLib.mux(__tmp110, ld,__tmp109);
			Boolean[] __tmp111 = f_tmp_94;
			depth[i]=__tmp111;
			AVLId f_tmp_95 = new AVLId(env, m).newObj(intLib.mux(go.getBits(), rf.getBits(),__tmp109));
			AVLId __tmp112 = f_tmp_95;
			go = __tmp112;
			AVLId f_tmp_96 = left[i];
			AVLId __tmp113 = f_tmp_96;
			AVLId f_tmp_97 = new AVLId(env, m).newObj(intLib.mux(__tmp113.getBits(), lf.getBits(),__tmp109));
			AVLId __tmp114 = f_tmp_97;
			left[i]=__tmp114;
			AVLId f_tmp_98 = new AVLId(env, m).newObj(intLib.mux(now.getBits(), go.getBits(),__tmp98));
			AVLId __tmp115 = f_tmp_98;
			now = __tmp115;
			Boolean[] f_tmp_99 = now.id;
			Boolean[] __tmp116 = f_tmp_99;
			int f_tmp_100 = 0;
			int __tmp117 = f_tmp_100;
			Boolean[] f_tmp_102 = env.inputOfAlice(Utils.fromInt(__tmp117, 32));
			Boolean f_tmp_101 = intLib.eq(__tmp116, f_tmp_102);
			Boolean __tmp118 = f_tmp_101;
			Boolean f_tmp_103 = intLib.and(__tmp98,__tmp118);
			Boolean __tmp119 = f_tmp_103;
			int f_tmp_104 = 1;
			int __tmp120 = f_tmp_104;
			Boolean[] f_tmp_106 = env.inputOfAlice(Utils.fromInt(__tmp120, 2));
			Boolean[] f_tmp_105 = intLib.mux(ind, f_tmp_106,__tmp119);
			Boolean[] __tmp121 = f_tmp_105;
			ind = __tmp121;
			Boolean f_tmp_107 = intLib.not(__tmp118);
			Boolean __tmp122 = f_tmp_107;
			Boolean f_tmp_108 = intLib.and(__tmp98,__tmp122);
			Boolean __tmp123 = f_tmp_108;
			Boolean f_tmp_109 = intLib.not(__tmp98);
			Boolean __tmp124 = f_tmp_109;
			int f_tmp_110 = 1;
			int __tmp125 = f_tmp_110;
			int f_tmp_111 = i + __tmp125;
			int __tmp126 = f_tmp_111;
			i = __tmp126;
			int f_tmp_112 = 3;
			__tmp32 = f_tmp_112;
			int f_tmp_113 = __tmp32 * m;
			__tmp33 = f_tmp_113;
			int f_tmp_114 = 2;
			__tmp34 = f_tmp_114;
			int f_tmp_115 = __tmp33 / __tmp34;
			__tmp35 = f_tmp_115;
			boolean f_tmp_116 = i < __tmp35;
			__tmp36 = f_tmp_116;
		}
		int f_tmp_117 = 0;
		int __tmp127 = f_tmp_117;
		int f_tmp_118 = 1;
		int __tmp128 = f_tmp_118;
		int f_tmp_119 = __tmp127 - __tmp128;
		int __tmp129 = f_tmp_119;
		nowDepth = env.inputOfAlice(Utils.fromInt(__tmp129, (m)+(1)));
		Boolean[] f_tmp_120 = intLib.randBools(m);
		Boolean[] __tmp130 = f_tmp_120;
		int f_tmp_121 = 0;
		int __tmp131 = f_tmp_121;
		AVLId f_tmp_122 = new AVLId(env, m);
		f_tmp_122.pos = __tmp130;
		f_tmp_122.id = env.inputOfAlice(Utils.fromInt(__tmp131, 32));
		AVLId __tmp132 = f_tmp_122;
		nid = __tmp132;
		int f_tmp_123 = 3;
		int __tmp133 = f_tmp_123;
		int f_tmp_124 = __tmp133 * m;
		int __tmp134 = f_tmp_124;
		int f_tmp_125 = 2;
		int __tmp135 = f_tmp_125;
		int f_tmp_126 = __tmp134 / __tmp135;
		int __tmp136 = f_tmp_126;
		int f_tmp_127 = 1;
		int __tmp137 = f_tmp_127;
		int f_tmp_128 = __tmp136 - __tmp137;
		int __tmp138 = f_tmp_128;
		i = __tmp138;
		int f_tmp_129 = 0;
		int __tmp139 = f_tmp_129;
		boolean f_tmp_130 = i >= __tmp139;
		boolean __tmp140 = f_tmp_130;
		while(__tmp140) {
			Boolean[] f_tmp_131 = ids[i];
			Boolean[] __tmp141 = f_tmp_131;
			int f_tmp_132 = 2;
			int __tmp142 = f_tmp_132;
			Boolean[] f_tmp_134 = env.inputOfAlice(Utils.fromInt(__tmp142, 2));
			Boolean f_tmp_133 = intLib.not(intLib.eq(__tmp141, f_tmp_134));
			Boolean __tmp143 = f_tmp_133;
			Boolean[] f_tmp_135 = this.total;
			Boolean[] __tmp144 = f_tmp_135;
			int f_tmp_136 = 1;
			int __tmp145 = f_tmp_136;
			Boolean[] f_tmp_138 = env.inputOfAlice(Utils.fromInt(__tmp145, 32));
			Boolean[] f_tmp_137 = intLib.add(__tmp144,f_tmp_138);
			Boolean[] __tmp146 = f_tmp_137;
			Boolean[] f_tmp_139 = this.total;
			Boolean[] __tmp147 = f_tmp_139;
			Boolean[] f_tmp_140 = intLib.mux(__tmp147, __tmp146,__tmp143);
			Boolean[] __tmp148 = f_tmp_140;
			this.total = __tmp148;
			Boolean[] f_tmp_141 = this.total;
			Boolean[] __tmp149 = f_tmp_141;
			Boolean[] f_tmp_142 = intLib.mux(id, __tmp149,__tmp143);
			Boolean[] __tmp150 = f_tmp_142;
			id = __tmp150;
			Boolean[] f_tmp_143 = intLib.randBools(m);
			Boolean[] __tmp151 = f_tmp_143;
			Boolean[] f_tmp_144 = intLib.mux(pos, __tmp151,__tmp143);
			Boolean[] __tmp152 = f_tmp_144;
			pos = __tmp152;
			Boolean[] f_tmp_145 = intLib.mux(hpos, pos,__tmp143);
			Boolean[] __tmp153 = f_tmp_145;
			hpos = __tmp153;
			AVLId f_tmp_146 = new AVLId(env, m);
			f_tmp_146.pos = pos;
			f_tmp_146.id = id;
			AVLId __tmp154 = f_tmp_146;
			AVLId f_tmp_147 = new AVLId(env, m).newObj(intLib.mux(next.getBits(), __tmp154.getBits(),__tmp143));
			AVLId __tmp155 = f_tmp_147;
			next = __tmp155;
			Boolean[] f_tmp_148 = cres[i];
			Boolean[] __tmp156 = f_tmp_148;
			int f_tmp_149 = 0;
			int __tmp157 = f_tmp_149;
			Boolean[] f_tmp_151 = env.inputOfAlice(Utils.fromInt(__tmp157, 2));
			Boolean f_tmp_150 = intLib.not(intLib.leq(__tmp156, f_tmp_151));
			Boolean __tmp158 = f_tmp_150;
			Boolean f_tmp_152 = intLib.and(__tmp143,__tmp158);
			Boolean __tmp159 = f_tmp_152;
			Boolean[] f_tmp_153 = intLib.mux(ld, nowDepth,__tmp159);
			Boolean[] __tmp160 = f_tmp_153;
			ld = __tmp160;
			Boolean[] f_tmp_154 = depth[i];
			Boolean[] __tmp161 = f_tmp_154;
			Boolean[] f_tmp_155 = intLib.mux(rd, __tmp161,__tmp159);
			Boolean[] __tmp162 = f_tmp_155;
			rd = __tmp162;
			AVLId f_tmp_156 = new AVLId(env, m).newObj(intLib.mux(ll.getBits(), nid.getBits(),__tmp159));
			AVLId __tmp163 = f_tmp_156;
			ll = __tmp163;
			AVLId f_tmp_157 = left[i];
			AVLId __tmp164 = f_tmp_157;
			AVLId f_tmp_158 = new AVLId(env, m).newObj(intLib.mux(rr.getBits(), __tmp164.getBits(),__tmp159));
			AVLId __tmp165 = f_tmp_158;
			rr = __tmp165;
			Boolean f_tmp_159 = intLib.not(__tmp158);
			Boolean __tmp166 = f_tmp_159;
			Boolean f_tmp_160 = intLib.and(__tmp143,__tmp166);
			Boolean __tmp167 = f_tmp_160;
			Boolean[] f_tmp_161 = depth[i];
			Boolean[] __tmp168 = f_tmp_161;
			Boolean[] f_tmp_162 = intLib.mux(ld, __tmp168,__tmp167);
			Boolean[] __tmp169 = f_tmp_162;
			ld = __tmp169;
			Boolean[] f_tmp_163 = intLib.mux(rd, nowDepth,__tmp167);
			Boolean[] __tmp170 = f_tmp_163;
			rd = __tmp170;
			AVLId f_tmp_164 = left[i];
			AVLId __tmp171 = f_tmp_164;
			AVLId f_tmp_165 = new AVLId(env, m).newObj(intLib.mux(ll.getBits(), __tmp171.getBits(),__tmp167));
			AVLId __tmp172 = f_tmp_165;
			ll = __tmp172;
			AVLId f_tmp_166 = new AVLId(env, m).newObj(intLib.mux(rr.getBits(), nid.getBits(),__tmp167));
			AVLId __tmp173 = f_tmp_166;
			rr = __tmp173;
			AVLId f_tmp_167 = new AVLId(env, m).newObj(intLib.mux(nid.getBits(), next.getBits(),__tmp143));
			AVLId __tmp174 = f_tmp_167;
			nid = __tmp174;
			V f_tmp_168 = values[i];
			V __tmp175 = f_tmp_168;
			K f_tmp_169 = keys[i];
			K __tmp176 = f_tmp_169;
			AVLNode<K, V> f_tmp_170 = new AVLNode<K, V>(env, m, factoryK, factoryV);
			f_tmp_170.left = ll;
			f_tmp_170.rDepth = rd;
			f_tmp_170.right = rr;
			f_tmp_170.value = __tmp175;
			f_tmp_170.key = __tmp176;
			f_tmp_170.lDepth = ld;
			AVLNode<K, V> __tmp177 = f_tmp_170;
			AVLNode<K, V> f_tmp_171 = new AVLNode<K, V>(env, m, factoryK, factoryV).newObj(intLib.mux(nowInsertNode.getBits(), __tmp177.getBits(),__tmp143));
			AVLNode<K, V> __tmp178 = f_tmp_171;
			nowInsertNode = __tmp178;
			Boolean[] f_tmp_172 = depth[i];
			Boolean[] __tmp179 = f_tmp_172;
			Boolean f_tmp_173 = intLib.not(intLib.leq(__tmp179, nowDepth));
			Boolean __tmp180 = f_tmp_173;
			Boolean f_tmp_174 = intLib.and(__tmp143,__tmp180);
			Boolean __tmp181 = f_tmp_174;
			Boolean[] f_tmp_175 = depth[i];
			Boolean[] __tmp182 = f_tmp_175;
			Boolean[] f_tmp_176 = intLib.mux(nowDepth, __tmp182,__tmp181);
			Boolean[] __tmp183 = f_tmp_176;
			nowDepth = __tmp183;
			Boolean f_tmp_177 = intLib.not(__tmp180);
			Boolean __tmp184 = f_tmp_177;
			Boolean f_tmp_178 = intLib.and(__tmp143,__tmp184);
			Boolean __tmp185 = f_tmp_178;
			int f_tmp_179 = 1;
			int __tmp186 = f_tmp_179;
			Boolean[] f_tmp_181 = env.inputOfAlice(Utils.fromInt(__tmp186, (m)+(1)));
			Boolean[] f_tmp_180 = intLib.add(nowDepth,f_tmp_181);
			Boolean[] __tmp187 = f_tmp_180;
			Boolean[] f_tmp_182 = intLib.mux(nowDepth, __tmp187,__tmp143);
			Boolean[] __tmp188 = f_tmp_182;
			nowDepth = __tmp188;
			boolean f_tmp_183 = false;
			boolean __tmp189 = f_tmp_183;
			Boolean f_tmp_185 = env.inputOfAlice(__tmp189);
			Boolean f_tmp_184 = intLib.mux(RDgeqLD, f_tmp_185,__tmp143);
			Boolean __tmp190 = f_tmp_184;
			RDgeqLD = __tmp190;
			Boolean[] f_tmp_186 = intLib.sub(rd,ld);
			Boolean[] __tmp191 = f_tmp_186;
			int f_tmp_187 = 2;
			int __tmp192 = f_tmp_187;
			Boolean[] f_tmp_189 = env.inputOfAlice(Utils.fromInt(__tmp192, (m)+(1)));
			Boolean f_tmp_188 = intLib.geq(__tmp191, f_tmp_189);
			Boolean __tmp193 = f_tmp_188;
			Boolean f_tmp_190 = intLib.and(__tmp143,__tmp193);
			Boolean __tmp194 = f_tmp_190;
			boolean f_tmp_191 = true;
			boolean __tmp195 = f_tmp_191;
			Boolean f_tmp_193 = env.inputOfAlice(__tmp195);
			Boolean f_tmp_192 = intLib.mux(RDgeqLD, f_tmp_193,__tmp194);
			Boolean __tmp196 = f_tmp_192;
			RDgeqLD = __tmp196;
			Boolean f_tmp_194 = intLib.not(__tmp193);
			Boolean __tmp197 = f_tmp_194;
			Boolean f_tmp_195 = intLib.and(__tmp143,__tmp197);
			Boolean __tmp198 = f_tmp_195;
			boolean f_tmp_196 = false;
			boolean __tmp199 = f_tmp_196;
			Boolean f_tmp_198 = env.inputOfAlice(__tmp199);
			Boolean f_tmp_197 = intLib.mux(LDgeqRD, f_tmp_198,__tmp143);
			Boolean __tmp200 = f_tmp_197;
			LDgeqRD = __tmp200;
			Boolean[] f_tmp_199 = intLib.sub(ld,rd);
			Boolean[] __tmp201 = f_tmp_199;
			int f_tmp_200 = 2;
			int __tmp202 = f_tmp_200;
			Boolean[] f_tmp_202 = env.inputOfAlice(Utils.fromInt(__tmp202, (m)+(1)));
			Boolean f_tmp_201 = intLib.geq(__tmp201, f_tmp_202);
			Boolean __tmp203 = f_tmp_201;
			Boolean f_tmp_203 = intLib.and(__tmp143,__tmp203);
			Boolean __tmp204 = f_tmp_203;
			boolean f_tmp_204 = true;
			boolean __tmp205 = f_tmp_204;
			Boolean f_tmp_206 = env.inputOfAlice(__tmp205);
			Boolean f_tmp_205 = intLib.mux(LDgeqRD, f_tmp_206,__tmp204);
			Boolean __tmp206 = f_tmp_205;
			LDgeqRD = __tmp206;
			Boolean f_tmp_207 = intLib.not(__tmp203);
			Boolean __tmp207 = f_tmp_207;
			Boolean f_tmp_208 = intLib.and(__tmp143,__tmp207);
			Boolean __tmp208 = f_tmp_208;
			boolean f_tmp_209 = false;
			boolean __tmp209 = f_tmp_209;
			Boolean f_tmp_211 = env.inputOfAlice(__tmp209);
			Boolean f_tmp_210 = intLib.mux(execute, f_tmp_211,__tmp143);
			Boolean __tmp210 = f_tmp_210;
			execute = __tmp210;
			boolean f_tmp_212 = true;
			boolean __tmp211 = f_tmp_212;
			Boolean f_tmp_214 = env.inputOfAlice(__tmp211);
			Boolean f_tmp_213 = intLib.eq(LDgeqRD, f_tmp_214);
			Boolean __tmp212 = f_tmp_213;
			boolean f_tmp_215 = true;
			boolean __tmp213 = f_tmp_215;
			Boolean f_tmp_217 = env.inputOfAlice(__tmp213);
			Boolean f_tmp_216 = intLib.eq(RDgeqLD, f_tmp_217);
			Boolean __tmp214 = f_tmp_216;
			Boolean f_tmp_218 = intLib.or(__tmp212,__tmp214);
			Boolean __tmp215 = f_tmp_218;
			Boolean f_tmp_219 = intLib.and(__tmp143,__tmp215);
			Boolean __tmp216 = f_tmp_219;
			boolean f_tmp_220 = true;
			boolean __tmp217 = f_tmp_220;
			Boolean f_tmp_222 = env.inputOfAlice(__tmp217);
			Boolean f_tmp_221 = intLib.mux(execute, f_tmp_222,__tmp216);
			Boolean __tmp218 = f_tmp_221;
			execute = __tmp218;
			Boolean f_tmp_223 = intLib.not(__tmp215);
			Boolean __tmp219 = f_tmp_223;
			Boolean f_tmp_224 = intLib.and(__tmp143,__tmp219);
			Boolean __tmp220 = f_tmp_224;
			boolean f_tmp_225 = true;
			boolean __tmp221 = f_tmp_225;
			Boolean f_tmp_227 = env.inputOfAlice(__tmp221);
			Boolean f_tmp_226 = intLib.eq(execute, f_tmp_227);
			Boolean __tmp222 = f_tmp_226;
			Boolean f_tmp_228 = intLib.and(__tmp143,__tmp222);
			Boolean __tmp223 = f_tmp_228;
			Boolean[] __tmp224 = nid.pos;
			Boolean[] __tmp225 = nid.id;
			Boolean[] f_tmp_229 = intLib.mux(oid, __tmp225,__tmp223);
			Boolean[] __tmp226 = f_tmp_229;
			oid = __tmp226;
			Boolean[] f_tmp_230 = intLib.mux(pos, __tmp224,__tmp223);
			Boolean[] __tmp227 = f_tmp_230;
			pos = __tmp227;
			AVLNode<K, V> f_tmp_231 = new AVLNode<K, V>(env, m, factoryK, factoryV).newObj(intLib.mux(tnodes.getBits(), nowInsertNode.getBits(),__tmp223));
			AVLNode<K, V> __tmp228 = f_tmp_231;
			tnodes = __tmp228;
			Boolean f_tmp_232 = intLib.not(__tmp222);
			Boolean __tmp229 = f_tmp_232;
			Boolean f_tmp_233 = intLib.and(__tmp143,__tmp229);
			Boolean __tmp230 = f_tmp_233;
			boolean f_tmp_234 = true;
			boolean __tmp231 = f_tmp_234;
			Boolean f_tmp_236 = env.inputOfAlice(__tmp231);
			Boolean f_tmp_235 = intLib.eq(RDgeqLD, f_tmp_236);
			Boolean __tmp232 = f_tmp_235;
			Boolean f_tmp_237 = intLib.and(__tmp143,__tmp232);
			Boolean __tmp233 = f_tmp_237;
			AVLId __tmp234 = tnodes.left;
			Boolean[] __tmp235 = tnodes.rDepth;
			AVLId __tmp236 = tnodes.right;
			V __tmp237 = tnodes.value;
			K __tmp238 = tnodes.key;
			Boolean[] __tmp239 = tnodes.lDepth;
			K f_tmp_238 = this.factoryK.newObj(intLib.mux(k.getBits(), __tmp238.getBits(),__tmp233));
			K __tmp240 = f_tmp_238;
			k = __tmp240;
			V f_tmp_239 = this.factoryV.newObj(intLib.mux(v.getBits(), __tmp237.getBits(),__tmp233));
			V __tmp241 = f_tmp_239;
			v = __tmp241;
			Boolean[] f_tmp_240 = intLib.mux(dc, __tmp239,__tmp233);
			Boolean[] __tmp242 = f_tmp_240;
			dc = __tmp242;
			AVLId f_tmp_241 = new AVLId(env, m).newObj(intLib.mux(c.getBits(), __tmp234.getBits(),__tmp233));
			AVLId __tmp243 = f_tmp_241;
			c = __tmp243;
			AVLId f_tmp_242 = new AVLId(env, m).newObj(intLib.mux(l.getBits(), __tmp236.getBits(),__tmp233));
			AVLId __tmp244 = f_tmp_242;
			l = __tmp244;
			Boolean f_tmp_243 = intLib.not(__tmp232);
			Boolean __tmp245 = f_tmp_243;
			Boolean f_tmp_244 = intLib.and(__tmp143,__tmp245);
			Boolean __tmp246 = f_tmp_244;
			boolean f_tmp_245 = true;
			boolean __tmp247 = f_tmp_245;
			Boolean f_tmp_247 = env.inputOfAlice(__tmp247);
			Boolean f_tmp_246 = intLib.eq(LDgeqRD, f_tmp_247);
			Boolean __tmp248 = f_tmp_246;
			Boolean f_tmp_248 = intLib.and(__tmp246,__tmp248);
			Boolean __tmp249 = f_tmp_248;
			AVLId __tmp250 = tnodes.left;
			Boolean[] __tmp251 = tnodes.rDepth;
			AVLId __tmp252 = tnodes.right;
			V __tmp253 = tnodes.value;
			K __tmp254 = tnodes.key;
			Boolean[] __tmp255 = tnodes.lDepth;
			K f_tmp_249 = this.factoryK.newObj(intLib.mux(k.getBits(), __tmp254.getBits(),__tmp249));
			K __tmp256 = f_tmp_249;
			k = __tmp256;
			V f_tmp_250 = this.factoryV.newObj(intLib.mux(v.getBits(), __tmp253.getBits(),__tmp249));
			V __tmp257 = f_tmp_250;
			v = __tmp257;
			Boolean[] f_tmp_251 = intLib.mux(dc, __tmp251,__tmp249);
			Boolean[] __tmp258 = f_tmp_251;
			dc = __tmp258;
			AVLId f_tmp_252 = new AVLId(env, m).newObj(intLib.mux(c.getBits(), __tmp252.getBits(),__tmp249));
			AVLId __tmp259 = f_tmp_252;
			c = __tmp259;
			AVLId f_tmp_253 = new AVLId(env, m).newObj(intLib.mux(l.getBits(), __tmp250.getBits(),__tmp249));
			AVLId __tmp260 = f_tmp_253;
			l = __tmp260;
			Boolean f_tmp_254 = intLib.not(__tmp248);
			Boolean __tmp261 = f_tmp_254;
			Boolean f_tmp_255 = intLib.and(__tmp246,__tmp261);
			Boolean __tmp262 = f_tmp_255;
			boolean f_tmp_256 = true;
			boolean __tmp263 = f_tmp_256;
			Boolean f_tmp_258 = env.inputOfAlice(__tmp263);
			Boolean f_tmp_257 = intLib.eq(execute, f_tmp_258);
			Boolean __tmp264 = f_tmp_257;
			Boolean f_tmp_259 = intLib.and(__tmp143,__tmp264);
			Boolean __tmp265 = f_tmp_259;
			Boolean[] __tmp266 = l.pos;
			Boolean[] __tmp267 = l.id;
			Boolean[] f_tmp_260 = intLib.mux(id, __tmp267,__tmp265);
			Boolean[] __tmp268 = f_tmp_260;
			id = __tmp268;
			Boolean[] f_tmp_261 = intLib.mux(pos, __tmp266,__tmp265);
			Boolean[] __tmp269 = f_tmp_261;
			pos = __tmp269;
			CircuitOram<Boolean> f_tmp_262 = this.poram;
			CircuitOram<Boolean> __tmp270 = f_tmp_262;
			AVLNode<K, V> f_tmp_263 = new AVLNode<K, V>(env, m, factoryK, factoryV).newObj(__tmp270.conditionalReadAndRemove(id, pos, __tmp265));
			AVLNode<K, V> __tmp271 = f_tmp_263;
			AVLNode<K, V> f_tmp_264 = new AVLNode<K, V>(env, m, factoryK, factoryV).newObj(intLib.mux(p.getBits(), __tmp271.getBits(),__tmp265));
			AVLNode<K, V> __tmp272 = f_tmp_264;
			p = __tmp272;
			AVLId __tmp273 = p.left;
			Boolean[] __tmp274 = p.rDepth;
			AVLId __tmp275 = p.right;
			V __tmp276 = p.value;
			K __tmp277 = p.key;
			Boolean[] __tmp278 = p.lDepth;
			K f_tmp_265 = this.factoryK.newObj(intLib.mux(kp.getBits(), __tmp277.getBits(),__tmp265));
			K __tmp279 = f_tmp_265;
			kp = __tmp279;
			V f_tmp_266 = this.factoryV.newObj(intLib.mux(vp.getBits(), __tmp276.getBits(),__tmp265));
			V __tmp280 = f_tmp_266;
			vp = __tmp280;
			Boolean[] f_tmp_267 = intLib.mux(dap, __tmp278,__tmp265);
			Boolean[] __tmp281 = f_tmp_267;
			dap = __tmp281;
			Boolean[] f_tmp_268 = intLib.mux(dbp, __tmp274,__tmp265);
			Boolean[] __tmp282 = f_tmp_268;
			dbp = __tmp282;
			AVLId f_tmp_269 = new AVLId(env, m).newObj(intLib.mux(a.getBits(), __tmp273.getBits(),__tmp265));
			AVLId __tmp283 = f_tmp_269;
			a = __tmp283;
			AVLId f_tmp_270 = new AVLId(env, m).newObj(intLib.mux(b.getBits(), __tmp275.getBits(),__tmp265));
			AVLId __tmp284 = f_tmp_270;
			b = __tmp284;
			Boolean f_tmp_271 = intLib.not(__tmp264);
			Boolean __tmp285 = f_tmp_271;
			Boolean f_tmp_272 = intLib.and(__tmp143,__tmp285);
			Boolean __tmp286 = f_tmp_272;
			boolean f_tmp_273 = true;
			boolean __tmp287 = f_tmp_273;
			Boolean f_tmp_275 = env.inputOfAlice(__tmp287);
			Boolean f_tmp_274 = intLib.eq(RDgeqLD, f_tmp_275);
			Boolean __tmp288 = f_tmp_274;
			Boolean f_tmp_276 = intLib.and(__tmp143,__tmp288);
			Boolean __tmp289 = f_tmp_276;
			AVLNode<K, V> f_tmp_277 = new AVLNode<K, V>(env, m, factoryK, factoryV);
			f_tmp_277.left = c;
			f_tmp_277.rDepth = dap;
			f_tmp_277.right = a;
			f_tmp_277.value = v;
			f_tmp_277.key = k;
			f_tmp_277.lDepth = dc;
			AVLNode<K, V> __tmp290 = f_tmp_277;
			AVLNode<K, V> f_tmp_278 = new AVLNode<K, V>(env, m, factoryK, factoryV).newObj(intLib.mux(insertNode.getBits(), __tmp290.getBits(),__tmp289));
			AVLNode<K, V> __tmp291 = f_tmp_278;
			insertNode = __tmp291;
			Boolean f_tmp_279 = intLib.not(__tmp288);
			Boolean __tmp292 = f_tmp_279;
			Boolean f_tmp_280 = intLib.and(__tmp143,__tmp292);
			Boolean __tmp293 = f_tmp_280;
			boolean f_tmp_281 = true;
			boolean __tmp294 = f_tmp_281;
			Boolean f_tmp_283 = env.inputOfAlice(__tmp294);
			Boolean f_tmp_282 = intLib.eq(LDgeqRD, f_tmp_283);
			Boolean __tmp295 = f_tmp_282;
			Boolean f_tmp_284 = intLib.and(__tmp293,__tmp295);
			Boolean __tmp296 = f_tmp_284;
			AVLNode<K, V> f_tmp_285 = new AVLNode<K, V>(env, m, factoryK, factoryV);
			f_tmp_285.left = b;
			f_tmp_285.rDepth = dc;
			f_tmp_285.right = c;
			f_tmp_285.value = v;
			f_tmp_285.key = k;
			f_tmp_285.lDepth = dbp;
			AVLNode<K, V> __tmp297 = f_tmp_285;
			AVLNode<K, V> f_tmp_286 = new AVLNode<K, V>(env, m, factoryK, factoryV).newObj(intLib.mux(insertNode.getBits(), __tmp297.getBits(),__tmp296));
			AVLNode<K, V> __tmp298 = f_tmp_286;
			insertNode = __tmp298;
			Boolean f_tmp_287 = intLib.not(__tmp295);
			Boolean __tmp299 = f_tmp_287;
			Boolean f_tmp_288 = intLib.and(__tmp293,__tmp299);
			Boolean __tmp300 = f_tmp_288;
			boolean f_tmp_289 = true;
			boolean __tmp301 = f_tmp_289;
			Boolean f_tmp_291 = env.inputOfAlice(__tmp301);
			Boolean f_tmp_290 = intLib.eq(execute, f_tmp_291);
			Boolean __tmp302 = f_tmp_290;
			Boolean f_tmp_292 = intLib.and(__tmp143,__tmp302);
			Boolean __tmp303 = f_tmp_292;
			Boolean[] f_tmp_293 = intLib.randBools(m);
			Boolean[] __tmp304 = f_tmp_293;
			Boolean[] f_tmp_294 = intLib.mux(pos, __tmp304,__tmp303);
			Boolean[] __tmp305 = f_tmp_294;
			pos = __tmp305;
			Boolean[] f_tmp_295 = intLib.mux(hpos, pos,__tmp303);
			Boolean[] __tmp306 = f_tmp_295;
			hpos = __tmp306;
			CircuitOram<Boolean> f_tmp_296 = this.poram;
			CircuitOram<Boolean> __tmp307 = f_tmp_296;
			__tmp307.conditionalPutBack(id, pos, insertNode.getBits(), __tmp303);
			Boolean[] f_tmp_298 = intLib.mux(dp, dc,__tmp303);
			Boolean[] __tmp309 = f_tmp_298;
			dp = __tmp309;
			boolean f_tmp_299 = true;
			boolean __tmp310 = f_tmp_299;
			Boolean f_tmp_301 = env.inputOfAlice(__tmp310);
			Boolean f_tmp_300 = intLib.eq(RDgeqLD, f_tmp_301);
			Boolean __tmp311 = f_tmp_300;
			Boolean f_tmp_302 = intLib.not(intLib.leq(dap, dp));
			Boolean __tmp312 = f_tmp_302;
			Boolean f_tmp_303 = intLib.and(__tmp311,__tmp312);
			Boolean __tmp313 = f_tmp_303;
			Boolean f_tmp_304 = intLib.and(__tmp303,__tmp313);
			Boolean __tmp314 = f_tmp_304;
			Boolean[] f_tmp_305 = intLib.mux(dp, dap,__tmp314);
			Boolean[] __tmp315 = f_tmp_305;
			dp = __tmp315;
			Boolean f_tmp_306 = intLib.not(__tmp313);
			Boolean __tmp316 = f_tmp_306;
			Boolean f_tmp_307 = intLib.and(__tmp303,__tmp316);
			Boolean __tmp317 = f_tmp_307;
			Boolean f_tmp_308 = intLib.not(intLib.leq(dbp, dp));
			Boolean __tmp318 = f_tmp_308;
			Boolean f_tmp_309 = intLib.and(__tmp317,__tmp318);
			Boolean __tmp319 = f_tmp_309;
			Boolean[] f_tmp_310 = intLib.mux(dp, dbp,__tmp319);
			Boolean[] __tmp320 = f_tmp_310;
			dp = __tmp320;
			Boolean f_tmp_311 = intLib.not(__tmp318);
			Boolean __tmp321 = f_tmp_311;
			Boolean f_tmp_312 = intLib.and(__tmp317,__tmp321);
			Boolean __tmp322 = f_tmp_312;
			int f_tmp_313 = 1;
			int __tmp323 = f_tmp_313;
			Boolean[] f_tmp_315 = env.inputOfAlice(Utils.fromInt(__tmp323, (m)+(1)));
			Boolean[] f_tmp_314 = intLib.add(dp,f_tmp_315);
			Boolean[] __tmp324 = f_tmp_314;
			Boolean[] f_tmp_316 = intLib.mux(dp, __tmp324,__tmp303);
			Boolean[] __tmp325 = f_tmp_316;
			dp = __tmp325;
			AVLId f_tmp_317 = new AVLId(env, m);
			f_tmp_317.pos = pos;
			f_tmp_317.id = id;
			AVLId __tmp326 = f_tmp_317;
			AVLId f_tmp_318 = new AVLId(env, m).newObj(intLib.mux(next.getBits(), __tmp326.getBits(),__tmp303));
			AVLId __tmp327 = f_tmp_318;
			next = __tmp327;
			Boolean f_tmp_319 = intLib.not(__tmp302);
			Boolean __tmp328 = f_tmp_319;
			Boolean f_tmp_320 = intLib.and(__tmp143,__tmp328);
			Boolean __tmp329 = f_tmp_320;
			boolean f_tmp_321 = true;
			boolean __tmp330 = f_tmp_321;
			Boolean f_tmp_323 = env.inputOfAlice(__tmp330);
			Boolean f_tmp_322 = intLib.eq(RDgeqLD, f_tmp_323);
			Boolean __tmp331 = f_tmp_322;
			Boolean f_tmp_324 = intLib.and(__tmp143,__tmp331);
			Boolean __tmp332 = f_tmp_324;
			AVLNode<K, V> f_tmp_325 = new AVLNode<K, V>(env, m, factoryK, factoryV);
			f_tmp_325.left = next;
			f_tmp_325.rDepth = dbp;
			f_tmp_325.right = b;
			f_tmp_325.value = vp;
			f_tmp_325.key = kp;
			f_tmp_325.lDepth = dp;
			AVLNode<K, V> __tmp333 = f_tmp_325;
			AVLNode<K, V> f_tmp_326 = new AVLNode<K, V>(env, m, factoryK, factoryV).newObj(intLib.mux(nowInsertNode.getBits(), __tmp333.getBits(),__tmp332));
			AVLNode<K, V> __tmp334 = f_tmp_326;
			nowInsertNode = __tmp334;
			Boolean f_tmp_327 = intLib.not(__tmp331);
			Boolean __tmp335 = f_tmp_327;
			Boolean f_tmp_328 = intLib.and(__tmp143,__tmp335);
			Boolean __tmp336 = f_tmp_328;
			boolean f_tmp_329 = true;
			boolean __tmp337 = f_tmp_329;
			Boolean f_tmp_331 = env.inputOfAlice(__tmp337);
			Boolean f_tmp_330 = intLib.eq(LDgeqRD, f_tmp_331);
			Boolean __tmp338 = f_tmp_330;
			Boolean f_tmp_332 = intLib.and(__tmp336,__tmp338);
			Boolean __tmp339 = f_tmp_332;
			AVLNode<K, V> f_tmp_333 = new AVLNode<K, V>(env, m, factoryK, factoryV);
			f_tmp_333.left = a;
			f_tmp_333.rDepth = dp;
			f_tmp_333.right = next;
			f_tmp_333.value = vp;
			f_tmp_333.key = kp;
			f_tmp_333.lDepth = dap;
			AVLNode<K, V> __tmp340 = f_tmp_333;
			AVLNode<K, V> f_tmp_334 = new AVLNode<K, V>(env, m, factoryK, factoryV).newObj(intLib.mux(nowInsertNode.getBits(), __tmp340.getBits(),__tmp339));
			AVLNode<K, V> __tmp341 = f_tmp_334;
			nowInsertNode = __tmp341;
			Boolean f_tmp_335 = intLib.not(__tmp338);
			Boolean __tmp342 = f_tmp_335;
			Boolean f_tmp_336 = intLib.and(__tmp336,__tmp342);
			Boolean __tmp343 = f_tmp_336;
			boolean f_tmp_337 = true;
			boolean __tmp344 = f_tmp_337;
			Boolean f_tmp_339 = env.inputOfAlice(__tmp344);
			Boolean f_tmp_338 = intLib.eq(execute, f_tmp_339);
			Boolean __tmp345 = f_tmp_338;
			Boolean f_tmp_340 = intLib.and(__tmp143,__tmp345);
			Boolean __tmp346 = f_tmp_340;
			Boolean[] f_tmp_341 = intLib.randBools(m);
			Boolean[] __tmp347 = f_tmp_341;
			Boolean[] f_tmp_342 = intLib.mux(pos, __tmp347,__tmp346);
			Boolean[] __tmp348 = f_tmp_342;
			pos = __tmp348;
			AVLId f_tmp_343 = new AVLId(env, m);
			f_tmp_343.pos = pos;
			f_tmp_343.id = oid;
			AVLId __tmp349 = f_tmp_343;
			AVLId f_tmp_344 = new AVLId(env, m).newObj(intLib.mux(nid.getBits(), __tmp349.getBits(),__tmp346));
			AVLId __tmp350 = f_tmp_344;
			nid = __tmp350;
			Boolean[] f_tmp_345 = intLib.mux(nowDepth, dp,__tmp346);
			Boolean[] __tmp351 = f_tmp_345;
			nowDepth = __tmp351;
			Boolean f_tmp_346 = intLib.not(__tmp345);
			Boolean __tmp352 = f_tmp_346;
			Boolean f_tmp_347 = intLib.and(__tmp143,__tmp352);
			Boolean __tmp353 = f_tmp_347;
			Boolean[] __tmp354 = nid.pos;
			Boolean[] __tmp355 = nid.id;
			Boolean[] f_tmp_348 = intLib.mux(id, __tmp355,__tmp143);
			Boolean[] __tmp356 = f_tmp_348;
			id = __tmp356;
			Boolean[] f_tmp_349 = intLib.mux(pos, __tmp354,__tmp143);
			Boolean[] __tmp357 = f_tmp_349;
			pos = __tmp357;
			Boolean[] f_tmp_350 = intLib.mux(hpos, pos,__tmp143);
			Boolean[] __tmp358 = f_tmp_350;
			hpos = __tmp358;
			CircuitOram<Boolean> f_tmp_351 = this.poram;
			CircuitOram<Boolean> __tmp359 = f_tmp_351;
			__tmp359.conditionalPutBack(id, hpos, nowInsertNode.getBits(), __tmp143);
			AVLId f_tmp_353 = new AVLId(env, m);
			f_tmp_353.pos = pos;
			f_tmp_353.id = id;
			AVLId __tmp361 = f_tmp_353;
			AVLId f_tmp_354 = new AVLId(env, m).newObj(intLib.mux(nid.getBits(), __tmp361.getBits(),__tmp143));
			AVLId __tmp362 = f_tmp_354;
			nid = __tmp362;
			Boolean f_tmp_355 = intLib.not(__tmp143);
			Boolean __tmp363 = f_tmp_355;
			int f_tmp_356 = 1;
			int __tmp364 = f_tmp_356;
			int f_tmp_357 = i - __tmp364;
			int __tmp365 = f_tmp_357;
			i = __tmp365;
			int f_tmp_358 = 0;
			__tmp139 = f_tmp_358;
			boolean f_tmp_359 = i >= __tmp139;
			__tmp140 = f_tmp_359;
		}
		this.root = nid;

	}
	public V search(K key, FUNC_1_INTsecure_T1_T1<K> cmp) throws Exception {
		AVLNode<K, V> tnodes = new AVLNode<K, V>(env, m, factoryK, factoryV);
		AVLNode<K, V> p = new AVLNode<K, V>(env, m, factoryK, factoryV);
		AVLId now = new AVLId(env, m);
		AVLId go = new AVLId(env, m);
		AVLId a = new AVLId(env, m);
		AVLId b = new AVLId(env, m);
		AVLId c = new AVLId(env, m);
		AVLId[] left = (AVLId[])Array.newInstance((Class<AVLId>)(new AVLId(env, m).getClass()), ((3)*(m))/(2));
		for(int _j_2 = 0; _j_2 < ((3)*(m))/(2); ++_j_2) {
			left[_j_2] = new AVLId(env, m);
		}
		K[] keys = (K[])Array.newInstance((Class<K>)factoryK.getClass(), ((3)*(m))/(2));
		for(int _j_2 = 0; _j_2 < ((3)*(m))/(2); ++_j_2) {
			keys[_j_2] = factoryK.newObj(null);
		}
		V[] values = (V[])Array.newInstance((Class<V>)factoryV.getClass(), ((3)*(m))/(2));
		for(int _j_2 = 0; _j_2 < ((3)*(m))/(2); ++_j_2) {
			values[_j_2] = factoryV.newObj(null);
		}
		Boolean[][] depth = new Boolean[((3)*(m))/(2)][];
		for(int _j_2 = 0; _j_2 < ((3)*(m))/(2); ++_j_2) {
			depth[_j_2] = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		}
		Boolean[][] ids = new Boolean[((3)*(m))/(2)][];
		for(int _j_2 = 0; _j_2 < ((3)*(m))/(2); ++_j_2) {
			ids[_j_2] = env.inputOfAlice(Utils.fromInt(0, 2));
		}
		Boolean[][] cres = new Boolean[((3)*(m))/(2)][];
		for(int _j_2 = 0; _j_2 < ((3)*(m))/(2); ++_j_2) {
			cres[_j_2] = env.inputOfAlice(Utils.fromInt(0, 2));
		}
		Boolean[] ind = env.inputOfAlice(Utils.fromInt(0, 2));
		Boolean[] id = env.inputOfAlice(Utils.fromInt(0, 32));
		Boolean[] pos = intLib.randBools(m);
		K k = factoryK.newObj(null);
		K kp = factoryK.newObj(null);
		V v = factoryV.newObj(null);
		V vp = factoryV.newObj(null);
		AVLId lf = new AVLId(env, m);
		AVLId rf = new AVLId(env, m);
		V ret = factoryV.newObj(null);
		int i = 0;
		int pre = 0;
		Boolean[] nowDepth = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] ld = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] rd = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId nid = new AVLId(env, m);
		AVLId next = new AVLId(env, m);
		AVLId ll = new AVLId(env, m);
		AVLId rr = new AVLId(env, m);
		Boolean[] hpos = env.inputOfAlice(Utils.fromInt(0, m));
		AVLId f_tmp_360 = this.root;
		AVLId __tmp366 = f_tmp_360;
		now = __tmp366;
		int f_tmp_361 = 0;
		int __tmp367 = f_tmp_361;
		ind = env.inputOfAlice(Utils.fromInt(__tmp367, 2));
		int f_tmp_362 = 0;
		int __tmp368 = f_tmp_362;
		i = __tmp368;
		int f_tmp_363 = 3;
		int __tmp369 = f_tmp_363;
		int f_tmp_364 = __tmp369 * m;
		int __tmp370 = f_tmp_364;
		int f_tmp_365 = 2;
		int __tmp371 = f_tmp_365;
		int f_tmp_366 = __tmp370 / __tmp371;
		int __tmp372 = f_tmp_366;
		boolean f_tmp_367 = i < __tmp372;
		boolean __tmp373 = f_tmp_367;
		while(__tmp373) {
			ids[i]=ind;
			int f_tmp_368 = 1;
			int __tmp374 = f_tmp_368;
			int f_tmp_369 = i - __tmp374;
			int __tmp375 = f_tmp_369;
			pre = __tmp375;
			int f_tmp_370 = 0;
			int __tmp376 = f_tmp_370;
			boolean f_tmp_371 = i == __tmp376;
			boolean __tmp377 = f_tmp_371;
			if(__tmp377) {
				int f_tmp_372 = 0;
				int __tmp378 = f_tmp_372;
				pre = __tmp378;
			} else {
			}
			int f_tmp_373 = 0;
			int __tmp379 = f_tmp_373;
			Boolean[] f_tmp_375 = env.inputOfAlice(Utils.fromInt(__tmp379, 2));
			Boolean f_tmp_374 = intLib.eq(ind, f_tmp_375);
			Boolean __tmp380 = f_tmp_374;
			Boolean[] __tmp381 = now.pos;
			Boolean[] __tmp382 = now.id;
			Boolean[] f_tmp_376 = intLib.mux(id, __tmp382,__tmp380);
			Boolean[] __tmp383 = f_tmp_376;
			id = __tmp383;
			Boolean[] f_tmp_377 = intLib.mux(pos, __tmp381,__tmp380);
			Boolean[] __tmp384 = f_tmp_377;
			pos = __tmp384;
			CircuitOram<Boolean> f_tmp_378 = this.poram;
			CircuitOram<Boolean> __tmp385 = f_tmp_378;
			AVLNode<K, V> f_tmp_379 = new AVLNode<K, V>(env, m, factoryK, factoryV).newObj(__tmp385.conditionalReadAndRemove(id, pos, __tmp380));
			AVLNode<K, V> __tmp386 = f_tmp_379;
			AVLNode<K, V> f_tmp_380 = new AVLNode<K, V>(env, m, factoryK, factoryV).newObj(intLib.mux(tnodes.getBits(), __tmp386.getBits(),__tmp380));
			AVLNode<K, V> __tmp387 = f_tmp_380;
			tnodes = __tmp387;
			AVLId __tmp388 = tnodes.left;
			Boolean[] __tmp389 = tnodes.rDepth;
			AVLId __tmp390 = tnodes.right;
			V __tmp391 = tnodes.value;
			K __tmp392 = tnodes.key;
			Boolean[] __tmp393 = tnodes.lDepth;
			K f_tmp_381 = keys[i];
			K __tmp394 = f_tmp_381;
			K f_tmp_382 = this.factoryK.newObj(intLib.mux(__tmp394.getBits(), __tmp392.getBits(),__tmp380));
			K __tmp395 = f_tmp_382;
			keys[i]=__tmp395;
			V f_tmp_383 = values[i];
			V __tmp396 = f_tmp_383;
			V f_tmp_384 = this.factoryV.newObj(intLib.mux(__tmp396.getBits(), __tmp391.getBits(),__tmp380));
			V __tmp397 = f_tmp_384;
			values[i]=__tmp397;
			Boolean[] f_tmp_385 = intLib.mux(ld, __tmp393,__tmp380);
			Boolean[] __tmp398 = f_tmp_385;
			ld = __tmp398;
			Boolean[] f_tmp_386 = intLib.mux(rd, __tmp389,__tmp380);
			Boolean[] __tmp399 = f_tmp_386;
			rd = __tmp399;
			AVLId f_tmp_387 = new AVLId(env, m).newObj(intLib.mux(lf.getBits(), __tmp388.getBits(),__tmp380));
			AVLId __tmp400 = f_tmp_387;
			lf = __tmp400;
			AVLId f_tmp_388 = new AVLId(env, m).newObj(intLib.mux(rf.getBits(), __tmp390.getBits(),__tmp380));
			AVLId __tmp401 = f_tmp_388;
			rf = __tmp401;
			Boolean f_tmp_389 = intLib.not(__tmp380);
			Boolean __tmp402 = f_tmp_389;
			int f_tmp_390 = 0;
			int __tmp403 = f_tmp_390;
			int f_tmp_391 = 1;
			int __tmp404 = f_tmp_391;
			int f_tmp_392 = __tmp403 - __tmp404;
			int __tmp405 = f_tmp_392;
			Boolean[] f_tmp_393 = depth[i];
			Boolean[] __tmp406 = f_tmp_393;
			Boolean[] f_tmp_395 = env.inputOfAlice(Utils.fromInt(__tmp405, (m)+(1)));
			Boolean[] f_tmp_394 = intLib.mux(__tmp406, f_tmp_395,__tmp402);
			Boolean[] __tmp407 = f_tmp_394;
			depth[i]=__tmp407;
			K f_tmp_396 = keys[pre];
			K __tmp408 = f_tmp_396;
			K f_tmp_397 = keys[i];
			K __tmp409 = f_tmp_397;
			K f_tmp_398 = this.factoryK.newObj(intLib.mux(__tmp409.getBits(), __tmp408.getBits(),__tmp402));
			K __tmp410 = f_tmp_398;
			keys[i]=__tmp410;
			K f_tmp_399 = keys[i];
			K __tmp411 = f_tmp_399;
			Boolean[] f_tmp_400 = cmp.calc(__tmp411, key);
			Boolean[] __tmp412 = f_tmp_400;
			cres[i]=__tmp412;
			int f_tmp_401 = 0;
			int __tmp413 = f_tmp_401;
			Boolean[] f_tmp_403 = env.inputOfAlice(Utils.fromInt(__tmp413, 2));
			Boolean f_tmp_402 = intLib.eq(ind, f_tmp_403);
			Boolean __tmp414 = f_tmp_402;
			Boolean[] f_tmp_404 = cres[i];
			Boolean[] __tmp415 = f_tmp_404;
			int f_tmp_405 = 0;
			int __tmp416 = f_tmp_405;
			Boolean[] f_tmp_407 = env.inputOfAlice(Utils.fromInt(__tmp416, 2));
			Boolean f_tmp_406 = intLib.not(intLib.leq(__tmp415, f_tmp_407));
			Boolean __tmp417 = f_tmp_406;
			Boolean f_tmp_408 = intLib.and(__tmp414,__tmp417);
			Boolean __tmp418 = f_tmp_408;
			Boolean[] f_tmp_409 = depth[i];
			Boolean[] __tmp419 = f_tmp_409;
			Boolean[] f_tmp_410 = intLib.mux(__tmp419, rd,__tmp418);
			Boolean[] __tmp420 = f_tmp_410;
			depth[i]=__tmp420;
			AVLId f_tmp_411 = new AVLId(env, m).newObj(intLib.mux(go.getBits(), lf.getBits(),__tmp418));
			AVLId __tmp421 = f_tmp_411;
			go = __tmp421;
			AVLId f_tmp_412 = left[i];
			AVLId __tmp422 = f_tmp_412;
			AVLId f_tmp_413 = new AVLId(env, m).newObj(intLib.mux(__tmp422.getBits(), rf.getBits(),__tmp418));
			AVLId __tmp423 = f_tmp_413;
			left[i]=__tmp423;
			Boolean f_tmp_414 = intLib.not(__tmp417);
			Boolean __tmp424 = f_tmp_414;
			Boolean f_tmp_415 = intLib.and(__tmp414,__tmp424);
			Boolean __tmp425 = f_tmp_415;
			Boolean[] f_tmp_416 = depth[i];
			Boolean[] __tmp426 = f_tmp_416;
			Boolean[] f_tmp_417 = intLib.mux(__tmp426, ld,__tmp425);
			Boolean[] __tmp427 = f_tmp_417;
			depth[i]=__tmp427;
			AVLId f_tmp_418 = new AVLId(env, m).newObj(intLib.mux(go.getBits(), rf.getBits(),__tmp425));
			AVLId __tmp428 = f_tmp_418;
			go = __tmp428;
			AVLId f_tmp_419 = left[i];
			AVLId __tmp429 = f_tmp_419;
			AVLId f_tmp_420 = new AVLId(env, m).newObj(intLib.mux(__tmp429.getBits(), lf.getBits(),__tmp425));
			AVLId __tmp430 = f_tmp_420;
			left[i]=__tmp430;
			Boolean[] f_tmp_421 = cres[i];
			Boolean[] __tmp431 = f_tmp_421;
			int f_tmp_422 = 0;
			int __tmp432 = f_tmp_422;
			Boolean[] f_tmp_424 = env.inputOfAlice(Utils.fromInt(__tmp432, 2));
			Boolean f_tmp_423 = intLib.eq(__tmp431, f_tmp_424);
			Boolean __tmp433 = f_tmp_423;
			Boolean f_tmp_425 = intLib.and(__tmp414,__tmp433);
			Boolean __tmp434 = f_tmp_425;
			V f_tmp_426 = values[i];
			V __tmp435 = f_tmp_426;
			V f_tmp_427 = this.factoryV.newObj(intLib.mux(ret.getBits(), __tmp435.getBits(),__tmp434));
			V __tmp436 = f_tmp_427;
			ret = __tmp436;
			int f_tmp_428 = 1;
			int __tmp437 = f_tmp_428;
			Boolean[] f_tmp_430 = env.inputOfAlice(Utils.fromInt(__tmp437, 2));
			Boolean[] f_tmp_429 = intLib.mux(ind, f_tmp_430,__tmp434);
			Boolean[] __tmp438 = f_tmp_429;
			ind = __tmp438;
			Boolean f_tmp_431 = intLib.not(__tmp433);
			Boolean __tmp439 = f_tmp_431;
			Boolean f_tmp_432 = intLib.and(__tmp414,__tmp439);
			Boolean __tmp440 = f_tmp_432;
			AVLId f_tmp_433 = new AVLId(env, m).newObj(intLib.mux(now.getBits(), go.getBits(),__tmp414));
			AVLId __tmp441 = f_tmp_433;
			now = __tmp441;
			Boolean[] f_tmp_434 = now.id;
			Boolean[] __tmp442 = f_tmp_434;
			int f_tmp_435 = 0;
			int __tmp443 = f_tmp_435;
			Boolean[] f_tmp_437 = env.inputOfAlice(Utils.fromInt(__tmp443, 32));
			Boolean f_tmp_436 = intLib.eq(__tmp442, f_tmp_437);
			Boolean __tmp444 = f_tmp_436;
			Boolean f_tmp_438 = intLib.and(__tmp414,__tmp444);
			Boolean __tmp445 = f_tmp_438;
			int f_tmp_439 = 1;
			int __tmp446 = f_tmp_439;
			Boolean[] f_tmp_441 = env.inputOfAlice(Utils.fromInt(__tmp446, 2));
			Boolean[] f_tmp_440 = intLib.mux(ind, f_tmp_441,__tmp445);
			Boolean[] __tmp447 = f_tmp_440;
			ind = __tmp447;
			Boolean f_tmp_442 = intLib.not(__tmp444);
			Boolean __tmp448 = f_tmp_442;
			Boolean f_tmp_443 = intLib.and(__tmp414,__tmp448);
			Boolean __tmp449 = f_tmp_443;
			Boolean f_tmp_444 = intLib.not(__tmp414);
			Boolean __tmp450 = f_tmp_444;
			int f_tmp_445 = 1;
			int __tmp451 = f_tmp_445;
			int f_tmp_446 = i + __tmp451;
			int __tmp452 = f_tmp_446;
			i = __tmp452;
			int f_tmp_447 = 3;
			__tmp369 = f_tmp_447;
			int f_tmp_448 = __tmp369 * m;
			__tmp370 = f_tmp_448;
			int f_tmp_449 = 2;
			__tmp371 = f_tmp_449;
			int f_tmp_450 = __tmp370 / __tmp371;
			__tmp372 = f_tmp_450;
			boolean f_tmp_451 = i < __tmp372;
			__tmp373 = f_tmp_451;
		}
		int f_tmp_452 = 0;
		int __tmp453 = f_tmp_452;
		int f_tmp_453 = 1;
		int __tmp454 = f_tmp_453;
		int f_tmp_454 = __tmp453 - __tmp454;
		int __tmp455 = f_tmp_454;
		nowDepth = env.inputOfAlice(Utils.fromInt(__tmp455, (m)+(1)));
		nid = now;
		int f_tmp_455 = 3;
		int __tmp456 = f_tmp_455;
		int f_tmp_456 = __tmp456 * m;
		int __tmp457 = f_tmp_456;
		int f_tmp_457 = 2;
		int __tmp458 = f_tmp_457;
		int f_tmp_458 = __tmp457 / __tmp458;
		int __tmp459 = f_tmp_458;
		int f_tmp_459 = 1;
		int __tmp460 = f_tmp_459;
		int f_tmp_460 = __tmp459 - __tmp460;
		int __tmp461 = f_tmp_460;
		i = __tmp461;
		int f_tmp_461 = 0;
		int __tmp462 = f_tmp_461;
		boolean f_tmp_462 = i >= __tmp462;
		boolean __tmp463 = f_tmp_462;
		while(__tmp463) {
			Boolean[] f_tmp_463 = ids[i];
			Boolean[] __tmp464 = f_tmp_463;
			int f_tmp_464 = 0;
			int __tmp465 = f_tmp_464;
			Boolean[] f_tmp_466 = env.inputOfAlice(Utils.fromInt(__tmp465, 2));
			Boolean f_tmp_465 = intLib.eq(__tmp464, f_tmp_466);
			Boolean __tmp466 = f_tmp_465;
			Boolean[] f_tmp_467 = this.total;
			Boolean[] __tmp467 = f_tmp_467;
			int f_tmp_468 = 1;
			int __tmp468 = f_tmp_468;
			Boolean[] f_tmp_470 = env.inputOfAlice(Utils.fromInt(__tmp468, 32));
			Boolean[] f_tmp_469 = intLib.add(__tmp467,f_tmp_470);
			Boolean[] __tmp469 = f_tmp_469;
			Boolean[] f_tmp_471 = this.total;
			Boolean[] __tmp470 = f_tmp_471;
			Boolean[] f_tmp_472 = intLib.mux(__tmp470, __tmp469,__tmp466);
			Boolean[] __tmp471 = f_tmp_472;
			this.total = __tmp471;
			Boolean[] f_tmp_473 = this.total;
			Boolean[] __tmp472 = f_tmp_473;
			Boolean[] f_tmp_474 = intLib.mux(id, __tmp472,__tmp466);
			Boolean[] __tmp473 = f_tmp_474;
			id = __tmp473;
			Boolean[] f_tmp_475 = intLib.randBools(m);
			Boolean[] __tmp474 = f_tmp_475;
			Boolean[] f_tmp_476 = intLib.mux(pos, __tmp474,__tmp466);
			Boolean[] __tmp475 = f_tmp_476;
			pos = __tmp475;
			Boolean[] f_tmp_477 = intLib.mux(hpos, pos,__tmp466);
			Boolean[] __tmp476 = f_tmp_477;
			hpos = __tmp476;
			AVLId f_tmp_478 = new AVLId(env, m);
			f_tmp_478.pos = pos;
			f_tmp_478.id = id;
			AVLId __tmp477 = f_tmp_478;
			AVLId f_tmp_479 = new AVLId(env, m).newObj(intLib.mux(next.getBits(), __tmp477.getBits(),__tmp466));
			AVLId __tmp478 = f_tmp_479;
			next = __tmp478;
			Boolean[] f_tmp_480 = cres[i];
			Boolean[] __tmp479 = f_tmp_480;
			int f_tmp_481 = 0;
			int __tmp480 = f_tmp_481;
			Boolean[] f_tmp_483 = env.inputOfAlice(Utils.fromInt(__tmp480, 2));
			Boolean f_tmp_482 = intLib.not(intLib.leq(__tmp479, f_tmp_483));
			Boolean __tmp481 = f_tmp_482;
			Boolean f_tmp_484 = intLib.and(__tmp466,__tmp481);
			Boolean __tmp482 = f_tmp_484;
			Boolean[] f_tmp_485 = intLib.mux(ld, nowDepth,__tmp482);
			Boolean[] __tmp483 = f_tmp_485;
			ld = __tmp483;
			Boolean[] f_tmp_486 = depth[i];
			Boolean[] __tmp484 = f_tmp_486;
			Boolean[] f_tmp_487 = intLib.mux(rd, __tmp484,__tmp482);
			Boolean[] __tmp485 = f_tmp_487;
			rd = __tmp485;
			AVLId f_tmp_488 = new AVLId(env, m).newObj(intLib.mux(ll.getBits(), nid.getBits(),__tmp482));
			AVLId __tmp486 = f_tmp_488;
			ll = __tmp486;
			AVLId f_tmp_489 = left[i];
			AVLId __tmp487 = f_tmp_489;
			AVLId f_tmp_490 = new AVLId(env, m).newObj(intLib.mux(rr.getBits(), __tmp487.getBits(),__tmp482));
			AVLId __tmp488 = f_tmp_490;
			rr = __tmp488;
			Boolean f_tmp_491 = intLib.not(__tmp481);
			Boolean __tmp489 = f_tmp_491;
			Boolean f_tmp_492 = intLib.and(__tmp466,__tmp489);
			Boolean __tmp490 = f_tmp_492;
			Boolean[] f_tmp_493 = depth[i];
			Boolean[] __tmp491 = f_tmp_493;
			Boolean[] f_tmp_494 = intLib.mux(ld, __tmp491,__tmp490);
			Boolean[] __tmp492 = f_tmp_494;
			ld = __tmp492;
			Boolean[] f_tmp_495 = intLib.mux(rd, nowDepth,__tmp490);
			Boolean[] __tmp493 = f_tmp_495;
			rd = __tmp493;
			AVLId f_tmp_496 = left[i];
			AVLId __tmp494 = f_tmp_496;
			AVLId f_tmp_497 = new AVLId(env, m).newObj(intLib.mux(ll.getBits(), __tmp494.getBits(),__tmp490));
			AVLId __tmp495 = f_tmp_497;
			ll = __tmp495;
			AVLId f_tmp_498 = new AVLId(env, m).newObj(intLib.mux(rr.getBits(), nid.getBits(),__tmp490));
			AVLId __tmp496 = f_tmp_498;
			rr = __tmp496;
			AVLId f_tmp_499 = new AVLId(env, m).newObj(intLib.mux(nid.getBits(), next.getBits(),__tmp466));
			AVLId __tmp497 = f_tmp_499;
			nid = __tmp497;
			V f_tmp_500 = values[i];
			V __tmp498 = f_tmp_500;
			K f_tmp_501 = keys[i];
			K __tmp499 = f_tmp_501;
			AVLNode<K, V> f_tmp_502 = new AVLNode<K, V>(env, m, factoryK, factoryV);
			f_tmp_502.left = ll;
			f_tmp_502.rDepth = rd;
			f_tmp_502.right = rr;
			f_tmp_502.value = __tmp498;
			f_tmp_502.key = __tmp499;
			f_tmp_502.lDepth = ld;
			AVLNode<K, V> __tmp500 = f_tmp_502;
			CircuitOram<Boolean> f_tmp_503 = this.poram;
			CircuitOram<Boolean> __tmp501 = f_tmp_503;
			__tmp501.conditionalPutBack(id, pos, __tmp500.getBits(), __tmp466);
			Boolean[] f_tmp_505 = depth[i];
			Boolean[] __tmp503 = f_tmp_505;
			Boolean f_tmp_506 = intLib.not(intLib.leq(__tmp503, nowDepth));
			Boolean __tmp504 = f_tmp_506;
			Boolean f_tmp_507 = intLib.and(__tmp466,__tmp504);
			Boolean __tmp505 = f_tmp_507;
			Boolean[] f_tmp_508 = depth[i];
			Boolean[] __tmp506 = f_tmp_508;
			Boolean[] f_tmp_509 = intLib.mux(nowDepth, __tmp506,__tmp505);
			Boolean[] __tmp507 = f_tmp_509;
			nowDepth = __tmp507;
			Boolean f_tmp_510 = intLib.not(__tmp504);
			Boolean __tmp508 = f_tmp_510;
			Boolean f_tmp_511 = intLib.and(__tmp466,__tmp508);
			Boolean __tmp509 = f_tmp_511;
			int f_tmp_512 = 1;
			int __tmp510 = f_tmp_512;
			Boolean[] f_tmp_514 = env.inputOfAlice(Utils.fromInt(__tmp510, (m)+(1)));
			Boolean[] f_tmp_513 = intLib.add(nowDepth,f_tmp_514);
			Boolean[] __tmp511 = f_tmp_513;
			Boolean[] f_tmp_515 = intLib.mux(nowDepth, __tmp511,__tmp466);
			Boolean[] __tmp512 = f_tmp_515;
			nowDepth = __tmp512;
			Boolean f_tmp_516 = intLib.not(__tmp466);
			Boolean __tmp513 = f_tmp_516;
			int f_tmp_517 = 1;
			int __tmp514 = f_tmp_517;
			int f_tmp_518 = i - __tmp514;
			int __tmp515 = f_tmp_518;
			i = __tmp515;
			int f_tmp_519 = 0;
			__tmp462 = f_tmp_519;
			boolean f_tmp_520 = i >= __tmp462;
			__tmp463 = f_tmp_520;
		}
		this.root = nid;
		return ret;
	}
}
