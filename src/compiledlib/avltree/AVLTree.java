package compiledlib.avltree;
import java.security.SecureRandom;

import oram.SecureArray;
import oram.CircuitOram;
import flexsc.Mode;
import flexsc.Party;
import flexsc.CompEnv;

import java.util.BitSet;

import circuits.arithmetic.IntegerLib;
import util.Utils;
import gc.regular.GCEva;
import gc.regular.GCGen;
import gc.GCSignal;

import java.util.Arrays;
import java.util.Random;

import flexsc.IWritable;
import flexsc.Comparator;

import java.lang.reflect.Array;
public class AVLTree<K extends IWritable<K,Boolean>, V extends IWritable<V,Boolean>> {
	public CircuitOram<Boolean> poram;
	public Boolean[] total;
	public AVLId root;
	public IntStack IDs;

	public CompEnv<Boolean> env;
	public IntegerLib<Boolean> intLib;
	private K factoryK;
	private V factoryV;
	private int m;

	public AVLTree(CompEnv<Boolean> env, IntegerLib<Boolean> intLib, int m, K factoryK, V factoryV, CircuitOram<Boolean> poram, IntStack IDs) throws Exception {
		this.env = env;
		this.intLib = intLib;
		this.m = m;
		this.factoryK = factoryK;
		this.factoryV = factoryV;
		this.poram = poram;
		this.total = env.inputOfAlice(Utils.fromInt(0, m));
		this.root = new AVLId(env, intLib, m);
		this.IDs = IDs;
	}

	public void init() throws Exception {
		int i = 0;
		int f_tmp_46 = 0;
		int __tmp41 = f_tmp_46;
		Boolean[] f_tmp_47 = env.inputOfAlice(Utils.fromInt(__tmp41, m));
		this.total = f_tmp_47;
		Boolean[] f_tmp_48 = intLib.randBools(m);
		Boolean[] __tmp42 = f_tmp_48;
		int f_tmp_49 = 0;
		int __tmp43 = f_tmp_49;
		AVLId f_tmp_50 = new AVLId(env, intLib, m);
		f_tmp_50.pos = __tmp42;
		f_tmp_50.id = env.inputOfAlice(Utils.fromInt(__tmp43, m));
		AVLId __tmp44 = f_tmp_50;
		this.root = __tmp44;
		int f_tmp_51 = 1;
		int __tmp45 = f_tmp_51;
		i = __tmp45;
		int f_tmp_52 = 1;
		int __tmp46 = f_tmp_52;
		int f_tmp_53 = __tmp46 << m;
		int __tmp47 = f_tmp_53;
		boolean f_tmp_54 = i < __tmp47;
		boolean __tmp48 = f_tmp_54;
		while(__tmp48) {
			boolean f_tmp_55 = false;
			boolean __tmp49 = f_tmp_55;
			boolean f_tmp_56 = true;
			Boolean __tmp51 = env.inputOfAlice(f_tmp_56);
			IntStack f_tmp_57 = this.IDs;
			IntStack __tmp50 = f_tmp_57;
			Boolean[] f_tmp_58 = __tmp50.stack_op(env.inputOfAlice(Utils.fromInt(i, m)), env.inputOfAlice(__tmp49), __tmp51);
			Boolean[] __tmp52 = f_tmp_58;
			int f_tmp_59 = 1;
			int __tmp53 = f_tmp_59;
			int f_tmp_60 = i + __tmp53;
			int __tmp54 = f_tmp_60;
			i = __tmp54;
			int f_tmp_61 = 1;
			__tmp46 = f_tmp_61;
			int f_tmp_62 = __tmp46 << m;
			__tmp47 = f_tmp_62;
			boolean f_tmp_63 = i < __tmp47;
			__tmp48 = f_tmp_63;
		}

	}
	public void insert(K key, V value, FUNC_1_INTsecure_T1_T1<K> cmp) throws Exception {
		AVLNode<K, V> tnodes = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV);
		AVLNode<K, V> p = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV);
		AVLId now = new AVLId(env, intLib, m);
		AVLId go = new AVLId(env, intLib, m);
		AVLId a = new AVLId(env, intLib, m);
		AVLId b = new AVLId(env, intLib, m);
		AVLId c = new AVLId(env, intLib, m);
		AVLId[] left = (AVLId[])Array.newInstance((Class<AVLId>)(new AVLId(env, intLib, m).getClass()), ((3)*(m))/(2));
		for(int _j_=0; _j_<((3)*(m))/(2); ++_j_) {
			left[_j_] = new AVLId(env, intLib, m);
		}
		K[] keys = (K[])Array.newInstance((Class<K>)factoryK.getClass(), ((3)*(m))/(2));
		for(int _j_=0; _j_<((3)*(m))/(2); ++_j_) {
			keys[_j_] = factoryK.newObj(null);
		}
		V[] values = (V[])Array.newInstance((Class<V>)factoryV.getClass(), ((3)*(m))/(2));
		for(int _j_=0; _j_<((3)*(m))/(2); ++_j_) {
			values[_j_] = factoryV.newObj(null);
		}
		Boolean[][] depth = new Boolean[((3)*(m))/(2)][];
		for(int _j_=0; _j_<((3)*(m))/(2); ++_j_) {
			depth[_j_] = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		}
		Boolean[][] ids = new Boolean[((3)*(m))/(2)][];
		for(int _j_=0; _j_<((3)*(m))/(2); ++_j_) {
			ids[_j_] = env.inputOfAlice(Utils.fromInt(0, 2));
		}
		Boolean[][] cres = new Boolean[((3)*(m))/(2)][];
		for(int _j_=0; _j_<((3)*(m))/(2); ++_j_) {
			cres[_j_] = env.inputOfAlice(Utils.fromInt(0, 2));
		}
		Boolean[] ind = env.inputOfAlice(Utils.fromInt(0, 2));
		Boolean[] id = env.inputOfAlice(Utils.fromInt(0, m));
		Boolean[] pos = intLib.randBools(m);
		Boolean[] hpos = env.inputOfAlice(Utils.fromInt(0, m));
		K k = factoryK.newObj(null);
		K kp = factoryK.newObj(null);
		V v = factoryV.newObj(null);
		V vp = factoryV.newObj(null);
		Boolean[] dl = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dr = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId lf = new AVLId(env, intLib, m);
		AVLId rf = new AVLId(env, intLib, m);
		int i = 0;
		int pre = 0;
		Boolean[] nowDepth = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] ld = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] rd = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dc = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dap = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dbp = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId nid = new AVLId(env, intLib, m);
		AVLId next = new AVLId(env, intLib, m);
		AVLId ll = new AVLId(env, intLib, m);
		AVLId rr = new AVLId(env, intLib, m);
		AVLId l = new AVLId(env, intLib, m);
		Boolean[] dp = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId f_tmp_64 = this.root;
		AVLId __tmp55 = f_tmp_64;
		now = __tmp55;
		int f_tmp_65 = 0;
		int __tmp56 = f_tmp_65;
		ind = env.inputOfAlice(Utils.fromInt(__tmp56, 2));
		Boolean[] __tmp57 = now.pos;
		Boolean[] __tmp58 = now.id;
		id = __tmp58;
		pos = __tmp57;
		int f_tmp_66 = 0;
		int __tmp59 = f_tmp_66;
		Boolean[] f_tmp_68 = env.inputOfAlice(Utils.fromInt(__tmp59, m));
		Boolean f_tmp_67 = intLib.eq(id, f_tmp_68);
		Boolean __tmp60 = f_tmp_67;
		int f_tmp_69 = 0;
		int __tmp61 = f_tmp_69;
		Boolean[] f_tmp_71 = env.inputOfAlice(Utils.fromInt(__tmp61, 2));
		Boolean[] f_tmp_70 = intLib.mux(ind, f_tmp_71,__tmp60);
		Boolean[] __tmp62 = f_tmp_70;
		ind = __tmp62;
		Boolean f_tmp_72 = intLib.not(__tmp60);
		Boolean __tmp63 = f_tmp_72;
		AVLId f_tmp_73 = new AVLId(env, intLib, m);
		f_tmp_73.pos = pos;
		f_tmp_73.id = id;
		AVLId __tmp64 = f_tmp_73;
		now = __tmp64;
		int f_tmp_74 = 0;
		int __tmp65 = f_tmp_74;
		i = __tmp65;
		int f_tmp_75 = 3;
		int __tmp66 = f_tmp_75;
		int f_tmp_76 = __tmp66 * m;
		int __tmp67 = f_tmp_76;
		int f_tmp_77 = 2;
		int __tmp68 = f_tmp_77;
		int f_tmp_78 = __tmp67 / __tmp68;
		int __tmp69 = f_tmp_78;
		boolean f_tmp_79 = i < __tmp69;
		boolean __tmp70 = f_tmp_79;
		while(__tmp70) {
			ids[i]=ind;
			int f_tmp_80 = 1;
			int __tmp71 = f_tmp_80;
			int f_tmp_81 = i - __tmp71;
			int __tmp72 = f_tmp_81;
			pre = __tmp72;
			int f_tmp_82 = 0;
			int __tmp73 = f_tmp_82;
			boolean f_tmp_83 = i == __tmp73;
			boolean __tmp74 = f_tmp_83;
			if(__tmp74) {
				int f_tmp_84 = 0;
				int __tmp75 = f_tmp_84;
				pre = __tmp75;
			} else {
			}
			int f_tmp_85 = 0;
			int __tmp76 = f_tmp_85;
			Boolean[] f_tmp_87 = env.inputOfAlice(Utils.fromInt(__tmp76, 2));
			Boolean f_tmp_86 = intLib.eq(ind, f_tmp_87);
			Boolean __tmp77 = f_tmp_86;
			Boolean[] __tmp78 = now.pos;
			Boolean[] __tmp79 = now.id;
			Boolean[] f_tmp_88 = intLib.mux(id, __tmp79,__tmp77);
			Boolean[] __tmp80 = f_tmp_88;
			id = __tmp80;
			Boolean[] f_tmp_89 = intLib.mux(pos, __tmp78,__tmp77);
			Boolean[] __tmp81 = f_tmp_89;
			pos = __tmp81;
			CircuitOram<Boolean> f_tmp_90 = this.poram;
			CircuitOram<Boolean> __tmp82 = f_tmp_90;
			AVLNode<K, V> f_tmp_91 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV).newObj(__tmp82.conditionalReadAndRemove(id, pos, __tmp77));
			AVLNode<K, V> __tmp83 = f_tmp_91;
			AVLNode<K, V> f_tmp_92 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV).newObj(intLib.mux(tnodes.getBits(), __tmp83.getBits(),__tmp77));
			AVLNode<K, V> __tmp84 = f_tmp_92;
			tnodes = __tmp84;
			boolean f_tmp_93 = false;
			boolean __tmp85 = f_tmp_93;
			IntStack f_tmp_94 = this.IDs;
			IntStack __tmp86 = f_tmp_94;
			Boolean[] f_tmp_95 = __tmp86.stack_op(id, env.inputOfAlice(__tmp85), __tmp77);
			Boolean[] __tmp87 = f_tmp_95;
			AVLId __tmp88 = tnodes.left;
			Boolean[] __tmp89 = tnodes.rDepth;
			AVLId __tmp90 = tnodes.right;
			V __tmp91 = tnodes.value;
			K __tmp92 = tnodes.key;
			Boolean[] __tmp93 = tnodes.lDepth;
			K f_tmp_96 = keys[i];
			K __tmp94 = f_tmp_96;
			K f_tmp_97 = this.factoryK.newObj(intLib.mux(__tmp94.getBits(), __tmp92.getBits(),__tmp77));
			K __tmp95 = f_tmp_97;
			keys[i]=__tmp95;
			V f_tmp_98 = values[i];
			V __tmp96 = f_tmp_98;
			V f_tmp_99 = this.factoryV.newObj(intLib.mux(__tmp96.getBits(), __tmp91.getBits(),__tmp77));
			V __tmp97 = f_tmp_99;
			values[i]=__tmp97;
			Boolean[] f_tmp_100 = intLib.mux(ld, __tmp93,__tmp77);
			Boolean[] __tmp98 = f_tmp_100;
			ld = __tmp98;
			Boolean[] f_tmp_101 = intLib.mux(rd, __tmp89,__tmp77);
			Boolean[] __tmp99 = f_tmp_101;
			rd = __tmp99;
			AVLId f_tmp_102 = new AVLId(env, intLib, m).newObj(intLib.mux(lf.getBits(), __tmp88.getBits(),__tmp77));
			AVLId __tmp100 = f_tmp_102;
			lf = __tmp100;
			AVLId f_tmp_103 = new AVLId(env, intLib, m).newObj(intLib.mux(rf.getBits(), __tmp90.getBits(),__tmp77));
			AVLId __tmp101 = f_tmp_103;
			rf = __tmp101;
			Boolean f_tmp_104 = intLib.not(__tmp77);
			Boolean __tmp102 = f_tmp_104;
			int f_tmp_105 = 1;
			int __tmp103 = f_tmp_105;
			Boolean[] f_tmp_107 = env.inputOfAlice(Utils.fromInt(__tmp103, 2));
			Boolean f_tmp_106 = intLib.eq(ind, f_tmp_107);
			Boolean __tmp104 = f_tmp_106;
			Boolean f_tmp_108 = intLib.and(__tmp102,__tmp104);
			Boolean __tmp105 = f_tmp_108;
			K f_tmp_109 = keys[i];
			K __tmp106 = f_tmp_109;
			K f_tmp_110 = this.factoryK.newObj(intLib.mux(__tmp106.getBits(), key.getBits(),__tmp105));
			K __tmp107 = f_tmp_110;
			keys[i]=__tmp107;
			V f_tmp_111 = values[i];
			V __tmp108 = f_tmp_111;
			V f_tmp_112 = this.factoryV.newObj(intLib.mux(__tmp108.getBits(), value.getBits(),__tmp105));
			V __tmp109 = f_tmp_112;
			values[i]=__tmp109;
			int f_tmp_113 = 0;
			int __tmp110 = f_tmp_113;
			int f_tmp_114 = 1;
			int __tmp111 = f_tmp_114;
			int f_tmp_115 = __tmp110 - __tmp111;
			int __tmp112 = f_tmp_115;
			Boolean[] f_tmp_116 = depth[i];
			Boolean[] __tmp113 = f_tmp_116;
			Boolean[] f_tmp_118 = env.inputOfAlice(Utils.fromInt(__tmp112, (m)+(1)));
			Boolean[] f_tmp_117 = intLib.mux(__tmp113, f_tmp_118,__tmp105);
			Boolean[] __tmp114 = f_tmp_117;
			depth[i]=__tmp114;
			Boolean[] f_tmp_119 = intLib.randBools(m);
			Boolean[] __tmp115 = f_tmp_119;
			int f_tmp_120 = 0;
			int __tmp116 = f_tmp_120;
			AVLId f_tmp_121 = new AVLId(env, intLib, m);
			f_tmp_121.pos = __tmp115;
			f_tmp_121.id = env.inputOfAlice(Utils.fromInt(__tmp116, m));
			AVLId __tmp117 = f_tmp_121;
			AVLId f_tmp_122 = left[i];
			AVLId __tmp118 = f_tmp_122;
			AVLId f_tmp_123 = new AVLId(env, intLib, m).newObj(intLib.mux(__tmp118.getBits(), __tmp117.getBits(),__tmp105));
			AVLId __tmp119 = f_tmp_123;
			left[i]=__tmp119;
			int f_tmp_124 = 2;
			int __tmp120 = f_tmp_124;
			Boolean[] f_tmp_126 = env.inputOfAlice(Utils.fromInt(__tmp120, 2));
			Boolean[] f_tmp_125 = intLib.mux(ind, f_tmp_126,__tmp105);
			Boolean[] __tmp121 = f_tmp_125;
			ind = __tmp121;
			Boolean f_tmp_127 = intLib.not(__tmp104);
			Boolean __tmp122 = f_tmp_127;
			Boolean f_tmp_128 = intLib.and(__tmp102,__tmp122);
			Boolean __tmp123 = f_tmp_128;
			int f_tmp_129 = 0;
			int __tmp124 = f_tmp_129;
			int f_tmp_130 = 1;
			int __tmp125 = f_tmp_130;
			int f_tmp_131 = __tmp124 - __tmp125;
			int __tmp126 = f_tmp_131;
			Boolean[] f_tmp_132 = depth[i];
			Boolean[] __tmp127 = f_tmp_132;
			Boolean[] f_tmp_134 = env.inputOfAlice(Utils.fromInt(__tmp126, (m)+(1)));
			Boolean[] f_tmp_133 = intLib.mux(__tmp127, f_tmp_134,__tmp123);
			Boolean[] __tmp128 = f_tmp_133;
			depth[i]=__tmp128;
			K f_tmp_135 = keys[pre];
			K __tmp129 = f_tmp_135;
			K f_tmp_136 = keys[i];
			K __tmp130 = f_tmp_136;
			K f_tmp_137 = this.factoryK.newObj(intLib.mux(__tmp130.getBits(), __tmp129.getBits(),__tmp123));
			K __tmp131 = f_tmp_137;
			keys[i]=__tmp131;
			K f_tmp_138 = keys[i];
			K __tmp132 = f_tmp_138;
			Boolean[] f_tmp_139 = cmp.calc(__tmp132, key);
			Boolean[] __tmp133 = f_tmp_139;
			cres[i]=__tmp133;
			int f_tmp_140 = 0;
			int __tmp134 = f_tmp_140;
			Boolean[] f_tmp_142 = env.inputOfAlice(Utils.fromInt(__tmp134, 2));
			Boolean f_tmp_141 = intLib.eq(ind, f_tmp_142);
			Boolean __tmp135 = f_tmp_141;
			Boolean[] f_tmp_143 = cres[i];
			Boolean[] __tmp136 = f_tmp_143;
			int f_tmp_144 = 0;
			int __tmp137 = f_tmp_144;
			Boolean[] f_tmp_146 = env.inputOfAlice(Utils.fromInt(__tmp137, 2));
			Boolean f_tmp_145 = intLib.not(intLib.leq(__tmp136, f_tmp_146));
			Boolean __tmp138 = f_tmp_145;
			Boolean f_tmp_147 = intLib.and(__tmp135,__tmp138);
			Boolean __tmp139 = f_tmp_147;
			Boolean[] f_tmp_148 = depth[i];
			Boolean[] __tmp140 = f_tmp_148;
			Boolean[] f_tmp_149 = intLib.mux(__tmp140, dr,__tmp139);
			Boolean[] __tmp141 = f_tmp_149;
			depth[i]=__tmp141;
			AVLId f_tmp_150 = new AVLId(env, intLib, m).newObj(intLib.mux(go.getBits(), lf.getBits(),__tmp139));
			AVLId __tmp142 = f_tmp_150;
			go = __tmp142;
			AVLId f_tmp_151 = left[i];
			AVLId __tmp143 = f_tmp_151;
			AVLId f_tmp_152 = new AVLId(env, intLib, m).newObj(intLib.mux(__tmp143.getBits(), rf.getBits(),__tmp139));
			AVLId __tmp144 = f_tmp_152;
			left[i]=__tmp144;
			Boolean f_tmp_153 = intLib.not(__tmp138);
			Boolean __tmp145 = f_tmp_153;
			Boolean f_tmp_154 = intLib.and(__tmp135,__tmp145);
			Boolean __tmp146 = f_tmp_154;
			Boolean[] f_tmp_155 = depth[i];
			Boolean[] __tmp147 = f_tmp_155;
			Boolean[] f_tmp_156 = intLib.mux(__tmp147, dl,__tmp146);
			Boolean[] __tmp148 = f_tmp_156;
			depth[i]=__tmp148;
			AVLId f_tmp_157 = new AVLId(env, intLib, m).newObj(intLib.mux(go.getBits(), rf.getBits(),__tmp146));
			AVLId __tmp149 = f_tmp_157;
			go = __tmp149;
			AVLId f_tmp_158 = left[i];
			AVLId __tmp150 = f_tmp_158;
			AVLId f_tmp_159 = new AVLId(env, intLib, m).newObj(intLib.mux(__tmp150.getBits(), lf.getBits(),__tmp146));
			AVLId __tmp151 = f_tmp_159;
			left[i]=__tmp151;
			AVLId f_tmp_160 = new AVLId(env, intLib, m).newObj(intLib.mux(now.getBits(), go.getBits(),__tmp135));
			AVLId __tmp152 = f_tmp_160;
			now = __tmp152;
			Boolean[] f_tmp_161 = now.id;
			Boolean[] __tmp153 = f_tmp_161;
			int f_tmp_162 = 0;
			int __tmp154 = f_tmp_162;
			Boolean[] f_tmp_164 = env.inputOfAlice(Utils.fromInt(__tmp154, m));
			Boolean f_tmp_163 = intLib.eq(__tmp153, f_tmp_164);
			Boolean __tmp155 = f_tmp_163;
			Boolean f_tmp_165 = intLib.and(__tmp135,__tmp155);
			Boolean __tmp156 = f_tmp_165;
			int f_tmp_166 = 1;
			int __tmp157 = f_tmp_166;
			Boolean[] f_tmp_168 = env.inputOfAlice(Utils.fromInt(__tmp157, 2));
			Boolean[] f_tmp_167 = intLib.mux(ind, f_tmp_168,__tmp156);
			Boolean[] __tmp158 = f_tmp_167;
			ind = __tmp158;
			Boolean f_tmp_169 = intLib.not(__tmp155);
			Boolean __tmp159 = f_tmp_169;
			Boolean f_tmp_170 = intLib.and(__tmp135,__tmp159);
			Boolean __tmp160 = f_tmp_170;
			Boolean f_tmp_171 = intLib.not(__tmp135);
			Boolean __tmp161 = f_tmp_171;
			int f_tmp_172 = 1;
			int __tmp162 = f_tmp_172;
			int f_tmp_173 = i + __tmp162;
			int __tmp163 = f_tmp_173;
			i = __tmp163;
			int f_tmp_174 = 3;
			__tmp66 = f_tmp_174;
			int f_tmp_175 = __tmp66 * m;
			__tmp67 = f_tmp_175;
			int f_tmp_176 = 2;
			__tmp68 = f_tmp_176;
			int f_tmp_177 = __tmp67 / __tmp68;
			__tmp69 = f_tmp_177;
			boolean f_tmp_178 = i < __tmp69;
			__tmp70 = f_tmp_178;
		}
		int f_tmp_179 = 0;
		int __tmp164 = f_tmp_179;
		int f_tmp_180 = 1;
		int __tmp165 = f_tmp_180;
		int f_tmp_181 = __tmp164 - __tmp165;
		int __tmp166 = f_tmp_181;
		nowDepth = env.inputOfAlice(Utils.fromInt(__tmp166, (m)+(1)));
		Boolean[] f_tmp_182 = intLib.randBools(m);
		Boolean[] __tmp167 = f_tmp_182;
		int f_tmp_183 = 0;
		int __tmp168 = f_tmp_183;
		AVLId f_tmp_184 = new AVLId(env, intLib, m);
		f_tmp_184.pos = __tmp167;
		f_tmp_184.id = env.inputOfAlice(Utils.fromInt(__tmp168, m));
		AVLId __tmp169 = f_tmp_184;
		nid = __tmp169;
		int f_tmp_185 = 3;
		int __tmp170 = f_tmp_185;
		int f_tmp_186 = __tmp170 * m;
		int __tmp171 = f_tmp_186;
		int f_tmp_187 = 2;
		int __tmp172 = f_tmp_187;
		int f_tmp_188 = __tmp171 / __tmp172;
		int __tmp173 = f_tmp_188;
		int f_tmp_189 = 1;
		int __tmp174 = f_tmp_189;
		int f_tmp_190 = __tmp173 - __tmp174;
		int __tmp175 = f_tmp_190;
		i = __tmp175;
		int f_tmp_191 = 0;
		int __tmp176 = f_tmp_191;
		boolean f_tmp_192 = i >= __tmp176;
		boolean __tmp177 = f_tmp_192;
		while(__tmp177) {
			Boolean[] f_tmp_193 = ids[i];
			Boolean[] __tmp178 = f_tmp_193;
			int f_tmp_194 = 0;
			int __tmp179 = f_tmp_194;
			Boolean[] f_tmp_196 = env.inputOfAlice(Utils.fromInt(__tmp179, 2));
			Boolean f_tmp_195 = intLib.eq(__tmp178, f_tmp_196);
			Boolean __tmp180 = f_tmp_195;
			int f_tmp_197 = 0;
			int __tmp181 = f_tmp_197;
			boolean f_tmp_198 = true;
			boolean __tmp182 = f_tmp_198;
			IntStack f_tmp_199 = this.IDs;
			IntStack __tmp183 = f_tmp_199;
			Boolean[] f_tmp_200 = __tmp183.stack_op(env.inputOfAlice(Utils.fromInt(__tmp181, m)), env.inputOfAlice(__tmp182), __tmp180);
			Boolean[] __tmp184 = f_tmp_200;
			Boolean[] f_tmp_201 = intLib.mux(id, __tmp184,__tmp180);
			Boolean[] __tmp185 = f_tmp_201;
			id = __tmp185;
			Boolean[] f_tmp_202 = intLib.randBools(m);
			Boolean[] __tmp186 = f_tmp_202;
			Boolean[] f_tmp_203 = intLib.mux(pos, __tmp186,__tmp180);
			Boolean[] __tmp187 = f_tmp_203;
			pos = __tmp187;
			Boolean[] f_tmp_204 = intLib.mux(hpos, pos,__tmp180);
			Boolean[] __tmp188 = f_tmp_204;
			hpos = __tmp188;
			AVLId f_tmp_205 = new AVLId(env, intLib, m);
			f_tmp_205.pos = pos;
			f_tmp_205.id = id;
			AVLId __tmp189 = f_tmp_205;
			AVLId f_tmp_206 = new AVLId(env, intLib, m).newObj(intLib.mux(next.getBits(), __tmp189.getBits(),__tmp180));
			AVLId __tmp190 = f_tmp_206;
			next = __tmp190;
			Boolean[] f_tmp_207 = cres[i];
			Boolean[] __tmp191 = f_tmp_207;
			int f_tmp_208 = 0;
			int __tmp192 = f_tmp_208;
			Boolean[] f_tmp_210 = env.inputOfAlice(Utils.fromInt(__tmp192, 2));
			Boolean f_tmp_209 = intLib.geq(__tmp191, f_tmp_210);
			Boolean __tmp193 = f_tmp_209;
			Boolean f_tmp_211 = intLib.and(__tmp180,__tmp193);
			Boolean __tmp194 = f_tmp_211;
			Boolean[] f_tmp_212 = intLib.mux(ld, nowDepth,__tmp194);
			Boolean[] __tmp195 = f_tmp_212;
			ld = __tmp195;
			Boolean[] f_tmp_213 = depth[i];
			Boolean[] __tmp196 = f_tmp_213;
			Boolean[] f_tmp_214 = intLib.mux(rd, __tmp196,__tmp194);
			Boolean[] __tmp197 = f_tmp_214;
			rd = __tmp197;
			AVLId f_tmp_215 = new AVLId(env, intLib, m).newObj(intLib.mux(ll.getBits(), nid.getBits(),__tmp194));
			AVLId __tmp198 = f_tmp_215;
			ll = __tmp198;
			AVLId f_tmp_216 = left[i];
			AVLId __tmp199 = f_tmp_216;
			AVLId f_tmp_217 = new AVLId(env, intLib, m).newObj(intLib.mux(rr.getBits(), __tmp199.getBits(),__tmp194));
			AVLId __tmp200 = f_tmp_217;
			rr = __tmp200;
			Boolean f_tmp_218 = intLib.not(__tmp193);
			Boolean __tmp201 = f_tmp_218;
			Boolean f_tmp_219 = intLib.and(__tmp180,__tmp201);
			Boolean __tmp202 = f_tmp_219;
			Boolean[] f_tmp_220 = depth[i];
			Boolean[] __tmp203 = f_tmp_220;
			Boolean[] f_tmp_221 = intLib.mux(ld, __tmp203,__tmp202);
			Boolean[] __tmp204 = f_tmp_221;
			ld = __tmp204;
			Boolean[] f_tmp_222 = intLib.mux(rd, nowDepth,__tmp202);
			Boolean[] __tmp205 = f_tmp_222;
			rd = __tmp205;
			AVLId f_tmp_223 = left[i];
			AVLId __tmp206 = f_tmp_223;
			AVLId f_tmp_224 = new AVLId(env, intLib, m).newObj(intLib.mux(ll.getBits(), __tmp206.getBits(),__tmp202));
			AVLId __tmp207 = f_tmp_224;
			ll = __tmp207;
			AVLId f_tmp_225 = new AVLId(env, intLib, m).newObj(intLib.mux(rr.getBits(), nid.getBits(),__tmp202));
			AVLId __tmp208 = f_tmp_225;
			rr = __tmp208;
			AVLId f_tmp_226 = new AVLId(env, intLib, m).newObj(intLib.mux(nid.getBits(), next.getBits(),__tmp180));
			AVLId __tmp209 = f_tmp_226;
			nid = __tmp209;
			V f_tmp_227 = values[i];
			V __tmp210 = f_tmp_227;
			K f_tmp_228 = keys[i];
			K __tmp211 = f_tmp_228;
			AVLNode<K, V> f_tmp_229 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV);
			f_tmp_229.left = ll;
			f_tmp_229.rDepth = rd;
			f_tmp_229.right = rr;
			f_tmp_229.value = __tmp210;
			f_tmp_229.key = __tmp211;
			f_tmp_229.lDepth = ld;
			AVLNode<K, V> __tmp212 = f_tmp_229;
			CircuitOram<Boolean> f_tmp_230 = this.poram;
			CircuitOram<Boolean> __tmp213 = f_tmp_230;
			__tmp213.conditionalPutBack(id, pos, __tmp212.getBits(), __tmp180);
			Boolean[] f_tmp_232 = depth[i];
			Boolean[] __tmp215 = f_tmp_232;
			Boolean f_tmp_233 = intLib.not(intLib.leq(__tmp215, nowDepth));
			Boolean __tmp216 = f_tmp_233;
			Boolean f_tmp_234 = intLib.and(__tmp180,__tmp216);
			Boolean __tmp217 = f_tmp_234;
			Boolean[] f_tmp_235 = depth[i];
			Boolean[] __tmp218 = f_tmp_235;
			Boolean[] f_tmp_236 = intLib.mux(nowDepth, __tmp218,__tmp217);
			Boolean[] __tmp219 = f_tmp_236;
			nowDepth = __tmp219;
			Boolean f_tmp_237 = intLib.not(__tmp216);
			Boolean __tmp220 = f_tmp_237;
			Boolean f_tmp_238 = intLib.and(__tmp180,__tmp220);
			Boolean __tmp221 = f_tmp_238;
			int f_tmp_239 = 1;
			int __tmp222 = f_tmp_239;
			Boolean[] f_tmp_241 = env.inputOfAlice(Utils.fromInt(__tmp222, (m)+(1)));
			Boolean[] f_tmp_240 = intLib.add(nowDepth,f_tmp_241);
			Boolean[] __tmp223 = f_tmp_240;
			Boolean[] f_tmp_242 = intLib.mux(nowDepth, __tmp223,__tmp180);
			Boolean[] __tmp224 = f_tmp_242;
			nowDepth = __tmp224;
			Boolean[] f_tmp_243 = intLib.sub(rd,ld);
			Boolean[] __tmp225 = f_tmp_243;
			int f_tmp_244 = 2;
			int __tmp226 = f_tmp_244;
			Boolean[] f_tmp_246 = env.inputOfAlice(Utils.fromInt(__tmp226, (m)+(1)));
			Boolean f_tmp_245 = intLib.geq(__tmp225, f_tmp_246);
			Boolean __tmp227 = f_tmp_245;
			Boolean f_tmp_247 = intLib.and(__tmp180,__tmp227);
			Boolean __tmp228 = f_tmp_247;
			Boolean[] __tmp229 = nid.pos;
			Boolean[] __tmp230 = nid.id;
			Boolean[] f_tmp_248 = intLib.mux(id, __tmp230,__tmp228);
			Boolean[] __tmp231 = f_tmp_248;
			id = __tmp231;
			Boolean[] f_tmp_249 = intLib.mux(pos, __tmp229,__tmp228);
			Boolean[] __tmp232 = f_tmp_249;
			pos = __tmp232;
			CircuitOram<Boolean> f_tmp_250 = this.poram;
			CircuitOram<Boolean> __tmp233 = f_tmp_250;
			AVLNode<K, V> f_tmp_251 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV).newObj(__tmp233.conditionalReadAndRemove(id, pos, __tmp228));
			AVLNode<K, V> __tmp234 = f_tmp_251;
			AVLNode<K, V> f_tmp_252 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV).newObj(intLib.mux(tnodes.getBits(), __tmp234.getBits(),__tmp228));
			AVLNode<K, V> __tmp235 = f_tmp_252;
			tnodes = __tmp235;
			boolean f_tmp_253 = false;
			boolean __tmp236 = f_tmp_253;
			IntStack f_tmp_254 = this.IDs;
			IntStack __tmp237 = f_tmp_254;
			Boolean[] f_tmp_255 = __tmp237.stack_op(id, env.inputOfAlice(__tmp236), __tmp228);
			Boolean[] __tmp238 = f_tmp_255;
			AVLId __tmp239 = tnodes.left;
			Boolean[] __tmp240 = tnodes.rDepth;
			AVLId __tmp241 = tnodes.right;
			V __tmp242 = tnodes.value;
			K __tmp243 = tnodes.key;
			Boolean[] __tmp244 = tnodes.lDepth;
			K f_tmp_256 = this.factoryK.newObj(intLib.mux(k.getBits(), __tmp243.getBits(),__tmp228));
			K __tmp245 = f_tmp_256;
			k = __tmp245;
			V f_tmp_257 = this.factoryV.newObj(intLib.mux(v.getBits(), __tmp242.getBits(),__tmp228));
			V __tmp246 = f_tmp_257;
			v = __tmp246;
			Boolean[] f_tmp_258 = intLib.mux(dc, __tmp244,__tmp228);
			Boolean[] __tmp247 = f_tmp_258;
			dc = __tmp247;
			AVLId f_tmp_259 = new AVLId(env, intLib, m).newObj(intLib.mux(c.getBits(), __tmp239.getBits(),__tmp228));
			AVLId __tmp248 = f_tmp_259;
			c = __tmp248;
			AVLId f_tmp_260 = new AVLId(env, intLib, m).newObj(intLib.mux(l.getBits(), __tmp241.getBits(),__tmp228));
			AVLId __tmp249 = f_tmp_260;
			l = __tmp249;
			Boolean[] __tmp250 = l.pos;
			Boolean[] __tmp251 = l.id;
			Boolean[] f_tmp_261 = intLib.mux(id, __tmp251,__tmp228);
			Boolean[] __tmp252 = f_tmp_261;
			id = __tmp252;
			Boolean[] f_tmp_262 = intLib.mux(pos, __tmp250,__tmp228);
			Boolean[] __tmp253 = f_tmp_262;
			pos = __tmp253;
			CircuitOram<Boolean> f_tmp_263 = this.poram;
			CircuitOram<Boolean> __tmp254 = f_tmp_263;
			AVLNode<K, V> f_tmp_264 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV).newObj(__tmp254.conditionalReadAndRemove(id, pos, __tmp228));
			AVLNode<K, V> __tmp255 = f_tmp_264;
			AVLNode<K, V> f_tmp_265 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV).newObj(intLib.mux(p.getBits(), __tmp255.getBits(),__tmp228));
			AVLNode<K, V> __tmp256 = f_tmp_265;
			p = __tmp256;
			boolean f_tmp_266 = false;
			boolean __tmp257 = f_tmp_266;
			IntStack f_tmp_267 = this.IDs;
			IntStack __tmp258 = f_tmp_267;
			Boolean[] f_tmp_268 = __tmp258.stack_op(id, env.inputOfAlice(__tmp257), __tmp228);
			Boolean[] __tmp259 = f_tmp_268;
			AVLId __tmp260 = p.left;
			Boolean[] __tmp261 = p.rDepth;
			AVLId __tmp262 = p.right;
			V __tmp263 = p.value;
			K __tmp264 = p.key;
			Boolean[] __tmp265 = p.lDepth;
			K f_tmp_269 = this.factoryK.newObj(intLib.mux(kp.getBits(), __tmp264.getBits(),__tmp228));
			K __tmp266 = f_tmp_269;
			kp = __tmp266;
			V f_tmp_270 = this.factoryV.newObj(intLib.mux(vp.getBits(), __tmp263.getBits(),__tmp228));
			V __tmp267 = f_tmp_270;
			vp = __tmp267;
			Boolean[] f_tmp_271 = intLib.mux(dap, __tmp265,__tmp228);
			Boolean[] __tmp268 = f_tmp_271;
			dap = __tmp268;
			Boolean[] f_tmp_272 = intLib.mux(dbp, __tmp261,__tmp228);
			Boolean[] __tmp269 = f_tmp_272;
			dbp = __tmp269;
			AVLId f_tmp_273 = new AVLId(env, intLib, m).newObj(intLib.mux(a.getBits(), __tmp260.getBits(),__tmp228));
			AVLId __tmp270 = f_tmp_273;
			a = __tmp270;
			AVLId f_tmp_274 = new AVLId(env, intLib, m).newObj(intLib.mux(b.getBits(), __tmp262.getBits(),__tmp228));
			AVLId __tmp271 = f_tmp_274;
			b = __tmp271;
			int f_tmp_275 = 0;
			int __tmp272 = f_tmp_275;
			boolean f_tmp_276 = true;
			boolean __tmp273 = f_tmp_276;
			IntStack f_tmp_277 = this.IDs;
			IntStack __tmp274 = f_tmp_277;
			Boolean[] f_tmp_278 = __tmp274.stack_op(env.inputOfAlice(Utils.fromInt(__tmp272, m)), env.inputOfAlice(__tmp273), __tmp228);
			Boolean[] __tmp275 = f_tmp_278;
			Boolean[] f_tmp_279 = intLib.mux(id, __tmp275,__tmp228);
			Boolean[] __tmp276 = f_tmp_279;
			id = __tmp276;
			Boolean[] f_tmp_280 = intLib.randBools(m);
			Boolean[] __tmp277 = f_tmp_280;
			Boolean[] f_tmp_281 = intLib.mux(pos, __tmp277,__tmp228);
			Boolean[] __tmp278 = f_tmp_281;
			pos = __tmp278;
			Boolean[] f_tmp_282 = intLib.mux(hpos, pos,__tmp228);
			Boolean[] __tmp279 = f_tmp_282;
			hpos = __tmp279;
			AVLNode<K, V> f_tmp_283 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV);
			f_tmp_283.left = c;
			f_tmp_283.rDepth = dap;
			f_tmp_283.right = a;
			f_tmp_283.value = v;
			f_tmp_283.key = k;
			f_tmp_283.lDepth = dc;
			AVLNode<K, V> __tmp280 = f_tmp_283;
			CircuitOram<Boolean> f_tmp_284 = this.poram;
			CircuitOram<Boolean> __tmp281 = f_tmp_284;
			__tmp281.conditionalPutBack(id, pos, __tmp280.getBits(), __tmp228);
			Boolean[] f_tmp_286 = intLib.mux(dp, dc,__tmp228);
			Boolean[] __tmp283 = f_tmp_286;
			dp = __tmp283;
			Boolean f_tmp_287 = intLib.not(intLib.leq(dap, dp));
			Boolean __tmp284 = f_tmp_287;
			Boolean f_tmp_288 = intLib.and(__tmp228,__tmp284);
			Boolean __tmp285 = f_tmp_288;
			Boolean[] f_tmp_289 = intLib.mux(dp, dap,__tmp285);
			Boolean[] __tmp286 = f_tmp_289;
			dp = __tmp286;
			Boolean f_tmp_290 = intLib.not(__tmp284);
			Boolean __tmp287 = f_tmp_290;
			Boolean f_tmp_291 = intLib.and(__tmp228,__tmp287);
			Boolean __tmp288 = f_tmp_291;
			int f_tmp_292 = 1;
			int __tmp289 = f_tmp_292;
			Boolean[] f_tmp_294 = env.inputOfAlice(Utils.fromInt(__tmp289, (m)+(1)));
			Boolean[] f_tmp_293 = intLib.add(dp,f_tmp_294);
			Boolean[] __tmp290 = f_tmp_293;
			Boolean[] f_tmp_295 = intLib.mux(dp, __tmp290,__tmp228);
			Boolean[] __tmp291 = f_tmp_295;
			dp = __tmp291;
			AVLId f_tmp_296 = new AVLId(env, intLib, m);
			f_tmp_296.pos = pos;
			f_tmp_296.id = id;
			AVLId __tmp292 = f_tmp_296;
			AVLId f_tmp_297 = new AVLId(env, intLib, m).newObj(intLib.mux(next.getBits(), __tmp292.getBits(),__tmp228));
			AVLId __tmp293 = f_tmp_297;
			next = __tmp293;
			int f_tmp_298 = 0;
			int __tmp294 = f_tmp_298;
			boolean f_tmp_299 = true;
			boolean __tmp295 = f_tmp_299;
			IntStack f_tmp_300 = this.IDs;
			IntStack __tmp296 = f_tmp_300;
			Boolean[] f_tmp_301 = __tmp296.stack_op(env.inputOfAlice(Utils.fromInt(__tmp294, m)), env.inputOfAlice(__tmp295), __tmp228);
			Boolean[] __tmp297 = f_tmp_301;
			Boolean[] f_tmp_302 = intLib.mux(id, __tmp297,__tmp228);
			Boolean[] __tmp298 = f_tmp_302;
			id = __tmp298;
			Boolean[] f_tmp_303 = intLib.randBools(m);
			Boolean[] __tmp299 = f_tmp_303;
			Boolean[] f_tmp_304 = intLib.mux(pos, __tmp299,__tmp228);
			Boolean[] __tmp300 = f_tmp_304;
			pos = __tmp300;
			Boolean[] f_tmp_305 = intLib.mux(hpos, pos,__tmp228);
			Boolean[] __tmp301 = f_tmp_305;
			hpos = __tmp301;
			AVLNode<K, V> f_tmp_306 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV);
			f_tmp_306.left = next;
			f_tmp_306.rDepth = dbp;
			f_tmp_306.right = b;
			f_tmp_306.value = vp;
			f_tmp_306.key = kp;
			f_tmp_306.lDepth = dp;
			AVLNode<K, V> __tmp302 = f_tmp_306;
			CircuitOram<Boolean> f_tmp_307 = this.poram;
			CircuitOram<Boolean> __tmp303 = f_tmp_307;
			__tmp303.conditionalPutBack(id, pos, __tmp302.getBits(), __tmp228);
			AVLId f_tmp_309 = new AVLId(env, intLib, m);
			f_tmp_309.id = pos;
			AVLId __tmp305 = f_tmp_309;
			AVLId f_tmp_310 = new AVLId(env, intLib, m).newObj(intLib.mux(nid.getBits(), __tmp305.getBits(),__tmp228));
			AVLId __tmp306 = f_tmp_310;
			nid = __tmp306;
			Boolean[] f_tmp_311 = intLib.mux(nowDepth, dp,__tmp228);
			Boolean[] __tmp307 = f_tmp_311;
			nowDepth = __tmp307;
			Boolean f_tmp_312 = intLib.not(__tmp227);
			Boolean __tmp308 = f_tmp_312;
			Boolean f_tmp_313 = intLib.and(__tmp180,__tmp308);
			Boolean __tmp309 = f_tmp_313;
			Boolean[] f_tmp_314 = intLib.sub(ld,rd);
			Boolean[] __tmp310 = f_tmp_314;
			int f_tmp_315 = 2;
			int __tmp311 = f_tmp_315;
			Boolean[] f_tmp_317 = env.inputOfAlice(Utils.fromInt(__tmp311, (m)+(1)));
			Boolean f_tmp_316 = intLib.geq(__tmp310, f_tmp_317);
			Boolean __tmp312 = f_tmp_316;
			Boolean f_tmp_318 = intLib.and(__tmp309,__tmp312);
			Boolean __tmp313 = f_tmp_318;
			Boolean[] __tmp314 = nid.pos;
			Boolean[] __tmp315 = nid.id;
			Boolean[] f_tmp_319 = intLib.mux(id, __tmp315,__tmp313);
			Boolean[] __tmp316 = f_tmp_319;
			id = __tmp316;
			Boolean[] f_tmp_320 = intLib.mux(pos, __tmp314,__tmp313);
			Boolean[] __tmp317 = f_tmp_320;
			pos = __tmp317;
			CircuitOram<Boolean> f_tmp_321 = this.poram;
			CircuitOram<Boolean> __tmp318 = f_tmp_321;
			AVLNode<K, V> f_tmp_322 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV).newObj(__tmp318.conditionalReadAndRemove(id, pos, __tmp313));
			AVLNode<K, V> __tmp319 = f_tmp_322;
			AVLNode<K, V> f_tmp_323 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV).newObj(intLib.mux(tnodes.getBits(), __tmp319.getBits(),__tmp313));
			AVLNode<K, V> __tmp320 = f_tmp_323;
			tnodes = __tmp320;
			boolean f_tmp_324 = false;
			boolean __tmp321 = f_tmp_324;
			IntStack f_tmp_325 = this.IDs;
			IntStack __tmp322 = f_tmp_325;
			Boolean[] f_tmp_326 = __tmp322.stack_op(id, env.inputOfAlice(__tmp321), __tmp313);
			Boolean[] __tmp323 = f_tmp_326;
			AVLId __tmp324 = tnodes.left;
			Boolean[] __tmp325 = tnodes.rDepth;
			AVLId __tmp326 = tnodes.right;
			V __tmp327 = tnodes.value;
			K __tmp328 = tnodes.key;
			Boolean[] __tmp329 = tnodes.lDepth;
			K f_tmp_327 = this.factoryK.newObj(intLib.mux(k.getBits(), __tmp328.getBits(),__tmp313));
			K __tmp330 = f_tmp_327;
			k = __tmp330;
			V f_tmp_328 = this.factoryV.newObj(intLib.mux(v.getBits(), __tmp327.getBits(),__tmp313));
			V __tmp331 = f_tmp_328;
			v = __tmp331;
			Boolean[] f_tmp_329 = intLib.mux(dc, __tmp325,__tmp313);
			Boolean[] __tmp332 = f_tmp_329;
			dc = __tmp332;
			AVLId f_tmp_330 = new AVLId(env, intLib, m).newObj(intLib.mux(c.getBits(), __tmp326.getBits(),__tmp313));
			AVLId __tmp333 = f_tmp_330;
			c = __tmp333;
			AVLId f_tmp_331 = new AVLId(env, intLib, m).newObj(intLib.mux(l.getBits(), __tmp324.getBits(),__tmp313));
			AVLId __tmp334 = f_tmp_331;
			l = __tmp334;
			Boolean[] __tmp335 = l.pos;
			Boolean[] __tmp336 = l.id;
			Boolean[] f_tmp_332 = intLib.mux(id, __tmp336,__tmp313);
			Boolean[] __tmp337 = f_tmp_332;
			id = __tmp337;
			Boolean[] f_tmp_333 = intLib.mux(pos, __tmp335,__tmp313);
			Boolean[] __tmp338 = f_tmp_333;
			pos = __tmp338;
			CircuitOram<Boolean> f_tmp_334 = this.poram;
			CircuitOram<Boolean> __tmp339 = f_tmp_334;
			AVLNode<K, V> f_tmp_335 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV).newObj(__tmp339.conditionalReadAndRemove(id, pos, __tmp313));
			AVLNode<K, V> __tmp340 = f_tmp_335;
			AVLNode<K, V> f_tmp_336 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV).newObj(intLib.mux(p.getBits(), __tmp340.getBits(),__tmp313));
			AVLNode<K, V> __tmp341 = f_tmp_336;
			p = __tmp341;
			boolean f_tmp_337 = false;
			boolean __tmp342 = f_tmp_337;
			IntStack f_tmp_338 = this.IDs;
			IntStack __tmp343 = f_tmp_338;
			Boolean[] f_tmp_339 = __tmp343.stack_op(id, env.inputOfAlice(__tmp342), __tmp313);
			Boolean[] __tmp344 = f_tmp_339;
			AVLId __tmp345 = p.left;
			Boolean[] __tmp346 = p.rDepth;
			AVLId __tmp347 = p.right;
			V __tmp348 = p.value;
			K __tmp349 = p.key;
			Boolean[] __tmp350 = p.lDepth;
			K f_tmp_340 = this.factoryK.newObj(intLib.mux(kp.getBits(), __tmp349.getBits(),__tmp313));
			K __tmp351 = f_tmp_340;
			kp = __tmp351;
			V f_tmp_341 = this.factoryV.newObj(intLib.mux(vp.getBits(), __tmp348.getBits(),__tmp313));
			V __tmp352 = f_tmp_341;
			vp = __tmp352;
			Boolean[] f_tmp_342 = intLib.mux(dap, __tmp350,__tmp313);
			Boolean[] __tmp353 = f_tmp_342;
			dap = __tmp353;
			Boolean[] f_tmp_343 = intLib.mux(dbp, __tmp346,__tmp313);
			Boolean[] __tmp354 = f_tmp_343;
			dbp = __tmp354;
			AVLId f_tmp_344 = new AVLId(env, intLib, m).newObj(intLib.mux(a.getBits(), __tmp345.getBits(),__tmp313));
			AVLId __tmp355 = f_tmp_344;
			a = __tmp355;
			AVLId f_tmp_345 = new AVLId(env, intLib, m).newObj(intLib.mux(b.getBits(), __tmp347.getBits(),__tmp313));
			AVLId __tmp356 = f_tmp_345;
			b = __tmp356;
			int f_tmp_346 = 0;
			int __tmp357 = f_tmp_346;
			boolean f_tmp_347 = true;
			boolean __tmp358 = f_tmp_347;
			IntStack f_tmp_348 = this.IDs;
			IntStack __tmp359 = f_tmp_348;
			Boolean[] f_tmp_349 = __tmp359.stack_op(env.inputOfAlice(Utils.fromInt(__tmp357, m)), env.inputOfAlice(__tmp358), __tmp313);
			Boolean[] __tmp360 = f_tmp_349;
			Boolean[] f_tmp_350 = intLib.mux(id, __tmp360,__tmp313);
			Boolean[] __tmp361 = f_tmp_350;
			id = __tmp361;
			Boolean[] f_tmp_351 = intLib.randBools(m);
			Boolean[] __tmp362 = f_tmp_351;
			Boolean[] f_tmp_352 = intLib.mux(pos, __tmp362,__tmp313);
			Boolean[] __tmp363 = f_tmp_352;
			pos = __tmp363;
			Boolean[] f_tmp_353 = intLib.mux(hpos, pos,__tmp313);
			Boolean[] __tmp364 = f_tmp_353;
			hpos = __tmp364;
			AVLNode<K, V> f_tmp_354 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV);
			f_tmp_354.left = b;
			f_tmp_354.rDepth = dc;
			f_tmp_354.right = c;
			f_tmp_354.value = v;
			f_tmp_354.key = k;
			f_tmp_354.lDepth = dbp;
			AVLNode<K, V> __tmp365 = f_tmp_354;
			CircuitOram<Boolean> f_tmp_355 = this.poram;
			CircuitOram<Boolean> __tmp366 = f_tmp_355;
			__tmp366.conditionalPutBack(id, pos, __tmp365.getBits(), __tmp313);
			Boolean[] f_tmp_357 = intLib.mux(dp, dc,__tmp313);
			Boolean[] __tmp368 = f_tmp_357;
			dp = __tmp368;
			Boolean f_tmp_358 = intLib.not(intLib.leq(dbp, dp));
			Boolean __tmp369 = f_tmp_358;
			Boolean f_tmp_359 = intLib.and(__tmp313,__tmp369);
			Boolean __tmp370 = f_tmp_359;
			Boolean[] f_tmp_360 = intLib.mux(dp, dbp,__tmp370);
			Boolean[] __tmp371 = f_tmp_360;
			dp = __tmp371;
			Boolean f_tmp_361 = intLib.not(__tmp369);
			Boolean __tmp372 = f_tmp_361;
			Boolean f_tmp_362 = intLib.and(__tmp313,__tmp372);
			Boolean __tmp373 = f_tmp_362;
			int f_tmp_363 = 1;
			int __tmp374 = f_tmp_363;
			Boolean[] f_tmp_365 = env.inputOfAlice(Utils.fromInt(__tmp374, (m)+(1)));
			Boolean[] f_tmp_364 = intLib.add(dp,f_tmp_365);
			Boolean[] __tmp375 = f_tmp_364;
			Boolean[] f_tmp_366 = intLib.mux(dp, __tmp375,__tmp313);
			Boolean[] __tmp376 = f_tmp_366;
			dp = __tmp376;
			AVLId f_tmp_367 = new AVLId(env, intLib, m);
			f_tmp_367.pos = pos;
			f_tmp_367.id = id;
			AVLId __tmp377 = f_tmp_367;
			AVLId f_tmp_368 = new AVLId(env, intLib, m).newObj(intLib.mux(next.getBits(), __tmp377.getBits(),__tmp313));
			AVLId __tmp378 = f_tmp_368;
			next = __tmp378;
			int f_tmp_369 = 0;
			int __tmp379 = f_tmp_369;
			boolean f_tmp_370 = true;
			boolean __tmp380 = f_tmp_370;
			IntStack f_tmp_371 = this.IDs;
			IntStack __tmp381 = f_tmp_371;
			Boolean[] f_tmp_372 = __tmp381.stack_op(env.inputOfAlice(Utils.fromInt(__tmp379, m)), env.inputOfAlice(__tmp380), __tmp313);
			Boolean[] __tmp382 = f_tmp_372;
			Boolean[] f_tmp_373 = intLib.mux(id, __tmp382,__tmp313);
			Boolean[] __tmp383 = f_tmp_373;
			id = __tmp383;
			Boolean[] f_tmp_374 = intLib.randBools(m);
			Boolean[] __tmp384 = f_tmp_374;
			Boolean[] f_tmp_375 = intLib.mux(pos, __tmp384,__tmp313);
			Boolean[] __tmp385 = f_tmp_375;
			pos = __tmp385;
			Boolean[] f_tmp_376 = intLib.mux(hpos, pos,__tmp313);
			Boolean[] __tmp386 = f_tmp_376;
			hpos = __tmp386;
			AVLNode<K, V> f_tmp_377 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV);
			f_tmp_377.left = a;
			f_tmp_377.rDepth = dp;
			f_tmp_377.right = next;
			f_tmp_377.value = vp;
			f_tmp_377.key = kp;
			f_tmp_377.lDepth = dap;
			AVLNode<K, V> __tmp387 = f_tmp_377;
			CircuitOram<Boolean> f_tmp_378 = this.poram;
			CircuitOram<Boolean> __tmp388 = f_tmp_378;
			__tmp388.conditionalPutBack(id, pos, __tmp387.getBits(), __tmp313);
			AVLId f_tmp_380 = new AVLId(env, intLib, m);
			f_tmp_380.pos = pos;
			f_tmp_380.id = id;
			AVLId __tmp390 = f_tmp_380;
			AVLId f_tmp_381 = new AVLId(env, intLib, m).newObj(intLib.mux(nid.getBits(), __tmp390.getBits(),__tmp313));
			AVLId __tmp391 = f_tmp_381;
			nid = __tmp391;
			Boolean[] f_tmp_382 = intLib.mux(nowDepth, dp,__tmp313);
			Boolean[] __tmp392 = f_tmp_382;
			nowDepth = __tmp392;
			Boolean f_tmp_383 = intLib.not(__tmp312);
			Boolean __tmp393 = f_tmp_383;
			Boolean f_tmp_384 = intLib.and(__tmp309,__tmp393);
			Boolean __tmp394 = f_tmp_384;
			Boolean f_tmp_385 = intLib.not(__tmp180);
			Boolean __tmp395 = f_tmp_385;
			int f_tmp_386 = 1;
			int __tmp396 = f_tmp_386;
			int f_tmp_387 = i - __tmp396;
			int __tmp397 = f_tmp_387;
			i = __tmp397;
			int f_tmp_388 = 0;
			__tmp176 = f_tmp_388;
			boolean f_tmp_389 = i >= __tmp176;
			__tmp177 = f_tmp_389;
		}
		this.root = nid;

	}
	public V search(K key, V value, FUNC_1_INTsecure_T1_T1<K> cmp) throws Exception {
		AVLNode<K, V> tnodes = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV);
		AVLNode<K, V> p = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV);
		AVLId now = new AVLId(env, intLib, m);
		AVLId go = new AVLId(env, intLib, m);
		AVLId a = new AVLId(env, intLib, m);
		AVLId b = new AVLId(env, intLib, m);
		AVLId c = new AVLId(env, intLib, m);
		AVLId[] left = (AVLId[])Array.newInstance((Class<AVLId>)(new AVLId(env, intLib, m).getClass()), ((3)*(m))/(2));
		for(int _j_=0; _j_<((3)*(m))/(2); ++_j_) {
			left[_j_] = new AVLId(env, intLib, m);
		}
		K[] keys = (K[])Array.newInstance((Class<K>)factoryK.getClass(), ((3)*(m))/(2));
		for(int _j_=0; _j_<((3)*(m))/(2); ++_j_) {
			keys[_j_] = factoryK.newObj(null);
		}
		V[] values = (V[])Array.newInstance((Class<V>)factoryV.getClass(), ((3)*(m))/(2));
		for(int _j_=0; _j_<((3)*(m))/(2); ++_j_) {
			values[_j_] = factoryV.newObj(null);
		}
		Boolean[][] depth = new Boolean[((3)*(m))/(2)][];
		for(int _j_=0; _j_<((3)*(m))/(2); ++_j_) {
			depth[_j_] = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		}
		Boolean[][] ids = new Boolean[((3)*(m))/(2)][];
		for(int _j_=0; _j_<((3)*(m))/(2); ++_j_) {
			ids[_j_] = env.inputOfAlice(Utils.fromInt(0, 2));
		}
		Boolean[][] cres = new Boolean[((3)*(m))/(2)][];
		for(int _j_=0; _j_<((3)*(m))/(2); ++_j_) {
			cres[_j_] = env.inputOfAlice(Utils.fromInt(0, 2));
		}
		Boolean[] ind = env.inputOfAlice(Utils.fromInt(0, 2));
		Boolean[] id = env.inputOfAlice(Utils.fromInt(0, m));
		Boolean[] pos = intLib.randBools(m);
		K k = factoryK.newObj(null);
		K kp = factoryK.newObj(null);
		V v = factoryV.newObj(null);
		V vp = factoryV.newObj(null);
		Boolean[] dl = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] dr = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId lf = new AVLId(env, intLib, m);
		AVLId rf = new AVLId(env, intLib, m);
		V ret = factoryV.newObj(null);
		int i = 0;
		int pre = 0;
		Boolean[] nowDepth = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] ld = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		Boolean[] rd = env.inputOfAlice(Utils.fromInt(0, (m)+(1)));
		AVLId nid = new AVLId(env, intLib, m);
		AVLId next = new AVLId(env, intLib, m);
		AVLId ll = new AVLId(env, intLib, m);
		AVLId rr = new AVLId(env, intLib, m);
		Boolean[] hpos = env.inputOfAlice(Utils.fromInt(0, m));
		AVLId f_tmp_390 = this.root;
		AVLId __tmp398 = f_tmp_390;
		now = __tmp398;
		int f_tmp_391 = 0;
		int __tmp399 = f_tmp_391;
		ind = env.inputOfAlice(Utils.fromInt(__tmp399, 2));
		int f_tmp_392 = 0;
		int __tmp400 = f_tmp_392;
		i = __tmp400;
		int f_tmp_393 = 3;
		int __tmp401 = f_tmp_393;
		int f_tmp_394 = __tmp401 * m;
		int __tmp402 = f_tmp_394;
		int f_tmp_395 = 2;
		int __tmp403 = f_tmp_395;
		int f_tmp_396 = __tmp402 / __tmp403;
		int __tmp404 = f_tmp_396;
		boolean f_tmp_397 = i < __tmp404;
		boolean __tmp405 = f_tmp_397;
		while(__tmp405) {
			ids[i]=ind;
			int f_tmp_398 = 1;
			int __tmp406 = f_tmp_398;
			int f_tmp_399 = i - __tmp406;
			int __tmp407 = f_tmp_399;
			pre = __tmp407;
			int f_tmp_400 = 0;
			int __tmp408 = f_tmp_400;
			boolean f_tmp_401 = i == __tmp408;
			boolean __tmp409 = f_tmp_401;
			if(__tmp409) {
				int f_tmp_402 = 0;
				int __tmp410 = f_tmp_402;
				pre = __tmp410;
			} else {
			}
			int f_tmp_403 = 0;
			int __tmp411 = f_tmp_403;
			Boolean[] f_tmp_405 = env.inputOfAlice(Utils.fromInt(__tmp411, 2));
			Boolean f_tmp_404 = intLib.eq(ind, f_tmp_405);
			Boolean __tmp412 = f_tmp_404;
			Boolean[] __tmp413 = now.pos;
			Boolean[] __tmp414 = now.id;
			Boolean[] f_tmp_406 = intLib.mux(id, __tmp414,__tmp412);
			Boolean[] __tmp415 = f_tmp_406;
			id = __tmp415;
			Boolean[] f_tmp_407 = intLib.mux(pos, __tmp413,__tmp412);
			Boolean[] __tmp416 = f_tmp_407;
			pos = __tmp416;
			CircuitOram<Boolean> f_tmp_408 = this.poram;
			CircuitOram<Boolean> __tmp417 = f_tmp_408;
			AVLNode<K, V> f_tmp_409 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV).newObj(__tmp417.conditionalReadAndRemove(id, pos, __tmp412));
			AVLNode<K, V> __tmp418 = f_tmp_409;
			AVLNode<K, V> f_tmp_410 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV).newObj(intLib.mux(tnodes.getBits(), __tmp418.getBits(),__tmp412));
			AVLNode<K, V> __tmp419 = f_tmp_410;
			tnodes = __tmp419;
			boolean f_tmp_411 = false;
			boolean __tmp420 = f_tmp_411;
			IntStack f_tmp_412 = this.IDs;
			IntStack __tmp421 = f_tmp_412;
			Boolean[] f_tmp_413 = __tmp421.stack_op(id, env.inputOfAlice(__tmp420), __tmp412);
			Boolean[] __tmp422 = f_tmp_413;
			AVLId __tmp423 = tnodes.left;
			Boolean[] __tmp424 = tnodes.rDepth;
			AVLId __tmp425 = tnodes.right;
			V __tmp426 = tnodes.value;
			K __tmp427 = tnodes.key;
			Boolean[] __tmp428 = tnodes.lDepth;
			K f_tmp_414 = keys[i];
			K __tmp429 = f_tmp_414;
			K f_tmp_415 = this.factoryK.newObj(intLib.mux(__tmp429.getBits(), __tmp427.getBits(),__tmp412));
			K __tmp430 = f_tmp_415;
			keys[i]=__tmp430;
			V f_tmp_416 = values[i];
			V __tmp431 = f_tmp_416;
			V f_tmp_417 = this.factoryV.newObj(intLib.mux(__tmp431.getBits(), __tmp426.getBits(),__tmp412));
			V __tmp432 = f_tmp_417;
			values[i]=__tmp432;
			Boolean[] f_tmp_418 = intLib.mux(ld, __tmp428,__tmp412);
			Boolean[] __tmp433 = f_tmp_418;
			ld = __tmp433;
			Boolean[] f_tmp_419 = intLib.mux(rd, __tmp424,__tmp412);
			Boolean[] __tmp434 = f_tmp_419;
			rd = __tmp434;
			AVLId f_tmp_420 = new AVLId(env, intLib, m).newObj(intLib.mux(lf.getBits(), __tmp423.getBits(),__tmp412));
			AVLId __tmp435 = f_tmp_420;
			lf = __tmp435;
			AVLId f_tmp_421 = new AVLId(env, intLib, m).newObj(intLib.mux(rf.getBits(), __tmp425.getBits(),__tmp412));
			AVLId __tmp436 = f_tmp_421;
			rf = __tmp436;
			Boolean f_tmp_422 = intLib.not(__tmp412);
			Boolean __tmp437 = f_tmp_422;
			int f_tmp_423 = 0;
			int __tmp438 = f_tmp_423;
			int f_tmp_424 = 1;
			int __tmp439 = f_tmp_424;
			int f_tmp_425 = __tmp438 - __tmp439;
			int __tmp440 = f_tmp_425;
			Boolean[] f_tmp_426 = depth[i];
			Boolean[] __tmp441 = f_tmp_426;
			Boolean[] f_tmp_428 = env.inputOfAlice(Utils.fromInt(__tmp440, (m)+(1)));
			Boolean[] f_tmp_427 = intLib.mux(__tmp441, f_tmp_428,__tmp437);
			Boolean[] __tmp442 = f_tmp_427;
			depth[i]=__tmp442;
			K f_tmp_429 = keys[pre];
			K __tmp443 = f_tmp_429;
			K f_tmp_430 = keys[i];
			K __tmp444 = f_tmp_430;
			K f_tmp_431 = this.factoryK.newObj(intLib.mux(__tmp444.getBits(), __tmp443.getBits(),__tmp437));
			K __tmp445 = f_tmp_431;
			keys[i]=__tmp445;
			K f_tmp_432 = keys[i];
			K __tmp446 = f_tmp_432;
			Boolean[] f_tmp_433 = cmp.calc(__tmp446, key);
			Boolean[] __tmp447 = f_tmp_433;
			cres[i]=__tmp447;
			int f_tmp_434 = 0;
			int __tmp448 = f_tmp_434;
			Boolean[] f_tmp_436 = env.inputOfAlice(Utils.fromInt(__tmp448, 2));
			Boolean f_tmp_435 = intLib.eq(ind, f_tmp_436);
			Boolean __tmp449 = f_tmp_435;
			Boolean[] f_tmp_437 = cres[i];
			Boolean[] __tmp450 = f_tmp_437;
			int f_tmp_438 = 0;
			int __tmp451 = f_tmp_438;
			Boolean[] f_tmp_440 = env.inputOfAlice(Utils.fromInt(__tmp451, 2));
			Boolean f_tmp_439 = intLib.not(intLib.leq(__tmp450, f_tmp_440));
			Boolean __tmp452 = f_tmp_439;
			Boolean f_tmp_441 = intLib.and(__tmp449,__tmp452);
			Boolean __tmp453 = f_tmp_441;
			Boolean[] f_tmp_442 = depth[i];
			Boolean[] __tmp454 = f_tmp_442;
			Boolean[] f_tmp_443 = intLib.mux(__tmp454, dr,__tmp453);
			Boolean[] __tmp455 = f_tmp_443;
			depth[i]=__tmp455;
			AVLId f_tmp_444 = new AVLId(env, intLib, m).newObj(intLib.mux(go.getBits(), lf.getBits(),__tmp453));
			AVLId __tmp456 = f_tmp_444;
			go = __tmp456;
			AVLId f_tmp_445 = left[i];
			AVLId __tmp457 = f_tmp_445;
			AVLId f_tmp_446 = new AVLId(env, intLib, m).newObj(intLib.mux(__tmp457.getBits(), rf.getBits(),__tmp453));
			AVLId __tmp458 = f_tmp_446;
			left[i]=__tmp458;
			Boolean f_tmp_447 = intLib.not(__tmp452);
			Boolean __tmp459 = f_tmp_447;
			Boolean f_tmp_448 = intLib.and(__tmp449,__tmp459);
			Boolean __tmp460 = f_tmp_448;
			Boolean[] f_tmp_449 = depth[i];
			Boolean[] __tmp461 = f_tmp_449;
			Boolean[] f_tmp_450 = intLib.mux(__tmp461, dl,__tmp460);
			Boolean[] __tmp462 = f_tmp_450;
			depth[i]=__tmp462;
			AVLId f_tmp_451 = new AVLId(env, intLib, m).newObj(intLib.mux(go.getBits(), rf.getBits(),__tmp460));
			AVLId __tmp463 = f_tmp_451;
			go = __tmp463;
			AVLId f_tmp_452 = left[i];
			AVLId __tmp464 = f_tmp_452;
			AVLId f_tmp_453 = new AVLId(env, intLib, m).newObj(intLib.mux(__tmp464.getBits(), lf.getBits(),__tmp460));
			AVLId __tmp465 = f_tmp_453;
			left[i]=__tmp465;
			Boolean[] f_tmp_454 = cres[i];
			Boolean[] __tmp466 = f_tmp_454;
			int f_tmp_455 = 0;
			int __tmp467 = f_tmp_455;
			Boolean[] f_tmp_457 = env.inputOfAlice(Utils.fromInt(__tmp467, 2));
			Boolean f_tmp_456 = intLib.eq(__tmp466, f_tmp_457);
			Boolean __tmp468 = f_tmp_456;
			Boolean f_tmp_458 = intLib.and(__tmp449,__tmp468);
			Boolean __tmp469 = f_tmp_458;
			V f_tmp_459 = this.factoryV.newObj(intLib.mux(ret.getBits(), value.getBits(),__tmp469));
			V __tmp470 = f_tmp_459;
			ret = __tmp470;
			int f_tmp_460 = 1;
			int __tmp471 = f_tmp_460;
			Boolean[] f_tmp_462 = env.inputOfAlice(Utils.fromInt(__tmp471, 2));
			Boolean[] f_tmp_461 = intLib.mux(ind, f_tmp_462,__tmp469);
			Boolean[] __tmp472 = f_tmp_461;
			ind = __tmp472;
			Boolean f_tmp_463 = intLib.not(__tmp468);
			Boolean __tmp473 = f_tmp_463;
			Boolean f_tmp_464 = intLib.and(__tmp449,__tmp473);
			Boolean __tmp474 = f_tmp_464;
			AVLId f_tmp_465 = new AVLId(env, intLib, m).newObj(intLib.mux(now.getBits(), go.getBits(),__tmp449));
			AVLId __tmp475 = f_tmp_465;
			now = __tmp475;
			Boolean[] f_tmp_466 = now.id;
			Boolean[] __tmp476 = f_tmp_466;
			int f_tmp_467 = 0;
			int __tmp477 = f_tmp_467;
			Boolean[] f_tmp_469 = env.inputOfAlice(Utils.fromInt(__tmp477, m));
			Boolean f_tmp_468 = intLib.eq(__tmp476, f_tmp_469);
			Boolean __tmp478 = f_tmp_468;
			Boolean f_tmp_470 = intLib.and(__tmp449,__tmp478);
			Boolean __tmp479 = f_tmp_470;
			int f_tmp_471 = 1;
			int __tmp480 = f_tmp_471;
			Boolean[] f_tmp_473 = env.inputOfAlice(Utils.fromInt(__tmp480, 2));
			Boolean[] f_tmp_472 = intLib.mux(ind, f_tmp_473,__tmp479);
			Boolean[] __tmp481 = f_tmp_472;
			ind = __tmp481;
			Boolean f_tmp_474 = intLib.not(__tmp478);
			Boolean __tmp482 = f_tmp_474;
			Boolean f_tmp_475 = intLib.and(__tmp449,__tmp482);
			Boolean __tmp483 = f_tmp_475;
			Boolean f_tmp_476 = intLib.not(__tmp449);
			Boolean __tmp484 = f_tmp_476;
			int f_tmp_477 = 1;
			int __tmp485 = f_tmp_477;
			int f_tmp_478 = i + __tmp485;
			int __tmp486 = f_tmp_478;
			i = __tmp486;
			int f_tmp_479 = 3;
			__tmp401 = f_tmp_479;
			int f_tmp_480 = __tmp401 * m;
			__tmp402 = f_tmp_480;
			int f_tmp_481 = 2;
			__tmp403 = f_tmp_481;
			int f_tmp_482 = __tmp402 / __tmp403;
			__tmp404 = f_tmp_482;
			boolean f_tmp_483 = i < __tmp404;
			__tmp405 = f_tmp_483;
		}
		int f_tmp_484 = 0;
		int __tmp487 = f_tmp_484;
		int f_tmp_485 = 1;
		int __tmp488 = f_tmp_485;
		int f_tmp_486 = __tmp487 - __tmp488;
		int __tmp489 = f_tmp_486;
		nowDepth = env.inputOfAlice(Utils.fromInt(__tmp489, (m)+(1)));
		nid = now;
		int f_tmp_487 = 3;
		int __tmp490 = f_tmp_487;
		int f_tmp_488 = __tmp490 * m;
		int __tmp491 = f_tmp_488;
		int f_tmp_489 = 2;
		int __tmp492 = f_tmp_489;
		int f_tmp_490 = __tmp491 / __tmp492;
		int __tmp493 = f_tmp_490;
		int f_tmp_491 = 1;
		int __tmp494 = f_tmp_491;
		int f_tmp_492 = __tmp493 - __tmp494;
		int __tmp495 = f_tmp_492;
		i = __tmp495;
		int f_tmp_493 = 0;
		int __tmp496 = f_tmp_493;
		boolean f_tmp_494 = i >= __tmp496;
		boolean __tmp497 = f_tmp_494;
		while(__tmp497) {
			Boolean[] f_tmp_495 = ids[i];
			Boolean[] __tmp498 = f_tmp_495;
			int f_tmp_496 = 0;
			int __tmp499 = f_tmp_496;
			Boolean[] f_tmp_498 = env.inputOfAlice(Utils.fromInt(__tmp499, 2));
			Boolean f_tmp_497 = intLib.eq(__tmp498, f_tmp_498);
			Boolean __tmp500 = f_tmp_497;
			int f_tmp_499 = 0;
			int __tmp501 = f_tmp_499;
			boolean f_tmp_500 = true;
			boolean __tmp502 = f_tmp_500;
			IntStack f_tmp_501 = this.IDs;
			IntStack __tmp503 = f_tmp_501;
			Boolean[] f_tmp_502 = __tmp503.stack_op(env.inputOfAlice(Utils.fromInt(__tmp501, m)), env.inputOfAlice(__tmp502), __tmp500);
			Boolean[] __tmp504 = f_tmp_502;
			Boolean[] f_tmp_503 = intLib.mux(id, __tmp504,__tmp500);
			Boolean[] __tmp505 = f_tmp_503;
			id = __tmp505;
			Boolean[] f_tmp_504 = intLib.randBools(m);
			Boolean[] __tmp506 = f_tmp_504;
			Boolean[] f_tmp_505 = intLib.mux(pos, __tmp506,__tmp500);
			Boolean[] __tmp507 = f_tmp_505;
			pos = __tmp507;
			Boolean[] f_tmp_506 = intLib.mux(hpos, pos,__tmp500);
			Boolean[] __tmp508 = f_tmp_506;
			hpos = __tmp508;
			AVLId f_tmp_507 = new AVLId(env, intLib, m);
			f_tmp_507.pos = pos;
			f_tmp_507.id = id;
			AVLId __tmp509 = f_tmp_507;
			AVLId f_tmp_508 = new AVLId(env, intLib, m).newObj(intLib.mux(next.getBits(), __tmp509.getBits(),__tmp500));
			AVLId __tmp510 = f_tmp_508;
			next = __tmp510;
			Boolean[] f_tmp_509 = cres[i];
			Boolean[] __tmp511 = f_tmp_509;
			int f_tmp_510 = 0;
			int __tmp512 = f_tmp_510;
			Boolean[] f_tmp_512 = env.inputOfAlice(Utils.fromInt(__tmp512, 2));
			Boolean f_tmp_511 = intLib.geq(__tmp511, f_tmp_512);
			Boolean __tmp513 = f_tmp_511;
			Boolean f_tmp_513 = intLib.and(__tmp500,__tmp513);
			Boolean __tmp514 = f_tmp_513;
			Boolean[] f_tmp_514 = intLib.mux(ld, nowDepth,__tmp514);
			Boolean[] __tmp515 = f_tmp_514;
			ld = __tmp515;
			Boolean[] f_tmp_515 = depth[i];
			Boolean[] __tmp516 = f_tmp_515;
			Boolean[] f_tmp_516 = intLib.mux(rd, __tmp516,__tmp514);
			Boolean[] __tmp517 = f_tmp_516;
			rd = __tmp517;
			AVLId f_tmp_517 = new AVLId(env, intLib, m).newObj(intLib.mux(ll.getBits(), nid.getBits(),__tmp514));
			AVLId __tmp518 = f_tmp_517;
			ll = __tmp518;
			AVLId f_tmp_518 = left[i];
			AVLId __tmp519 = f_tmp_518;
			AVLId f_tmp_519 = new AVLId(env, intLib, m).newObj(intLib.mux(rr.getBits(), __tmp519.getBits(),__tmp514));
			AVLId __tmp520 = f_tmp_519;
			rr = __tmp520;
			Boolean f_tmp_520 = intLib.not(__tmp513);
			Boolean __tmp521 = f_tmp_520;
			Boolean f_tmp_521 = intLib.and(__tmp500,__tmp521);
			Boolean __tmp522 = f_tmp_521;
			Boolean[] f_tmp_522 = depth[i];
			Boolean[] __tmp523 = f_tmp_522;
			Boolean[] f_tmp_523 = intLib.mux(ld, __tmp523,__tmp522);
			Boolean[] __tmp524 = f_tmp_523;
			ld = __tmp524;
			Boolean[] f_tmp_524 = intLib.mux(rd, nowDepth,__tmp522);
			Boolean[] __tmp525 = f_tmp_524;
			rd = __tmp525;
			AVLId f_tmp_525 = left[i];
			AVLId __tmp526 = f_tmp_525;
			AVLId f_tmp_526 = new AVLId(env, intLib, m).newObj(intLib.mux(ll.getBits(), __tmp526.getBits(),__tmp522));
			AVLId __tmp527 = f_tmp_526;
			ll = __tmp527;
			AVLId f_tmp_527 = new AVLId(env, intLib, m).newObj(intLib.mux(rr.getBits(), nid.getBits(),__tmp522));
			AVLId __tmp528 = f_tmp_527;
			rr = __tmp528;
			AVLId f_tmp_528 = new AVLId(env, intLib, m).newObj(intLib.mux(nid.getBits(), next.getBits(),__tmp500));
			AVLId __tmp529 = f_tmp_528;
			nid = __tmp529;
			V f_tmp_529 = values[i];
			V __tmp530 = f_tmp_529;
			K f_tmp_530 = keys[i];
			K __tmp531 = f_tmp_530;
			AVLNode<K, V> f_tmp_531 = new AVLNode<K, V>(env, intLib, m, factoryK, factoryV);
			f_tmp_531.left = ll;
			f_tmp_531.rDepth = rd;
			f_tmp_531.right = rr;
			f_tmp_531.value = __tmp530;
			f_tmp_531.key = __tmp531;
			f_tmp_531.lDepth = ld;
			AVLNode<K, V> __tmp532 = f_tmp_531;
			CircuitOram<Boolean> f_tmp_532 = this.poram;
			CircuitOram<Boolean> __tmp533 = f_tmp_532;
			__tmp533.conditionalPutBack(id, pos, __tmp532.getBits(), __tmp500);
			Boolean[] f_tmp_534 = depth[i];
			Boolean[] __tmp535 = f_tmp_534;
			Boolean f_tmp_535 = intLib.not(intLib.leq(__tmp535, nowDepth));
			Boolean __tmp536 = f_tmp_535;
			Boolean f_tmp_536 = intLib.and(__tmp500,__tmp536);
			Boolean __tmp537 = f_tmp_536;
			Boolean[] f_tmp_537 = depth[i];
			Boolean[] __tmp538 = f_tmp_537;
			Boolean[] f_tmp_538 = intLib.mux(nowDepth, __tmp538,__tmp537);
			Boolean[] __tmp539 = f_tmp_538;
			nowDepth = __tmp539;
			Boolean f_tmp_539 = intLib.not(__tmp536);
			Boolean __tmp540 = f_tmp_539;
			Boolean f_tmp_540 = intLib.and(__tmp500,__tmp540);
			Boolean __tmp541 = f_tmp_540;
			int f_tmp_541 = 1;
			int __tmp542 = f_tmp_541;
			Boolean[] f_tmp_543 = env.inputOfAlice(Utils.fromInt(__tmp542, (m)+(1)));
			Boolean[] f_tmp_542 = intLib.add(nowDepth,f_tmp_543);
			Boolean[] __tmp543 = f_tmp_542;
			Boolean[] f_tmp_544 = intLib.mux(nowDepth, __tmp543,__tmp500);
			Boolean[] __tmp544 = f_tmp_544;
			nowDepth = __tmp544;
			Boolean f_tmp_545 = intLib.not(__tmp500);
			Boolean __tmp545 = f_tmp_545;
			int f_tmp_546 = 1;
			int __tmp546 = f_tmp_546;
			int f_tmp_547 = i - __tmp546;
			int __tmp547 = f_tmp_547;
			i = __tmp547;
			int f_tmp_548 = 0;
			__tmp496 = f_tmp_548;
			boolean f_tmp_549 = i >= __tmp496;
			__tmp497 = f_tmp_549;
		}
		this.root = nid;
		return ret;
	}
}
