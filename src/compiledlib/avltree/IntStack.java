package compiledlib.avltree;
import java.security.SecureRandom;
import oram.SecureArray;
import oram.CircuitOram;
import flexsc.Mode;
import flexsc.Party;
import flexsc.CompEnv;
import java.util.BitSet;
import circuits.arithmetic.IntegerLib;
import util.Utils;
import gc.regular.GCEva;
import gc.regular.GCGen;
import gc.GCSignal;
import java.util.Arrays;
import java.util.Random;
import flexsc.IWritable;
import flexsc.Comparator;
import java.lang.reflect.Array;
public class IntStack {
	public CircuitOram<Boolean> poram;
	public Boolean[] size;
	public Boolean[] root;

	public CompEnv<Boolean> env;
	public IntegerLib<Boolean> intLib;
	private int m;

	public IntStack(CompEnv<Boolean> env, IntegerLib<Boolean> intLib, int m, CircuitOram<Boolean> poram) throws Exception {
		this.env = env;
		this.intLib = intLib;
		this.m = m;
		this.poram = poram;
		this.size = env.inputOfAlice(Utils.fromInt(0, m));
		this.root = intLib.randBools(m);
	}

	public Boolean[] stack_op(Boolean[] operand, Boolean op, Boolean dum) throws Exception {
		Boolean[] ret = env.inputOfAlice(Utils.fromInt(0, m));
		IntStackNode r = new IntStackNode(env, intLib, m);
		IntStackNode node = new IntStackNode(env, intLib, m);
		boolean f_tmp_0 = true;
		boolean __tmp0 = f_tmp_0;
		Boolean f_tmp_2 = env.inputOfAlice(__tmp0);
		Boolean f_tmp_1 = intLib.eq(op, f_tmp_2);
		Boolean __tmp1 = f_tmp_1;
		boolean f_tmp_3 = false;
		boolean __tmp2 = f_tmp_3;
		Boolean f_tmp_5 = env.inputOfAlice(__tmp2);
		Boolean f_tmp_4 = intLib.eq(dum, f_tmp_5);
		Boolean __tmp3 = f_tmp_4;
		Boolean f_tmp_6 = intLib.and(__tmp1,__tmp3);
		Boolean __tmp4 = f_tmp_6;
		Boolean[] f_tmp_7 = this.size;
		Boolean[] __tmp5 = f_tmp_7;
		Boolean[] f_tmp_8 = this.root;
		Boolean[] __tmp6 = f_tmp_8;
		CircuitOram<Boolean> f_tmp_9 = this.poram;
		CircuitOram<Boolean> __tmp7 = f_tmp_9;
		IntStackNode f_tmp_10 = new IntStackNode(env, intLib, m).newObj(__tmp7.conditionalReadAndRemove(__tmp5, __tmp6, __tmp4));
		IntStackNode __tmp8 = f_tmp_10;
		IntStackNode f_tmp_11 = new IntStackNode(env, intLib, m).newObj(intLib.mux(r.getBits(), __tmp8.getBits(),__tmp4));
		IntStackNode __tmp9 = f_tmp_11;
		r = __tmp9;
		Boolean[] f_tmp_12 = r.next;
		Boolean[] __tmp10 = f_tmp_12;
		Boolean[] f_tmp_13 = this.root;
		Boolean[] __tmp11 = f_tmp_13;
		Boolean[] f_tmp_14 = intLib.mux(__tmp11, __tmp10,__tmp4);
		Boolean[] __tmp12 = f_tmp_14;
		this.root = __tmp12;
		Boolean[] f_tmp_15 = this.size;
		Boolean[] __tmp13 = f_tmp_15;
		int f_tmp_16 = 1;
		int __tmp14 = f_tmp_16;
		Boolean[] f_tmp_18 = env.inputOfAlice(Utils.fromInt(__tmp14, m));
		Boolean[] f_tmp_17 = intLib.sub(__tmp13,f_tmp_18);
		Boolean[] __tmp15 = f_tmp_17;
		Boolean[] f_tmp_19 = this.size;
		Boolean[] __tmp16 = f_tmp_19;
		Boolean[] f_tmp_20 = intLib.mux(__tmp16, __tmp15,__tmp4);
		Boolean[] __tmp17 = f_tmp_20;
		this.size = __tmp17;
		Boolean[] f_tmp_21 = r.data;
		Boolean[] __tmp18 = f_tmp_21;
		Boolean[] f_tmp_22 = intLib.mux(ret, __tmp18,__tmp4);
		Boolean[] __tmp19 = f_tmp_22;
		ret = __tmp19;
		Boolean f_tmp_23 = intLib.not(__tmp4);
		Boolean __tmp20 = f_tmp_23;
		boolean f_tmp_24 = false;
		boolean __tmp21 = f_tmp_24;
		Boolean f_tmp_26 = env.inputOfAlice(__tmp21);
		Boolean f_tmp_25 = intLib.eq(dum, f_tmp_26);
		Boolean __tmp22 = f_tmp_25;
		Boolean f_tmp_27 = intLib.and(__tmp20,__tmp22);
		Boolean __tmp23 = f_tmp_27;
		Boolean[] f_tmp_28 = this.root;
		Boolean[] __tmp24 = f_tmp_28;
		IntStackNode f_tmp_29 = new IntStackNode(env, intLib, m);
		f_tmp_29.next = __tmp24;
		f_tmp_29.data = operand;
		IntStackNode __tmp25 = f_tmp_29;
		IntStackNode f_tmp_30 = new IntStackNode(env, intLib, m).newObj(intLib.mux(node.getBits(), __tmp25.getBits(),__tmp23));
		IntStackNode __tmp26 = f_tmp_30;
		node = __tmp26;
		Boolean[] f_tmp_31 = intLib.randBools(m);
		Boolean[] __tmp27 = f_tmp_31;
		Boolean[] f_tmp_32 = this.root;
		Boolean[] __tmp28 = f_tmp_32;
		Boolean[] f_tmp_33 = intLib.mux(__tmp28, __tmp27,__tmp23);
		Boolean[] __tmp29 = f_tmp_33;
		this.root = __tmp29;
		Boolean[] f_tmp_34 = this.size;
		Boolean[] __tmp30 = f_tmp_34;
		int f_tmp_35 = 1;
		int __tmp31 = f_tmp_35;
		Boolean[] f_tmp_37 = env.inputOfAlice(Utils.fromInt(__tmp31, m));
		Boolean[] f_tmp_36 = intLib.add(__tmp30,f_tmp_37);
		Boolean[] __tmp32 = f_tmp_36;
		Boolean[] f_tmp_38 = this.size;
		Boolean[] __tmp33 = f_tmp_38;
		Boolean[] f_tmp_39 = intLib.mux(__tmp33, __tmp32,__tmp23);
		Boolean[] __tmp34 = f_tmp_39;
		this.size = __tmp34;
		Boolean[] f_tmp_40 = this.size;
		Boolean[] __tmp35 = f_tmp_40;
		Boolean[] f_tmp_41 = this.root;
		Boolean[] __tmp36 = f_tmp_41;
		CircuitOram<Boolean> f_tmp_42 = this.poram;
		CircuitOram<Boolean> __tmp37 = f_tmp_42;
		__tmp37.conditionalPutBack(__tmp35, __tmp36, node.getBits(), __tmp23);
		Boolean f_tmp_44 = intLib.not(__tmp22);
		Boolean __tmp39 = f_tmp_44;
		Boolean f_tmp_45 = intLib.and(__tmp20,__tmp39);
		Boolean __tmp40 = f_tmp_45;
		return ret;
	}
}
