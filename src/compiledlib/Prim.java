package compiledlib;
import java.security.SecureRandom;
import oram.SecureArray;
import oram.CircuitOram;
import flexsc.Mode;
import flexsc.Party;
import flexsc.CompEnv;
import java.util.BitSet;
import circuits.arithmetic.IntegerLib;
import circuits.arithmetic.FloatLib;
import util.Utils;
import gc.regular.GCEva;
import gc.regular.GCGen;
import gc.GCSignal;
import java.util.Arrays;
import java.util.Random;
import flexsc.IWritable;
import flexsc.Comparator;
import java.lang.reflect.Array;
public class Prim<t__T> {
	public SecureArray<t__T> graph;
	public SecureArray<t__T> dis;

	public CompEnv<t__T> env;
	public IntegerLib<t__T> intLib;
	public FloatLib<t__T> floatLib;

	public Prim(CompEnv<t__T> env, SecureArray<t__T> graph, SecureArray<t__T> dis) throws Exception {
		this.env = env;
		this.intLib = new IntegerLib<t__T>(env);
		this.floatLib = new FloatLib<t__T>(env, 24, 8);
		this.graph = graph;
		this.dis = dis;
	}

	public void funct() throws Exception {
		SecureArray<t__T> explored = new SecureArray<t__T>(env, 10, 1);
		for(int _j_2 = 0; _j_2 < 10; ++_j_2) {
			explored[_j_2] = env.inputOfAlice(false);
		}
		int i = 0;
		PriorityQueue<t__T> pq;
		t__T[] zero = env.inputOfAlice(Utils.fromInt(0, 32));
		t__T[] next = env.inputOfAlice(Utils.fromInt(0, 32));
		t__T[] res = env.inputOfAlice(Utils.fromInt(0, 32));
		t__T traversingNode = env.inputOfAlice(false);
		Pair<t__T, Int<t__T>, Int<t__T>> t = new Pair<t__T, Int<t__T>, Int<t__T>>(env, new Int<t__T>(env), new Int<t__T>(env));
		SecureArray<t__T> e = new SecureArray<t__T>(env, 3, 32);
		for(int _j_2 = 0; _j_2 < 3; ++_j_2) {
			e[_j_2] = env.inputOfAlice(Utils.fromInt(0, 32));
		}
		t__T[] key1 = env.inputOfAlice(Utils.fromInt(0, 32));
		t__T[] val1 = env.inputOfAlice(Utils.fromInt(0, 32));
		int f_tmp_0 = 0;
		int __tmp0 = f_tmp_0;
		i = __tmp0;
		int f_tmp_1 = 10;
		int __tmp1 = f_tmp_1;
		boolean f_tmp_2 = i < __tmp1;
		boolean __tmp2 = f_tmp_2;
		while(__tmp2) {
			boolean f_tmp_3 = false;
			boolean __tmp3 = f_tmp_3;
			t__T[] f_tmp_4 = env.inputOfAlice(Utils.fromInt(i, 32));
			t__T[] f_tmp_5 = env.inputOfAlice(Utils.fromInt(__tmp3, 1));
			explored.write(f_tmp_4,f_tmp_5);
			int f_tmp_6 = 1;
			int __tmp4 = f_tmp_6;
			int f_tmp_7 = i + __tmp4;
			int __tmp5 = f_tmp_7;
			i = __tmp5;
			int f_tmp_8 = 10;
			__tmp1 = f_tmp_8;
			boolean f_tmp_9 = i < __tmp1;
			__tmp2 = f_tmp_9;
		}
		int f_tmp_10 = 0;
		int __tmp6 = f_tmp_10;
		zero = env.inputOfAlice(Utils.fromInt(__tmp6, 32));
		boolean f_tmp_11 = true;
		t__T __tmp7 = env.inputOfAlice(f_tmp_11);
		pq.push(zero, zero, __tmp7);
		int f_tmp_13 = 0;
		int __tmp9 = f_tmp_13;
		next = env.inputOfAlice(Utils.fromInt(__tmp9, 32));
		int f_tmp_14 = 0;
		int __tmp10 = f_tmp_14;
		res = env.inputOfAlice(Utils.fromInt(__tmp10, 32));
		boolean f_tmp_15 = false;
		boolean __tmp11 = f_tmp_15;
		traversingNode = env.inputOfAlice(__tmp11);
		int f_tmp_16 = 0;
		int __tmp12 = f_tmp_16;
		i = __tmp12;
		int f_tmp_17 = 2;
		int __tmp13 = f_tmp_17;
		int f_tmp_18 = 100;
		int __tmp14 = f_tmp_18;
		int f_tmp_19 = __tmp13 * __tmp14;
		int __tmp15 = f_tmp_19;
		boolean f_tmp_20 = i < __tmp15;
		boolean __tmp16 = f_tmp_20;
		while(__tmp16) {
			t__T f_tmp_21 = intLib.not(traversingNode);
			t__T __tmp18 = f_tmp_21;
			Pair<t__T, Int<t__T>, Int<t__T>> f_tmp_22 = new Pair<t__T, Int<t__T>, Int<t__T>>(env, new Int<t__T>(env), new Int<t__T>(env)).newObj(pq.pop(__tmp18));
			Pair<t__T, Int<t__T>, Int<t__T>> __tmp19 = f_tmp_22;
			Pair<t__T, Int<t__T>, Int<t__T>> __tmp20 = new Pair<t__T, Int<t__T>, Int<t__T>>(env, new Int<t__T>(env), new Int<t__T>(env)).newObj(intLib.mux(t.getBits(), __tmp19.getBits(),__tmp18));
			t = __tmp20;
			Int<t__T> f_tmp_24 = t.second;
			Int<t__T> __tmp21 = f_tmp_24;
			t__T[] f_tmp_25 = __tmp21.data;
			t__T[] __tmp22 = f_tmp_25;
			t__T f_tmp_26 = explored.read(__tmp22);
			t__T __tmp23 = f_tmp_26;
			t__T f_tmp_27 = intLib.not(__tmp23);
			t__T __tmp25 = f_tmp_27;
			t__T f_tmp_28 = intLib.and(__tmp18,__tmp25);
			t__T __tmp26 = f_tmp_28;
			boolean f_tmp_29 = true;
			boolean __tmp27 = f_tmp_29;
			Int<t__T> f_tmp_30 = t.second;
			Int<t__T> __tmp28 = f_tmp_30;
			t__T[] f_tmp_31 = __tmp28.data;
			t__T[] __tmp29 = f_tmp_31;
			t__T f_tmp_32 = explored.read(__tmp29);
			t__T __tmp30 = f_tmp_32;
			t__T f_tmp_34 = env.inputOfAlice(__tmp27);
			t__T __tmp31 = intLib.mux(__tmp30, f_tmp_34,__tmp26);
			explored.write(__tmp29,__tmp31);
			boolean f_tmp_35 = true;
			boolean __tmp32 = f_tmp_35;
			t__T f_tmp_37 = env.inputOfAlice(__tmp32);
			t__T __tmp33 = intLib.mux(traversingNode, f_tmp_37,__tmp26);
			traversingNode = __tmp33;
			Int<t__T> f_tmp_38 = t.first;
			Int<t__T> __tmp34 = f_tmp_38;
			t__T[] f_tmp_39 = __tmp34.data;
			t__T[] __tmp35 = f_tmp_39;
			t__T[] f_tmp_40 = intLib.add(res,__tmp35);
			t__T[] __tmp36 = f_tmp_40;
			t__T[] __tmp37 = intLib.mux(res, __tmp36,__tmp26);
			res = __tmp37;
			Int<t__T> f_tmp_42 = t.second;
			Int<t__T> __tmp38 = f_tmp_42;
			t__T[] f_tmp_43 = __tmp38.data;
			t__T[] __tmp39 = f_tmp_43;
			t__T[] __tmp40 = intLib.mux(next, __tmp39,__tmp26);
			next = __tmp40;
			t__T f_tmp_45 = intLib.not(__tmp18);
			t__T __tmp41 = f_tmp_45;
			SecureArray<t__T> f_tmp_46 = this.graph;
			SecureArray<t__T> __tmp42 = f_tmp_46;
			SecureArray<t__T> f_tmp_47 = __tmp42.read(next);
			SecureArray<t__T> __tmp43 = f_tmp_47;
			SecureArray<t__T> __tmp44 = intLib.mux(e.getBits(), __tmp43.getBits(),__tmp41);
			e = __tmp44;
			int f_tmp_49 = 1;
			int __tmp45 = f_tmp_49;
			t__T[] f_tmp_51 = env.inputOfAlice(Utils.fromInt(__tmp45, 32));
			t__T[] f_tmp_50 = e.read(f_tmp_51);
			t__T[] __tmp46 = f_tmp_50;
			t__T[] __tmp47 = intLib.mux(next, __tmp46,__tmp41);
			next = __tmp47;
			int f_tmp_53 = 0;
			int __tmp48 = f_tmp_53;
			int f_tmp_54 = 1;
			int __tmp49 = f_tmp_54;
			int f_tmp_55 = __tmp48 - __tmp49;
			int __tmp50 = f_tmp_55;
			t__T[] f_tmp_57 = env.inputOfAlice(Utils.fromInt(__tmp50, 32));
			t__T f_tmp_56 = intLib.eq(next, f_tmp_57);
			t__T __tmp51 = f_tmp_56;
			t__T f_tmp_58 = intLib.and(__tmp41,__tmp51);
			t__T __tmp52 = f_tmp_58;
			boolean f_tmp_59 = false;
			boolean __tmp53 = f_tmp_59;
			t__T f_tmp_61 = env.inputOfAlice(__tmp53);
			t__T __tmp54 = intLib.mux(traversingNode, f_tmp_61,__tmp52);
			traversingNode = __tmp54;
			t__T f_tmp_62 = intLib.not(__tmp51);
			t__T __tmp55 = f_tmp_62;
			t__T f_tmp_63 = intLib.and(__tmp41,__tmp55);
			t__T __tmp56 = f_tmp_63;
			int f_tmp_64 = 2;
			int __tmp57 = f_tmp_64;
			t__T[] f_tmp_66 = env.inputOfAlice(Utils.fromInt(__tmp57, 32));
			t__T[] f_tmp_65 = e.read(f_tmp_66);
			t__T[] __tmp58 = f_tmp_65;
			t__T[] __tmp59 = intLib.mux(key1, __tmp58,__tmp56);
			key1 = __tmp59;
			int f_tmp_68 = 0;
			int __tmp60 = f_tmp_68;
			t__T[] f_tmp_70 = env.inputOfAlice(Utils.fromInt(__tmp60, 32));
			t__T[] f_tmp_69 = e.read(f_tmp_70);
			t__T[] __tmp61 = f_tmp_69;
			t__T[] __tmp62 = intLib.mux(val1, __tmp61,__tmp56);
			val1 = __tmp62;
			pq.push(key1, val1, __tmp56);
			int f_tmp_73 = 1;
			int __tmp64 = f_tmp_73;
			int f_tmp_74 = i + __tmp64;
			int __tmp65 = f_tmp_74;
			i = __tmp65;
			int f_tmp_75 = 2;
			__tmp13 = f_tmp_75;
			int f_tmp_76 = 100;
			__tmp14 = f_tmp_76;
			int f_tmp_77 = __tmp13 * __tmp14;
			__tmp15 = f_tmp_77;
			boolean f_tmp_78 = i < __tmp15;
			__tmp16 = f_tmp_78;
		}

	}
}
