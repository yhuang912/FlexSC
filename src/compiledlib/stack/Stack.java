package compiledlib.stack;
import java.security.SecureRandom;
import oram.SecureArray;
import oram.CircuitOram;
import flexsc.Mode;
import flexsc.Party;
import flexsc.CompEnv;
import java.util.BitSet;
import circuits.arithmetic.IntegerLib;
import circuits.arithmetic.FloatLib;
import util.Utils;
import gc.regular.GCEva;
import gc.regular.GCGen;
import gc.GCSignal;
import java.util.Arrays;
import java.util.Random;
import flexsc.IWritable;
import flexsc.Comparator;
import java.lang.reflect.Array;
public class Stack<t__T, T extends IWritable<T,t__T>> {
	public t__T[] size;
	public t__T[] root;
	public CircuitOram<t__T> oram;

	public CompEnv<t__T> env;
	public IntegerLib<t__T> intLib;
	public FloatLib<t__T> floatLib;
	private T factoryT;
	private int m;

	public Stack(CompEnv<t__T> env, int m, T factoryT, CircuitOram<t__T> oram) throws Exception {
		this.env = env;
		this.intLib = new IntegerLib<t__T>(env);
		this.floatLib = new FloatLib<t__T>(env, 24, 8);
		this.m = m;
		this.factoryT = factoryT;
		this.size = env.inputOfAlice(Utils.fromInt(0, m));
		this.root = intLib.randBools(m);
		this.oram = oram;
	}

	public T stack_op(T operand, t__T op) throws Exception {
		T ret = factoryT.newObj(null);
		StackNode<t__T, T> r = new StackNode<t__T, T>(env, m, factoryT);
		StackNode<t__T, T> node = new StackNode<t__T, T>(env, m, factoryT);
		t__T __tmp1 = op;
		t__T[] f_tmp_0 = this.size;
		t__T[] __tmp2 = f_tmp_0;
		t__T[] f_tmp_1 = this.root;
		t__T[] __tmp3 = f_tmp_1;
		CircuitOram<t__T> f_tmp_2 = this.oram;
		CircuitOram<t__T> __tmp4 = f_tmp_2;
		StackNode<t__T, T> f_tmp_3 = new StackNode<t__T, T>(env, m, factoryT).newObj(__tmp4.conditionalReadAndRemove(__tmp2, __tmp3, __tmp1));
		StackNode<t__T, T> __tmp5 = f_tmp_3;
		StackNode<t__T, T> __tmp6 = new StackNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(r.getBits(), __tmp5.getBits(),__tmp1));
		r = __tmp6;
		t__T[] f_tmp_5 = r.next;
		t__T[] __tmp7 = f_tmp_5;
		t__T[] f_tmp_6 = this.root;
		t__T[] __tmp8 = f_tmp_6;
		t__T[] __tmp9 = intLib.mux(__tmp8, __tmp7,__tmp1);
		this.root = __tmp9;
		t__T[] f_tmp_8 = this.size;
		t__T[] __tmp10 = f_tmp_8;
		int f_tmp_9 = 1;
		int __tmp11 = f_tmp_9;
		t__T[] f_tmp_11 = env.inputOfAlice(Utils.fromInt(__tmp11, m));
		t__T[] f_tmp_10 = intLib.sub(__tmp10,f_tmp_11);
		t__T[] __tmp12 = f_tmp_10;
		t__T[] f_tmp_12 = this.size;
		t__T[] __tmp13 = f_tmp_12;
		t__T[] __tmp14 = intLib.mux(__tmp13, __tmp12,__tmp1);
		this.size = __tmp14;
		T f_tmp_14 = r.data;
		T __tmp15 = f_tmp_14;
		T __tmp16 = this.factoryT.newObj(intLib.mux(ret.getBits(), __tmp15.getBits(),__tmp1));
		ret = __tmp16;
		t__T f_tmp_16 = intLib.not(__tmp1);
		t__T __tmp17 = f_tmp_16;
		t__T[] f_tmp_17 = this.root;
		t__T[] __tmp18 = f_tmp_17;
		StackNode<t__T, T> f_tmp_18 = new StackNode<t__T, T>(env, m, factoryT);
		f_tmp_18.next = __tmp18;
		f_tmp_18.data = operand;
		StackNode<t__T, T> __tmp19 = f_tmp_18;
		StackNode<t__T, T> __tmp20 = new StackNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(node.getBits(), __tmp19.getBits(),__tmp17));
		node = __tmp20;
		t__T[] f_tmp_20 = intLib.randBools(m);
		t__T[] __tmp21 = f_tmp_20;
		t__T[] f_tmp_21 = this.root;
		t__T[] __tmp22 = f_tmp_21;
		t__T[] __tmp23 = intLib.mux(__tmp22, __tmp21,__tmp17);
		this.root = __tmp23;
		t__T[] f_tmp_23 = this.size;
		t__T[] __tmp24 = f_tmp_23;
		int f_tmp_24 = 1;
		int __tmp25 = f_tmp_24;
		t__T[] f_tmp_26 = env.inputOfAlice(Utils.fromInt(__tmp25, m));
		t__T[] f_tmp_25 = intLib.add(__tmp24,f_tmp_26);
		t__T[] __tmp26 = f_tmp_25;
		t__T[] f_tmp_27 = this.size;
		t__T[] __tmp27 = f_tmp_27;
		t__T[] __tmp28 = intLib.mux(__tmp27, __tmp26,__tmp17);
		this.size = __tmp28;
		t__T[] f_tmp_29 = this.size;
		t__T[] __tmp29 = f_tmp_29;
		t__T[] f_tmp_30 = this.root;
		t__T[] __tmp30 = f_tmp_30;
		CircuitOram<t__T> f_tmp_31 = this.oram;
		CircuitOram<t__T> __tmp31 = f_tmp_31;
		__tmp31.conditionalPutBack(__tmp29, __tmp30, node.getBits(), __tmp17);
		return ret;

	}
	public void push(T operand, t__T op) throws Exception {
		StackNode<t__T, T> node = new StackNode<t__T, T>(env, m, factoryT);
		t__T __tmp34 = op;
		t__T[] f_tmp_33 = this.root;
		t__T[] __tmp35 = f_tmp_33;
		StackNode<t__T, T> f_tmp_34 = new StackNode<t__T, T>(env, m, factoryT);
		f_tmp_34.next = __tmp35;
		f_tmp_34.data = operand;
		StackNode<t__T, T> __tmp36 = f_tmp_34;
		StackNode<t__T, T> __tmp37 = new StackNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(node.getBits(), __tmp36.getBits(),__tmp34));
		node = __tmp37;
		t__T[] f_tmp_36 = intLib.randBools(m);
		t__T[] __tmp38 = f_tmp_36;
		t__T[] f_tmp_37 = this.root;
		t__T[] __tmp39 = f_tmp_37;
		t__T[] __tmp40 = intLib.mux(__tmp39, __tmp38,__tmp34);
		this.root = __tmp40;
		t__T[] f_tmp_39 = this.size;
		t__T[] __tmp41 = f_tmp_39;
		int f_tmp_40 = 1;
		int __tmp42 = f_tmp_40;
		t__T[] f_tmp_42 = env.inputOfAlice(Utils.fromInt(__tmp42, m));
		t__T[] f_tmp_41 = intLib.add(__tmp41,f_tmp_42);
		t__T[] __tmp43 = f_tmp_41;
		t__T[] f_tmp_43 = this.size;
		t__T[] __tmp44 = f_tmp_43;
		t__T[] __tmp45 = intLib.mux(__tmp44, __tmp43,__tmp34);
		this.size = __tmp45;
		t__T[] f_tmp_45 = this.size;
		t__T[] __tmp46 = f_tmp_45;
		t__T[] f_tmp_46 = this.root;
		t__T[] __tmp47 = f_tmp_46;
		CircuitOram<t__T> f_tmp_47 = this.oram;
		CircuitOram<t__T> __tmp48 = f_tmp_47;
		__tmp48.conditionalPutBack(__tmp46, __tmp47, node.getBits(), __tmp34);

	}
	public T pop(t__T op) throws Exception {
		T ret = factoryT.newObj(null);
		StackNode<t__T, T> r = new StackNode<t__T, T>(env, m, factoryT);
		t__T __tmp51 = op;
		t__T[] f_tmp_49 = this.size;
		t__T[] __tmp52 = f_tmp_49;
		t__T[] f_tmp_50 = this.root;
		t__T[] __tmp53 = f_tmp_50;
		CircuitOram<t__T> f_tmp_51 = this.oram;
		CircuitOram<t__T> __tmp54 = f_tmp_51;
		StackNode<t__T, T> f_tmp_52 = new StackNode<t__T, T>(env, m, factoryT).newObj(__tmp54.conditionalReadAndRemove(__tmp52, __tmp53, __tmp51));
		StackNode<t__T, T> __tmp55 = f_tmp_52;
		StackNode<t__T, T> __tmp56 = new StackNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(r.getBits(), __tmp55.getBits(),__tmp51));
		r = __tmp56;
		t__T[] f_tmp_54 = r.next;
		t__T[] __tmp57 = f_tmp_54;
		t__T[] f_tmp_55 = this.root;
		t__T[] __tmp58 = f_tmp_55;
		t__T[] __tmp59 = intLib.mux(__tmp58, __tmp57,__tmp51);
		this.root = __tmp59;
		t__T[] f_tmp_57 = this.size;
		t__T[] __tmp60 = f_tmp_57;
		int f_tmp_58 = 1;
		int __tmp61 = f_tmp_58;
		t__T[] f_tmp_60 = env.inputOfAlice(Utils.fromInt(__tmp61, m));
		t__T[] f_tmp_59 = intLib.sub(__tmp60,f_tmp_60);
		t__T[] __tmp62 = f_tmp_59;
		t__T[] f_tmp_61 = this.size;
		t__T[] __tmp63 = f_tmp_61;
		t__T[] __tmp64 = intLib.mux(__tmp63, __tmp62,__tmp51);
		this.size = __tmp64;
		T f_tmp_63 = r.data;
		T __tmp65 = f_tmp_63;
		T __tmp66 = this.factoryT.newObj(intLib.mux(ret.getBits(), __tmp65.getBits(),__tmp51));
		ret = __tmp66;
		return ret;

	}
}
