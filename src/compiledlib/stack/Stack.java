package compiledlib.stack;
import oram.CircuitOram;
import util.Utils;
import circuits.IntegerLib;
import flexsc.CompEnv;
import flexsc.IWritable;
public class Stack<T extends IWritable<T,Boolean>> {
	public CircuitOram<Boolean> oram;
	public Boolean[] root;
	public Boolean[] size;

	private CompEnv<Boolean> env;
	private IntegerLib<Boolean> lib;
	private T factoryT;
	private int m;

	public Stack(CompEnv<Boolean> env, IntegerLib<Boolean> lib, int m, T factoryT, CircuitOram<Boolean> oram) throws Exception {
		this.env = env;
		this.lib = lib;
		this.m = m;
		this.factoryT = factoryT;
		this.oram = oram;
		this.root = env.inputOfAlice(Utils.fromInt(0, m));
		this.size = env.inputOfAlice(Utils.fromInt(0, m));
	}

	public T stack_op(T operand, Boolean op) throws Exception {
		T ret = factoryT.newObj(null);
		StackNode<T> r = new StackNode<T>(env, lib, m, factoryT);
		StackNode<T> node = new StackNode<T>(env, lib, m, factoryT);
		boolean f_tmp_0 = true;
		boolean __tmp0 = f_tmp_0;
		Boolean f_tmp_2 = env.inputOfAlice(__tmp0);
		Boolean f_tmp_1 = lib.eq(op, f_tmp_2);
		Boolean __tmp1 = f_tmp_1;
		Boolean[] f_tmp_3 = this.size;
		Boolean[] __tmp2 = f_tmp_3;
		Boolean[] f_tmp_4 = this.root;
		Boolean[] __tmp3 = f_tmp_4;
		CircuitOram<Boolean> f_tmp_5 = this.oram;
		CircuitOram<Boolean> __tmp4 = f_tmp_5;
		StackNode<T> f_tmp_6 = new StackNode<T>(env, lib, m, factoryT).newObj(__tmp4.conditionalReadAndRemove(__tmp2, __tmp3, __tmp1));
		StackNode<T> __tmp5 = f_tmp_6;
		StackNode<T> f_tmp_7 = new StackNode<T>(env, lib, m, factoryT).newObj(lib.mux(r.getBits(), __tmp5.getBits(),__tmp1));
		StackNode<T> __tmp6 = f_tmp_7;
		r = __tmp6;
		Boolean[] f_tmp_8 = r.next;
		Boolean[] __tmp7 = f_tmp_8;
		Boolean[] f_tmp_9 = this.root;
		Boolean[] __tmp8 = f_tmp_9;
		Boolean[] f_tmp_10 = lib.mux(__tmp8, __tmp7,__tmp1);
		Boolean[] __tmp9 = f_tmp_10;
		this.root = __tmp9;
		Boolean[] f_tmp_11 = this.size;
		Boolean[] __tmp10 = f_tmp_11;
		int f_tmp_12 = 1;
		int __tmp11 = f_tmp_12;
		Boolean[] f_tmp_14 = env.inputOfAlice(Utils.fromInt(__tmp11, m));
		Boolean[] f_tmp_13 = lib.sub(__tmp10,f_tmp_14);
		Boolean[] __tmp12 = f_tmp_13;
		Boolean[] f_tmp_15 = this.size;
		Boolean[] __tmp13 = f_tmp_15;
		Boolean[] f_tmp_16 = lib.mux(__tmp13, __tmp12,__tmp1);
		Boolean[] __tmp14 = f_tmp_16;
		this.size = __tmp14;
		T f_tmp_17 = r.data;
		T __tmp15 = f_tmp_17;
		T f_tmp_18 = this.factoryT.newObj(lib.mux(ret.getBits(), __tmp15.getBits(),__tmp1));
		T __tmp16 = f_tmp_18;
		ret = __tmp16;
		Boolean f_tmp_19 = lib.not(__tmp1);
		Boolean __tmp17 = f_tmp_19;
		Boolean[] f_tmp_20 = this.root;
		Boolean[] __tmp18 = f_tmp_20;
		StackNode<T> f_tmp_21 = new StackNode<T>(env, lib, m, factoryT);
		f_tmp_21.next = __tmp18;
		f_tmp_21.data = operand;
		StackNode<T> __tmp19 = f_tmp_21;
		StackNode<T> f_tmp_22 = new StackNode<T>(env, lib, m, factoryT).newObj(lib.mux(node.getBits(), __tmp19.getBits(),__tmp17));
		StackNode<T> __tmp20 = f_tmp_22;
		node = __tmp20;
		Boolean[] f_tmp_23 = lib.randBools(m);
		Boolean[] __tmp21 = f_tmp_23;
		Boolean[] f_tmp_24 = this.root;
		Boolean[] __tmp22 = f_tmp_24;
		Boolean[] f_tmp_25 = lib.mux(__tmp22, __tmp21,__tmp17);
		Boolean[] __tmp23 = f_tmp_25;
		this.root = __tmp23;
		Boolean[] f_tmp_26 = this.size;
		Boolean[] __tmp24 = f_tmp_26;
		int f_tmp_27 = 1;
		int __tmp25 = f_tmp_27;
		Boolean[] f_tmp_29 = env.inputOfAlice(Utils.fromInt(__tmp25, m));
		Boolean[] f_tmp_28 = lib.add(__tmp24,f_tmp_29);
		Boolean[] __tmp26 = f_tmp_28;
		Boolean[] f_tmp_30 = this.size;
		Boolean[] __tmp27 = f_tmp_30;
		Boolean[] f_tmp_31 = lib.mux(__tmp27, __tmp26,__tmp17);
		Boolean[] __tmp28 = f_tmp_31;
		this.size = __tmp28;
		Boolean[] f_tmp_32 = this.size;
		Boolean[] __tmp29 = f_tmp_32;
		Boolean[] f_tmp_33 = this.root;
		Boolean[] __tmp30 = f_tmp_33;
		CircuitOram<Boolean> f_tmp_34 = this.oram;
		CircuitOram<Boolean> __tmp31 = f_tmp_34;
		__tmp31.conditionalPutBack(__tmp29, __tmp30, node.getBits(), __tmp17);
		return ret;
	}
}
