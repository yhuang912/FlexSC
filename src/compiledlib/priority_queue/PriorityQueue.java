package compiledlib.priority_queue;
import java.security.SecureRandom;
import oram.SecureArray;
import oram.CircuitOram;
import flexsc.Mode;
import flexsc.Party;
import flexsc.CompEnv;
import java.util.BitSet;
import circuits.arithmetic.IntegerLib;
import circuits.arithmetic.FloatLib;
import util.Utils;
import gc.regular.GCEva;
import gc.regular.GCGen;
import gc.GCSignal;
import java.util.Arrays;
import java.util.Random;
import flexsc.IWritable;
import flexsc.Comparator;
import java.lang.reflect.Array;
public class PriorityQueue<t__T, T extends IWritable<T,t__T>> {
	public CircuitOram<t__T> poram;
	public t__T[] size;
	public NodeId<t__T> root;

	public CompEnv<t__T> env;
	public IntegerLib<t__T> intLib;
	public FloatLib<t__T> floatLib;
	private T factoryT;
	private int m;

	public PriorityQueue(CompEnv<t__T> env, int m, T factoryT, CircuitOram<t__T> poram) throws Exception {
		this.env = env;
		this.intLib = new IntegerLib<t__T>(env);
		this.floatLib = new FloatLib<t__T>(env, 24, 8);
		this.m = m;
		this.factoryT = factoryT;
		this.poram = poram;
		this.size = env.inputOfAlice(Utils.fromInt(0, m));
		this.root = new NodeId<t__T>(env, m);
	}

	public void init() throws Exception {
		int __tmp0 = m;
		t__T[] f_tmp_0 = intLib.randBools(__tmp0);
		t__T[] __tmp1 = f_tmp_0;
		NodeId<t__T> f_tmp_1 = this.root;
		NodeId<t__T> __tmp2 = f_tmp_1;
		__tmp2.pos = __tmp1;
		int f_tmp_2 = 0;
		int __tmp3 = f_tmp_2;
		t__T[] f_tmp_3 = env.inputOfAlice(Utils.fromInt(__tmp3, m));
		this.size = f_tmp_3;
		int f_tmp_4 = 0;
		int __tmp4 = f_tmp_4;
		NodeId<t__T> f_tmp_5 = this.root;
		NodeId<t__T> __tmp5 = f_tmp_5;
		t__T[] f_tmp_6 = env.inputOfAlice(Utils.fromInt(__tmp4, m));
		__tmp5.id = f_tmp_6;

	}
	public KeyValue<t__T, T> pqueue_op(t__T[] key, T operand, t__T op) throws Exception {
		KeyValue<t__T, T> ret = new KeyValue<t__T, T>(env, m, factoryT);
		KeyValue<t__T, T> d = new KeyValue<t__T, T>(env, m, factoryT);
		t__T insert_dummy_bit = env.inputOfAlice(false);
		t__T pop_dummy_bit = env.inputOfAlice(false);
		KeyValue<t__T, T> f_tmp_7 = new KeyValue<t__T, T>(env, m, factoryT);
		f_tmp_7.value = operand;
		f_tmp_7.key = key;
		KeyValue<t__T, T> __tmp6 = f_tmp_7;
		d = __tmp6;
		t__T __tmp8 = op;
		boolean f_tmp_8 = false;
		boolean __tmp9 = f_tmp_8;
		t__T f_tmp_10 = env.inputOfAlice(__tmp9);
		t__T __tmp10 = intLib.mux(insert_dummy_bit, f_tmp_10,__tmp8);
		insert_dummy_bit = __tmp10;
		boolean f_tmp_11 = true;
		boolean __tmp11 = f_tmp_11;
		t__T f_tmp_13 = env.inputOfAlice(__tmp11);
		t__T __tmp12 = intLib.mux(pop_dummy_bit, f_tmp_13,__tmp8);
		pop_dummy_bit = __tmp12;
		t__T f_tmp_14 = intLib.not(__tmp8);
		t__T __tmp13 = f_tmp_14;
		boolean f_tmp_15 = true;
		boolean __tmp14 = f_tmp_15;
		t__T f_tmp_17 = env.inputOfAlice(__tmp14);
		t__T __tmp15 = intLib.mux(insert_dummy_bit, f_tmp_17,__tmp13);
		insert_dummy_bit = __tmp15;
		boolean f_tmp_18 = false;
		boolean __tmp16 = f_tmp_18;
		t__T f_tmp_20 = env.inputOfAlice(__tmp16);
		t__T __tmp17 = intLib.mux(pop_dummy_bit, f_tmp_20,__tmp13);
		pop_dummy_bit = __tmp17;
		KeyValue<t__T, T> f_tmp_21 = this.extractMax(pop_dummy_bit);
		KeyValue<t__T, T> __tmp18 = f_tmp_21;
		ret = __tmp18;
		this.insert(d, insert_dummy_bit);
		return ret;

	}
	public void push(t__T[] key, T operand, t__T dummy_bit) throws Exception {
		KeyValue<t__T, T> d = new KeyValue<t__T, T>(env, m, factoryT);
		KeyValue<t__T, T> f_tmp_23 = new KeyValue<t__T, T>(env, m, factoryT);
		f_tmp_23.value = operand;
		f_tmp_23.key = key;
		KeyValue<t__T, T> __tmp20 = f_tmp_23;
		d = __tmp20;
		this.insert(d, dummy_bit);

	}
	public KeyValue<t__T, T> pop(t__T dummy_bit) throws Exception {
		KeyValue<t__T, T> ret = new KeyValue<t__T, T>(env, m, factoryT);
		KeyValue<t__T, T> f_tmp_25 = this.extractMax(dummy_bit);
		KeyValue<t__T, T> __tmp22 = f_tmp_25;
		ret = __tmp22;
		return ret;

	}
	public t__T[] right_shift(t__T[] id, int s) throws Exception {
		t__T[] ret = env.inputOfAlice(Utils.fromInt(0, m));
		int i = 0;
		ret = id;
		int f_tmp_26 = 0;
		int __tmp23 = f_tmp_26;
		i = __tmp23;
		boolean f_tmp_27 = i < s;
		boolean __tmp24 = f_tmp_27;
		while(__tmp24) {
			int f_tmp_28 = 1;
			int __tmp25 = f_tmp_28;
			t__T[] f_tmp_29 = intLib.rightPublicShift(ret, __tmp25);
			t__T[] __tmp26 = f_tmp_29;
			ret = __tmp26;
			int f_tmp_30 = 1;
			int __tmp27 = f_tmp_30;
			int f_tmp_31 = i + __tmp27;
			int __tmp28 = f_tmp_31;
			i = __tmp28;
			boolean f_tmp_32 = i < s;
			__tmp24 = f_tmp_32;
		}
		return ret;

	}
	public t__T should_go_left(t__T[] id, int level) throws Exception {
		t__T ret = env.inputOfAlice(false);
		t__T[] res = env.inputOfAlice(Utils.fromInt(0, m));
		t__T[] tmpid = env.inputOfAlice(Utils.fromInt(0, m));
		int i = 0;
		t__T[] toshift = env.inputOfAlice(Utils.fromInt(0, m));
		int __tmp29 = m;
		int f_tmp_33 = 1;
		int __tmp30 = f_tmp_33;
		int f_tmp_34 = __tmp29 - __tmp30;
		int __tmp31 = f_tmp_34;
		boolean f_tmp_35 = level >= __tmp31;
		boolean __tmp32 = f_tmp_35;
		if(__tmp32) {
			boolean f_tmp_36 = true;
			boolean __tmp33 = f_tmp_36;
			ret = env.inputOfAlice(__tmp33);
		} else {
			int f_tmp_37 = 0;
			int __tmp34 = f_tmp_37;
			res = env.inputOfAlice(Utils.fromInt(__tmp34, m));
			tmpid = id;
			int f_tmp_38 = 0;
			int __tmp35 = f_tmp_38;
			i = __tmp35;
			int f_tmp_39 = 0;
			int __tmp36 = f_tmp_39;
			i = __tmp36;
			int __tmp37 = m;
			boolean f_tmp_40 = i < __tmp37;
			boolean __tmp38 = f_tmp_40;
			while(__tmp38) {
				int f_tmp_41 = 1;
				int __tmp39 = f_tmp_41;
				t__T[] f_tmp_43 = env.inputOfAlice(Utils.fromInt(__tmp39, m));
				t__T f_tmp_42 = intLib.eq(tmpid, f_tmp_43);
				t__T __tmp40 = f_tmp_42;
				t__T[] f_tmp_45 = env.inputOfAlice(Utils.fromInt(i, m));
				t__T[] __tmp41 = intLib.mux(res, f_tmp_45,__tmp40);
				res = __tmp41;
				int f_tmp_46 = 1;
				int __tmp42 = f_tmp_46;
				t__T[] f_tmp_47 = intLib.rightPublicShift(tmpid, __tmp42);
				t__T[] __tmp43 = f_tmp_47;
				tmpid = __tmp43;
				int f_tmp_48 = 1;
				int __tmp44 = f_tmp_48;
				int f_tmp_49 = i + __tmp44;
				int __tmp45 = f_tmp_49;
				i = __tmp45;
				__tmp37 = m;
				boolean f_tmp_50 = i < __tmp37;
				__tmp38 = f_tmp_50;
			}
			tmpid = id;
			t__T[] f_tmp_52 = env.inputOfAlice(Utils.fromInt(level, m));
			t__T[] f_tmp_51 = intLib.sub(res,f_tmp_52);
			t__T[] __tmp46 = f_tmp_51;
			toshift = __tmp46;
			int f_tmp_53 = 0;
			int __tmp47 = f_tmp_53;
			i = __tmp47;
			int __tmp48 = m;
			boolean f_tmp_54 = i < __tmp48;
			boolean __tmp49 = f_tmp_54;
			while(__tmp49) {
				int f_tmp_55 = 0;
				int __tmp50 = f_tmp_55;
				t__T[] f_tmp_57 = env.inputOfAlice(Utils.fromInt(__tmp50, m));
				t__T f_tmp_56 = intLib.not(intLib.leq(toshift, f_tmp_57));
				t__T __tmp51 = f_tmp_56;
				int f_tmp_58 = 1;
				int __tmp52 = f_tmp_58;
				t__T[] f_tmp_59 = intLib.rightPublicShift(tmpid, __tmp52);
				t__T[] __tmp53 = f_tmp_59;
				t__T[] __tmp54 = intLib.mux(tmpid, __tmp53,__tmp51);
				tmpid = __tmp54;
				int f_tmp_61 = 1;
				int __tmp55 = f_tmp_61;
				t__T[] f_tmp_63 = env.inputOfAlice(Utils.fromInt(__tmp55, m));
				t__T[] f_tmp_62 = intLib.sub(toshift,f_tmp_63);
				t__T[] __tmp56 = f_tmp_62;
				t__T[] __tmp57 = intLib.mux(toshift, __tmp56,__tmp51);
				toshift = __tmp57;
				int f_tmp_65 = 1;
				int __tmp58 = f_tmp_65;
				int f_tmp_66 = i + __tmp58;
				int __tmp59 = f_tmp_66;
				i = __tmp59;
				__tmp48 = m;
				boolean f_tmp_67 = i < __tmp48;
				__tmp49 = f_tmp_67;
			}
			int f_tmp_68 = 1;
			int __tmp60 = f_tmp_68;
			t__T[] f_tmp_70 = env.inputOfAlice(Utils.fromInt(__tmp60, m));
			t__T f_tmp_69 = intLib.eq(id, f_tmp_70);
			t__T __tmp61 = f_tmp_69;
			boolean f_tmp_71 = true;
			boolean __tmp62 = f_tmp_71;
			t__T f_tmp_73 = env.inputOfAlice(__tmp62);
			t__T __tmp63 = intLib.mux(ret, f_tmp_73,__tmp61);
			ret = __tmp63;
			t__T f_tmp_74 = intLib.not(__tmp61);
			t__T __tmp64 = f_tmp_74;
			int f_tmp_75 = 1;
			int __tmp65 = f_tmp_75;
			t__T[] f_tmp_77 = env.inputOfAlice(Utils.fromInt(__tmp65, m));
			t__T[] f_tmp_76 = intLib.and(tmpid,f_tmp_77);
			t__T[] __tmp66 = f_tmp_76;
			int f_tmp_78 = 0;
			int __tmp67 = f_tmp_78;
			t__T[] f_tmp_80 = env.inputOfAlice(Utils.fromInt(__tmp67, m));
			t__T f_tmp_79 = intLib.eq(__tmp66, f_tmp_80);
			t__T __tmp68 = f_tmp_79;
			t__T f_tmp_81 = intLib.and(__tmp64,__tmp68);
			t__T __tmp69 = f_tmp_81;
			boolean f_tmp_82 = true;
			boolean __tmp70 = f_tmp_82;
			t__T f_tmp_84 = env.inputOfAlice(__tmp70);
			t__T __tmp71 = intLib.mux(ret, f_tmp_84,__tmp69);
			ret = __tmp71;
			t__T f_tmp_85 = intLib.not(__tmp68);
			t__T __tmp72 = f_tmp_85;
			t__T f_tmp_86 = intLib.and(__tmp64,__tmp72);
			t__T __tmp73 = f_tmp_86;
			boolean f_tmp_87 = false;
			boolean __tmp74 = f_tmp_87;
			t__T f_tmp_89 = env.inputOfAlice(__tmp74);
			t__T __tmp75 = intLib.mux(ret, f_tmp_89,__tmp73);
			ret = __tmp75;
		}
		return ret;

	}
	public KeyValue<t__T, T> extractMax(t__T dummy_bit) throws Exception {
		KeyValue<t__T, T> ret = new KeyValue<t__T, T>(env, m, factoryT);
		PriorityQueueNode<t__T, T> last_node = new PriorityQueueNode<t__T, T>(env, m, factoryT);
		t__T newdummy_bit = env.inputOfAlice(false);
		PriorityQueueNode<t__T, T> root_node = new PriorityQueueNode<t__T, T>(env, m, factoryT);
		NodeId<t__T> f_tmp_90 = this.root;
		NodeId<t__T> __tmp76 = f_tmp_90;
		int f_tmp_91 = 1;
		int __tmp77 = f_tmp_91;
		PriorityQueueNode<t__T, T> f_tmp_92 = this.get_last(__tmp76, __tmp77, dummy_bit);
		PriorityQueueNode<t__T, T> __tmp78 = f_tmp_92;
		last_node = __tmp78;
		boolean f_tmp_93 = false;
		boolean __tmp79 = f_tmp_93;
		newdummy_bit = env.inputOfAlice(__tmp79);
		t__T __tmp81 = dummy_bit;
		int f_tmp_94 = 1;
		int __tmp82 = f_tmp_94;
		NodeId<t__T> f_tmp_95 = this.root;
		NodeId<t__T> __tmp83 = f_tmp_95;
		t__T[] f_tmp_96 = __tmp83.id;
		t__T[] __tmp84 = f_tmp_96;
		t__T[] f_tmp_98 = env.inputOfAlice(Utils.fromInt(__tmp82, m));
		t__T[] __tmp85 = intLib.mux(__tmp84, f_tmp_98,__tmp81);
		__tmp83.id = __tmp85;
		t__T[] f_tmp_99 = this.size;
		t__T[] __tmp86 = f_tmp_99;
		int f_tmp_100 = 1;
		int __tmp87 = f_tmp_100;
		t__T[] f_tmp_102 = env.inputOfAlice(Utils.fromInt(__tmp87, m));
		t__T[] f_tmp_101 = intLib.sub(__tmp86,f_tmp_102);
		t__T[] __tmp88 = f_tmp_101;
		t__T[] f_tmp_103 = this.size;
		t__T[] __tmp89 = f_tmp_103;
		t__T[] __tmp90 = intLib.mux(__tmp89, __tmp88,__tmp81);
		this.size = __tmp90;
		t__T[] f_tmp_105 = this.size;
		t__T[] __tmp91 = f_tmp_105;
		int f_tmp_106 = 0;
		int __tmp92 = f_tmp_106;
		t__T[] f_tmp_108 = env.inputOfAlice(Utils.fromInt(__tmp92, m));
		t__T f_tmp_107 = intLib.not(intLib.leq(__tmp91, f_tmp_108));
		t__T __tmp93 = f_tmp_107;
		t__T f_tmp_109 = intLib.and(__tmp81,__tmp93);
		t__T __tmp94 = f_tmp_109;
		t__T[] f_tmp_110 = this.size;
		t__T[] __tmp95 = f_tmp_110;
		int f_tmp_111 = 0;
		int __tmp96 = f_tmp_111;
		t__T[] f_tmp_113 = env.inputOfAlice(Utils.fromInt(__tmp96, m));
		t__T f_tmp_112 = intLib.not(intLib.leq(__tmp95, f_tmp_113));
		t__T __tmp97 = f_tmp_112;
		t__T __tmp99 = dummy_bit;
		t__T f_tmp_114 = intLib.and(__tmp97,__tmp99);
		t__T __tmp100 = f_tmp_114;
		t__T f_tmp_115 = intLib.and(__tmp94,__tmp100);
		t__T __tmp101 = f_tmp_115;
		boolean f_tmp_116 = true;
		boolean __tmp102 = f_tmp_116;
		t__T f_tmp_118 = env.inputOfAlice(__tmp102);
		t__T __tmp103 = intLib.mux(newdummy_bit, f_tmp_118,__tmp101);
		newdummy_bit = __tmp103;
		t__T f_tmp_119 = intLib.not(__tmp100);
		t__T __tmp104 = f_tmp_119;
		t__T f_tmp_120 = intLib.and(__tmp94,__tmp104);
		t__T __tmp105 = f_tmp_120;
		boolean f_tmp_121 = false;
		boolean __tmp106 = f_tmp_121;
		t__T f_tmp_123 = env.inputOfAlice(__tmp106);
		t__T __tmp107 = intLib.mux(newdummy_bit, f_tmp_123,__tmp105);
		newdummy_bit = __tmp107;
		NodeId<t__T> f_tmp_124 = last_node.left;
		NodeId<t__T> __tmp108 = f_tmp_124;
		t__T[] f_tmp_125 = __tmp108.pos;
		t__T[] __tmp109 = f_tmp_125;
		NodeId<t__T> f_tmp_126 = this.root;
		NodeId<t__T> __tmp110 = f_tmp_126;
		t__T[] f_tmp_127 = __tmp110.pos;
		t__T[] __tmp111 = f_tmp_127;
		t__T[] __tmp112 = intLib.mux(__tmp111, __tmp109,__tmp94);
		__tmp110.pos = __tmp112;
		NodeId<t__T> f_tmp_129 = this.root;
		NodeId<t__T> __tmp113 = f_tmp_129;
		t__T[] f_tmp_130 = __tmp113.id;
		t__T[] __tmp114 = f_tmp_130;
		NodeId<t__T> f_tmp_131 = this.root;
		NodeId<t__T> __tmp115 = f_tmp_131;
		t__T[] f_tmp_132 = __tmp115.pos;
		t__T[] __tmp116 = f_tmp_132;
		CircuitOram<t__T> f_tmp_133 = this.poram;
		CircuitOram<t__T> __tmp117 = f_tmp_133;
		PriorityQueueNode<t__T, T> f_tmp_134 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(__tmp117.conditionalReadAndRemove(__tmp114, __tmp116, __tmp94));
		PriorityQueueNode<t__T, T> __tmp118 = f_tmp_134;
		PriorityQueueNode<t__T, T> __tmp119 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(root_node.getBits(), __tmp118.getBits(),__tmp94));
		root_node = __tmp119;
		KeyValue<t__T, T> f_tmp_136 = root_node.keyvalue;
		KeyValue<t__T, T> __tmp120 = f_tmp_136;
		KeyValue<t__T, T> __tmp121 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(ret.getBits(), __tmp120.getBits(),__tmp94));
		ret = __tmp121;
		KeyValue<t__T, T> f_tmp_138 = last_node.keyvalue;
		KeyValue<t__T, T> __tmp122 = f_tmp_138;
		KeyValue<t__T, T> f_tmp_139 = root_node.keyvalue;
		KeyValue<t__T, T> __tmp123 = f_tmp_139;
		KeyValue<t__T, T> __tmp124 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(__tmp123.getBits(), __tmp122.getBits(),__tmp94));
		root_node.keyvalue = __tmp124;
		NodeId<t__T> f_tmp_141 = this.root;
		NodeId<t__T> __tmp125 = f_tmp_141;
		t__T[] f_tmp_142 = __tmp125.id;
		t__T[] __tmp126 = f_tmp_142;
		int f_tmp_143 = 1;
		int __tmp127 = f_tmp_143;
		t__T[] f_tmp_144 = this.heapify(__tmp126, root_node, __tmp127, newdummy_bit);
		t__T[] __tmp128 = f_tmp_144;
		NodeId<t__T> f_tmp_145 = this.root;
		NodeId<t__T> __tmp129 = f_tmp_145;
		t__T[] f_tmp_146 = __tmp129.pos;
		t__T[] __tmp130 = f_tmp_146;
		t__T[] __tmp131 = intLib.mux(__tmp130, __tmp128,__tmp94);
		__tmp129.pos = __tmp131;
		t__T f_tmp_148 = intLib.not(__tmp93);
		t__T __tmp132 = f_tmp_148;
		t__T f_tmp_149 = intLib.and(__tmp81,__tmp132);
		t__T __tmp133 = f_tmp_149;
		KeyValue<t__T, T> f_tmp_150 = last_node.keyvalue;
		KeyValue<t__T, T> __tmp134 = f_tmp_150;
		KeyValue<t__T, T> __tmp135 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(ret.getBits(), __tmp134.getBits(),__tmp133));
		ret = __tmp135;
		int __tmp136 = m;
		t__T[] f_tmp_152 = intLib.randBools(__tmp136);
		t__T[] __tmp137 = f_tmp_152;
		NodeId<t__T> f_tmp_153 = this.root;
		NodeId<t__T> __tmp138 = f_tmp_153;
		t__T[] f_tmp_154 = __tmp138.pos;
		t__T[] __tmp139 = f_tmp_154;
		t__T[] __tmp140 = intLib.mux(__tmp139, __tmp137,__tmp133);
		__tmp138.pos = __tmp140;
		return ret;

	}
	public t__T[] heapify(t__T[] top_id, PriorityQueueNode<t__T, T> top_node, int level, t__T dummy_bit) throws Exception {
		t__T[] ret = intLib.randBools(m);
		t__T newdummy_bit = env.inputOfAlice(false);
		t__T go_left = env.inputOfAlice(false);
		t__T[] child_iter = intLib.randBools(m);
		t__T[] id_to_use = env.inputOfAlice(Utils.fromInt(0, m));
		t__T[] pos_to_use = intLib.randBools(m);
		PriorityQueueNode<t__T, T> node_to_use = new PriorityQueueNode<t__T, T>(env, m, factoryT);
		PriorityQueueNode<t__T, T> left_node = new PriorityQueueNode<t__T, T>(env, m, factoryT);
		PriorityQueueNode<t__T, T> right_node = new PriorityQueueNode<t__T, T>(env, m, factoryT);
		KeyValue<t__T, T> tmp_kv = new KeyValue<t__T, T>(env, m, factoryT);
		boolean f_tmp_156 = false;
		boolean __tmp141 = f_tmp_156;
		newdummy_bit = env.inputOfAlice(__tmp141);
		boolean f_tmp_157 = false;
		boolean __tmp142 = f_tmp_157;
		go_left = env.inputOfAlice(__tmp142);
		int __tmp143 = m;
		boolean f_tmp_158 = level < __tmp143;
		boolean __tmp144 = f_tmp_158;
		if(__tmp144) {
			t__T __tmp146 = dummy_bit;
			t__T[] f_tmp_159 = this.size;
			t__T[] __tmp147 = f_tmp_159;
			t__T f_tmp_160 = intLib.leq(top_id, __tmp147);
			t__T __tmp148 = f_tmp_160;
			t__T f_tmp_161 = intLib.and(__tmp146,__tmp148);
			t__T __tmp149 = f_tmp_161;
			t__T[] f_tmp_162 = this.size;
			t__T[] __tmp150 = f_tmp_162;
			int f_tmp_163 = 1;
			int __tmp151 = f_tmp_163;
			t__T[] f_tmp_164 = intLib.rightPublicShift(__tmp150, __tmp151);
			t__T[] __tmp152 = f_tmp_164;
			t__T f_tmp_165 = intLib.leq(top_id, __tmp152);
			t__T __tmp153 = f_tmp_165;
			t__T f_tmp_166 = intLib.and(__tmp149,__tmp153);
			t__T __tmp154 = f_tmp_166;
			NodeId<t__T> f_tmp_167 = top_node.left;
			NodeId<t__T> __tmp155 = f_tmp_167;
			t__T[] f_tmp_168 = __tmp155.id;
			t__T[] __tmp156 = f_tmp_168;
			NodeId<t__T> f_tmp_169 = top_node.left;
			NodeId<t__T> __tmp157 = f_tmp_169;
			t__T[] f_tmp_170 = __tmp157.pos;
			t__T[] __tmp158 = f_tmp_170;
			CircuitOram<t__T> f_tmp_171 = this.poram;
			CircuitOram<t__T> __tmp159 = f_tmp_171;
			PriorityQueueNode<t__T, T> f_tmp_172 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(__tmp159.conditionalReadAndRemove(__tmp156, __tmp158, __tmp154));
			PriorityQueueNode<t__T, T> __tmp160 = f_tmp_172;
			PriorityQueueNode<t__T, T> __tmp161 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(left_node.getBits(), __tmp160.getBits(),__tmp154));
			left_node = __tmp161;
			NodeId<t__T> f_tmp_174 = top_node.right;
			NodeId<t__T> __tmp162 = f_tmp_174;
			t__T[] f_tmp_175 = __tmp162.id;
			t__T[] __tmp163 = f_tmp_175;
			NodeId<t__T> f_tmp_176 = top_node.right;
			NodeId<t__T> __tmp164 = f_tmp_176;
			t__T[] f_tmp_177 = __tmp164.pos;
			t__T[] __tmp165 = f_tmp_177;
			CircuitOram<t__T> f_tmp_178 = this.poram;
			CircuitOram<t__T> __tmp166 = f_tmp_178;
			PriorityQueueNode<t__T, T> f_tmp_179 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(__tmp166.conditionalReadAndRemove(__tmp163, __tmp165, __tmp154));
			PriorityQueueNode<t__T, T> __tmp167 = f_tmp_179;
			PriorityQueueNode<t__T, T> __tmp168 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(right_node.getBits(), __tmp167.getBits(),__tmp154));
			right_node = __tmp168;
			KeyValue<t__T, T> f_tmp_181 = left_node.keyvalue;
			KeyValue<t__T, T> __tmp169 = f_tmp_181;
			t__T[] f_tmp_182 = __tmp169.key;
			t__T[] __tmp170 = f_tmp_182;
			KeyValue<t__T, T> f_tmp_183 = right_node.keyvalue;
			KeyValue<t__T, T> __tmp171 = f_tmp_183;
			t__T[] f_tmp_184 = __tmp171.key;
			t__T[] __tmp172 = f_tmp_184;
			t__T f_tmp_185 = intLib.not(intLib.leq(__tmp170, __tmp172));
			t__T __tmp173 = f_tmp_185;
			t__T f_tmp_186 = intLib.and(__tmp154,__tmp173);
			t__T __tmp174 = f_tmp_186;
			KeyValue<t__T, T> f_tmp_187 = left_node.keyvalue;
			KeyValue<t__T, T> __tmp175 = f_tmp_187;
			t__T[] f_tmp_188 = __tmp175.key;
			t__T[] __tmp176 = f_tmp_188;
			KeyValue<t__T, T> f_tmp_189 = top_node.keyvalue;
			KeyValue<t__T, T> __tmp177 = f_tmp_189;
			t__T[] f_tmp_190 = __tmp177.key;
			t__T[] __tmp178 = f_tmp_190;
			t__T f_tmp_191 = intLib.not(intLib.leq(__tmp176, __tmp178));
			t__T __tmp179 = f_tmp_191;
			t__T f_tmp_192 = intLib.and(__tmp174,__tmp179);
			t__T __tmp180 = f_tmp_192;
			KeyValue<t__T, T> f_tmp_193 = top_node.keyvalue;
			KeyValue<t__T, T> __tmp181 = f_tmp_193;
			KeyValue<t__T, T> __tmp182 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(tmp_kv.getBits(), __tmp181.getBits(),__tmp180));
			tmp_kv = __tmp182;
			KeyValue<t__T, T> f_tmp_195 = left_node.keyvalue;
			KeyValue<t__T, T> __tmp183 = f_tmp_195;
			KeyValue<t__T, T> f_tmp_196 = top_node.keyvalue;
			KeyValue<t__T, T> __tmp184 = f_tmp_196;
			KeyValue<t__T, T> __tmp185 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(__tmp184.getBits(), __tmp183.getBits(),__tmp180));
			top_node.keyvalue = __tmp185;
			KeyValue<t__T, T> f_tmp_198 = left_node.keyvalue;
			KeyValue<t__T, T> __tmp186 = f_tmp_198;
			KeyValue<t__T, T> __tmp187 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(__tmp186.getBits(), tmp_kv.getBits(),__tmp180));
			left_node.keyvalue = __tmp187;
			boolean f_tmp_200 = true;
			boolean __tmp188 = f_tmp_200;
			t__T f_tmp_202 = env.inputOfAlice(__tmp188);
			t__T __tmp189 = intLib.mux(go_left, f_tmp_202,__tmp180);
			go_left = __tmp189;
			t__T f_tmp_203 = intLib.not(__tmp173);
			t__T __tmp190 = f_tmp_203;
			t__T f_tmp_204 = intLib.and(__tmp154,__tmp190);
			t__T __tmp191 = f_tmp_204;
			KeyValue<t__T, T> f_tmp_205 = right_node.keyvalue;
			KeyValue<t__T, T> __tmp192 = f_tmp_205;
			t__T[] f_tmp_206 = __tmp192.key;
			t__T[] __tmp193 = f_tmp_206;
			KeyValue<t__T, T> f_tmp_207 = top_node.keyvalue;
			KeyValue<t__T, T> __tmp194 = f_tmp_207;
			t__T[] f_tmp_208 = __tmp194.key;
			t__T[] __tmp195 = f_tmp_208;
			t__T f_tmp_209 = intLib.not(intLib.leq(__tmp193, __tmp195));
			t__T __tmp196 = f_tmp_209;
			t__T f_tmp_210 = intLib.and(__tmp191,__tmp196);
			t__T __tmp197 = f_tmp_210;
			KeyValue<t__T, T> f_tmp_211 = top_node.keyvalue;
			KeyValue<t__T, T> __tmp198 = f_tmp_211;
			KeyValue<t__T, T> __tmp199 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(tmp_kv.getBits(), __tmp198.getBits(),__tmp197));
			tmp_kv = __tmp199;
			KeyValue<t__T, T> f_tmp_213 = right_node.keyvalue;
			KeyValue<t__T, T> __tmp200 = f_tmp_213;
			KeyValue<t__T, T> f_tmp_214 = top_node.keyvalue;
			KeyValue<t__T, T> __tmp201 = f_tmp_214;
			KeyValue<t__T, T> __tmp202 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(__tmp201.getBits(), __tmp200.getBits(),__tmp197));
			top_node.keyvalue = __tmp202;
			KeyValue<t__T, T> f_tmp_216 = right_node.keyvalue;
			KeyValue<t__T, T> __tmp203 = f_tmp_216;
			KeyValue<t__T, T> __tmp204 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(__tmp203.getBits(), tmp_kv.getBits(),__tmp197));
			right_node.keyvalue = __tmp204;
			boolean f_tmp_218 = false;
			boolean __tmp205 = f_tmp_218;
			t__T f_tmp_220 = env.inputOfAlice(__tmp205);
			t__T __tmp206 = intLib.mux(go_left, f_tmp_220,__tmp197);
			go_left = __tmp206;
			t__T __tmp208 = go_left;
			t__T f_tmp_221 = intLib.and(__tmp154,__tmp208);
			t__T __tmp209 = f_tmp_221;
			PriorityQueueNode<t__T, T> __tmp210 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(node_to_use.getBits(), left_node.getBits(),__tmp209));
			node_to_use = __tmp210;
			NodeId<t__T> f_tmp_223 = top_node.left;
			NodeId<t__T> __tmp211 = f_tmp_223;
			t__T[] f_tmp_224 = __tmp211.id;
			t__T[] __tmp212 = f_tmp_224;
			t__T[] __tmp213 = intLib.mux(id_to_use, __tmp212,__tmp209);
			id_to_use = __tmp213;
			t__T f_tmp_226 = intLib.not(__tmp208);
			t__T __tmp214 = f_tmp_226;
			t__T f_tmp_227 = intLib.and(__tmp154,__tmp214);
			t__T __tmp215 = f_tmp_227;
			PriorityQueueNode<t__T, T> __tmp216 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(node_to_use.getBits(), right_node.getBits(),__tmp215));
			node_to_use = __tmp216;
			NodeId<t__T> f_tmp_229 = top_node.right;
			NodeId<t__T> __tmp217 = f_tmp_229;
			t__T[] f_tmp_230 = __tmp217.id;
			t__T[] __tmp218 = f_tmp_230;
			t__T[] __tmp219 = intLib.mux(id_to_use, __tmp218,__tmp215);
			id_to_use = __tmp219;
			t__T __tmp221 = dummy_bit;
			t__T[] f_tmp_232 = this.size;
			t__T[] __tmp222 = f_tmp_232;
			int f_tmp_233 = 1;
			int __tmp223 = f_tmp_233;
			t__T[] f_tmp_234 = intLib.rightPublicShift(__tmp222, __tmp223);
			t__T[] __tmp224 = f_tmp_234;
			t__T f_tmp_235 = intLib.leq(top_id, __tmp224);
			t__T __tmp225 = f_tmp_235;
			t__T f_tmp_236 = intLib.and(__tmp221,__tmp225);
			t__T __tmp226 = f_tmp_236;
			t__T f_tmp_237 = intLib.and(__tmp154,__tmp226);
			t__T __tmp227 = f_tmp_237;
			boolean f_tmp_238 = true;
			boolean __tmp228 = f_tmp_238;
			t__T f_tmp_240 = env.inputOfAlice(__tmp228);
			t__T __tmp229 = intLib.mux(newdummy_bit, f_tmp_240,__tmp227);
			newdummy_bit = __tmp229;
			t__T f_tmp_241 = intLib.not(__tmp226);
			t__T __tmp230 = f_tmp_241;
			t__T f_tmp_242 = intLib.and(__tmp154,__tmp230);
			t__T __tmp231 = f_tmp_242;
			boolean f_tmp_243 = false;
			boolean __tmp232 = f_tmp_243;
			t__T f_tmp_245 = env.inputOfAlice(__tmp232);
			t__T __tmp233 = intLib.mux(newdummy_bit, f_tmp_245,__tmp231);
			newdummy_bit = __tmp233;
			int f_tmp_246 = 1;
			int __tmp234 = f_tmp_246;
			int f_tmp_247 = level + __tmp234;
			int __tmp235 = f_tmp_247;
			t__T[] f_tmp_248 = this.heapify(id_to_use, node_to_use, __tmp235, newdummy_bit);
			t__T[] __tmp236 = f_tmp_248;
			t__T[] __tmp237 = intLib.mux(child_iter, __tmp236,__tmp154);
			child_iter = __tmp237;
			NodeId<t__T> f_tmp_250 = top_node.left;
			NodeId<t__T> __tmp238 = f_tmp_250;
			t__T[] f_tmp_251 = __tmp238.id;
			t__T[] __tmp239 = f_tmp_251;
			t__T[] __tmp240 = intLib.mux(id_to_use, __tmp239,__tmp154);
			id_to_use = __tmp240;
			PriorityQueueNode<t__T, T> __tmp241 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(node_to_use.getBits(), left_node.getBits(),__tmp154));
			node_to_use = __tmp241;
			t__T __tmp243 = go_left;
			t__T f_tmp_254 = intLib.and(__tmp154,__tmp243);
			t__T __tmp244 = f_tmp_254;
			NodeId<t__T> f_tmp_255 = top_node.left;
			NodeId<t__T> __tmp245 = f_tmp_255;
			t__T[] f_tmp_256 = __tmp245.pos;
			t__T[] __tmp246 = f_tmp_256;
			t__T[] __tmp247 = intLib.mux(__tmp246, child_iter,__tmp244);
			__tmp245.pos = __tmp247;
			int __tmp248 = m;
			t__T[] f_tmp_258 = intLib.randBools(__tmp248);
			t__T[] __tmp249 = f_tmp_258;
			NodeId<t__T> f_tmp_259 = top_node.right;
			NodeId<t__T> __tmp250 = f_tmp_259;
			t__T[] f_tmp_260 = __tmp250.pos;
			t__T[] __tmp251 = f_tmp_260;
			t__T[] __tmp252 = intLib.mux(__tmp251, __tmp249,__tmp244);
			__tmp250.pos = __tmp252;
			NodeId<t__T> f_tmp_262 = top_node.right;
			NodeId<t__T> __tmp253 = f_tmp_262;
			t__T[] f_tmp_263 = __tmp253.id;
			t__T[] __tmp254 = f_tmp_263;
			t__T[] __tmp255 = intLib.mux(id_to_use, __tmp254,__tmp244);
			id_to_use = __tmp255;
			NodeId<t__T> f_tmp_265 = top_node.right;
			NodeId<t__T> __tmp256 = f_tmp_265;
			t__T[] f_tmp_266 = __tmp256.pos;
			t__T[] __tmp257 = f_tmp_266;
			t__T[] __tmp258 = intLib.mux(pos_to_use, __tmp257,__tmp244);
			pos_to_use = __tmp258;
			PriorityQueueNode<t__T, T> __tmp259 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(node_to_use.getBits(), right_node.getBits(),__tmp244));
			node_to_use = __tmp259;
			t__T f_tmp_269 = intLib.not(__tmp243);
			t__T __tmp260 = f_tmp_269;
			t__T f_tmp_270 = intLib.and(__tmp154,__tmp260);
			t__T __tmp261 = f_tmp_270;
			NodeId<t__T> f_tmp_271 = top_node.right;
			NodeId<t__T> __tmp262 = f_tmp_271;
			t__T[] f_tmp_272 = __tmp262.pos;
			t__T[] __tmp263 = f_tmp_272;
			t__T[] __tmp264 = intLib.mux(__tmp263, child_iter,__tmp261);
			__tmp262.pos = __tmp264;
			int __tmp265 = m;
			t__T[] f_tmp_274 = intLib.randBools(__tmp265);
			t__T[] __tmp266 = f_tmp_274;
			NodeId<t__T> f_tmp_275 = top_node.left;
			NodeId<t__T> __tmp267 = f_tmp_275;
			t__T[] f_tmp_276 = __tmp267.pos;
			t__T[] __tmp268 = f_tmp_276;
			t__T[] __tmp269 = intLib.mux(__tmp268, __tmp266,__tmp261);
			__tmp267.pos = __tmp269;
			NodeId<t__T> f_tmp_278 = top_node.left;
			NodeId<t__T> __tmp270 = f_tmp_278;
			t__T[] f_tmp_279 = __tmp270.pos;
			t__T[] __tmp271 = f_tmp_279;
			t__T[] __tmp272 = intLib.mux(pos_to_use, __tmp271,__tmp261);
			pos_to_use = __tmp272;
			CircuitOram<t__T> f_tmp_281 = this.poram;
			CircuitOram<t__T> __tmp273 = f_tmp_281;
			__tmp273.conditionalPutBack(id_to_use, pos_to_use, node_to_use.getBits(), __tmp154);
			t__T[] f_tmp_283 = this.size;
			t__T[] __tmp275 = f_tmp_283;
			t__T f_tmp_284 = intLib.leq(top_id, __tmp275);
			t__T __tmp276 = f_tmp_284;
			t__T f_tmp_285 = intLib.and(__tmp149,__tmp276);
			t__T __tmp277 = f_tmp_285;
			int __tmp278 = m;
			t__T[] f_tmp_286 = intLib.randBools(__tmp278);
			t__T[] __tmp279 = f_tmp_286;
			t__T[] __tmp280 = intLib.mux(ret, __tmp279,__tmp277);
			ret = __tmp280;
			CircuitOram<t__T> f_tmp_288 = this.poram;
			CircuitOram<t__T> __tmp281 = f_tmp_288;
			__tmp281.conditionalPutBack(top_id, ret, top_node.getBits(), __tmp277);
		} else {
		}
		return ret;

	}
	public PriorityQueueNode<t__T, T> get_last(NodeId<t__T> top, int level, t__T dummy_bit) throws Exception {
		PriorityQueueNode<t__T, T> ret = new PriorityQueueNode<t__T, T>(env, m, factoryT);
		t__T newdummy_bit = env.inputOfAlice(false);
		PriorityQueueNode<t__T, T> node = new PriorityQueueNode<t__T, T>(env, m, factoryT);
		PriorityQueueNode<t__T, T> child = new PriorityQueueNode<t__T, T>(env, m, factoryT);
		t__T go_left = env.inputOfAlice(false);
		NodeId<t__T> next = new NodeId<t__T>(env, m);
		boolean f_tmp_290 = false;
		boolean __tmp283 = f_tmp_290;
		newdummy_bit = env.inputOfAlice(__tmp283);
		int __tmp284 = m;
		boolean f_tmp_291 = level < __tmp284;
		boolean __tmp285 = f_tmp_291;
		if(__tmp285) {
			t__T __tmp287 = dummy_bit;
			t__T[] f_tmp_292 = top.id;
			t__T[] __tmp288 = f_tmp_292;
			t__T[] f_tmp_293 = this.size;
			t__T[] __tmp289 = f_tmp_293;
			t__T f_tmp_294 = intLib.leq(__tmp288, __tmp289);
			t__T __tmp290 = f_tmp_294;
			t__T f_tmp_295 = intLib.and(__tmp287,__tmp290);
			t__T __tmp291 = f_tmp_295;
			t__T[] f_tmp_296 = top.id;
			t__T[] __tmp292 = f_tmp_296;
			t__T[] f_tmp_297 = top.pos;
			t__T[] __tmp293 = f_tmp_297;
			CircuitOram<t__T> f_tmp_298 = this.poram;
			CircuitOram<t__T> __tmp294 = f_tmp_298;
			PriorityQueueNode<t__T, T> f_tmp_299 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(__tmp294.conditionalReadAndRemove(__tmp292, __tmp293, __tmp291));
			PriorityQueueNode<t__T, T> __tmp295 = f_tmp_299;
			PriorityQueueNode<t__T, T> __tmp296 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(node.getBits(), __tmp295.getBits(),__tmp291));
			node = __tmp296;
			t__T[] f_tmp_301 = top.id;
			t__T[] __tmp297 = f_tmp_301;
			t__T[] f_tmp_302 = this.size;
			t__T[] __tmp298 = f_tmp_302;
			t__T f_tmp_303 = intLib.eq(__tmp297, __tmp298);
			t__T __tmp299 = f_tmp_303;
			t__T f_tmp_304 = intLib.and(__tmp291,__tmp299);
			t__T __tmp300 = f_tmp_304;
			PriorityQueueNode<t__T, T> __tmp301 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(ret.getBits(), node.getBits(),__tmp300));
			ret = __tmp301;
			t__T f_tmp_306 = intLib.not(__tmp299);
			t__T __tmp302 = f_tmp_306;
			t__T f_tmp_307 = intLib.and(__tmp291,__tmp302);
			t__T __tmp303 = f_tmp_307;
			t__T[] f_tmp_308 = this.size;
			t__T[] __tmp304 = f_tmp_308;
			t__T f_tmp_309 = this.should_go_left(__tmp304, level);
			t__T __tmp305 = f_tmp_309;
			t__T __tmp306 = intLib.mux(go_left, __tmp305,__tmp303);
			go_left = __tmp306;
			NodeId<t__T> f_tmp_311 = node.right;
			NodeId<t__T> __tmp307 = f_tmp_311;
			NodeId<t__T> __tmp308 = new NodeId<t__T>(env, m).newObj(intLib.mux(next.getBits(), __tmp307.getBits(),__tmp303));
			next = __tmp308;
			t__T __tmp310 = go_left;
			t__T f_tmp_313 = intLib.and(__tmp303,__tmp310);
			t__T __tmp311 = f_tmp_313;
			NodeId<t__T> f_tmp_314 = node.left;
			NodeId<t__T> __tmp312 = f_tmp_314;
			NodeId<t__T> __tmp313 = new NodeId<t__T>(env, m).newObj(intLib.mux(next.getBits(), __tmp312.getBits(),__tmp311));
			next = __tmp313;
			t__T __tmp315 = dummy_bit;
			t__T[] f_tmp_316 = top.id;
			t__T[] __tmp316 = f_tmp_316;
			t__T[] f_tmp_317 = this.size;
			t__T[] __tmp317 = f_tmp_317;
			t__T f_tmp_318 = intLib.not(intLib.geq(__tmp316, __tmp317));
			t__T __tmp318 = f_tmp_318;
			t__T f_tmp_319 = intLib.and(__tmp315,__tmp318);
			t__T __tmp319 = f_tmp_319;
			t__T f_tmp_320 = intLib.and(__tmp303,__tmp319);
			t__T __tmp320 = f_tmp_320;
			boolean f_tmp_321 = true;
			boolean __tmp321 = f_tmp_321;
			t__T f_tmp_323 = env.inputOfAlice(__tmp321);
			t__T __tmp322 = intLib.mux(newdummy_bit, f_tmp_323,__tmp320);
			newdummy_bit = __tmp322;
			t__T f_tmp_324 = intLib.not(__tmp319);
			t__T __tmp323 = f_tmp_324;
			t__T f_tmp_325 = intLib.and(__tmp303,__tmp323);
			t__T __tmp324 = f_tmp_325;
			boolean f_tmp_326 = false;
			boolean __tmp325 = f_tmp_326;
			t__T f_tmp_328 = env.inputOfAlice(__tmp325);
			t__T __tmp326 = intLib.mux(newdummy_bit, f_tmp_328,__tmp324);
			newdummy_bit = __tmp326;
			int f_tmp_329 = 1;
			int __tmp327 = f_tmp_329;
			int f_tmp_330 = level + __tmp327;
			int __tmp328 = f_tmp_330;
			PriorityQueueNode<t__T, T> f_tmp_331 = this.get_last(next, __tmp328, newdummy_bit);
			PriorityQueueNode<t__T, T> __tmp329 = f_tmp_331;
			PriorityQueueNode<t__T, T> __tmp330 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(child.getBits(), __tmp329.getBits(),__tmp303));
			child = __tmp330;
			t__T __tmp332 = go_left;
			t__T f_tmp_333 = intLib.and(__tmp303,__tmp332);
			t__T __tmp333 = f_tmp_333;
			NodeId<t__T> f_tmp_334 = child.left;
			NodeId<t__T> __tmp334 = f_tmp_334;
			t__T[] f_tmp_335 = __tmp334.pos;
			t__T[] __tmp335 = f_tmp_335;
			NodeId<t__T> f_tmp_336 = node.left;
			NodeId<t__T> __tmp336 = f_tmp_336;
			t__T[] f_tmp_337 = __tmp336.pos;
			t__T[] __tmp337 = f_tmp_337;
			t__T[] __tmp338 = intLib.mux(__tmp337, __tmp335,__tmp333);
			__tmp336.pos = __tmp338;
			t__T f_tmp_339 = intLib.not(__tmp332);
			t__T __tmp339 = f_tmp_339;
			t__T f_tmp_340 = intLib.and(__tmp303,__tmp339);
			t__T __tmp340 = f_tmp_340;
			NodeId<t__T> f_tmp_341 = child.left;
			NodeId<t__T> __tmp341 = f_tmp_341;
			t__T[] f_tmp_342 = __tmp341.pos;
			t__T[] __tmp342 = f_tmp_342;
			NodeId<t__T> f_tmp_343 = node.right;
			NodeId<t__T> __tmp343 = f_tmp_343;
			t__T[] f_tmp_344 = __tmp343.pos;
			t__T[] __tmp344 = f_tmp_344;
			t__T[] __tmp345 = intLib.mux(__tmp344, __tmp342,__tmp340);
			__tmp343.pos = __tmp345;
			int __tmp346 = m;
			t__T[] f_tmp_346 = intLib.randBools(__tmp346);
			t__T[] __tmp347 = f_tmp_346;
			t__T[] f_tmp_347 = top.pos;
			t__T[] __tmp348 = f_tmp_347;
			t__T[] __tmp349 = intLib.mux(__tmp348, __tmp347,__tmp303);
			top.pos = __tmp349;
			t__T[] f_tmp_349 = top.id;
			t__T[] __tmp350 = f_tmp_349;
			t__T[] f_tmp_350 = top.pos;
			t__T[] __tmp351 = f_tmp_350;
			CircuitOram<t__T> f_tmp_351 = this.poram;
			CircuitOram<t__T> __tmp352 = f_tmp_351;
			__tmp352.conditionalPutBack(__tmp350, __tmp351, node.getBits(), __tmp303);
			t__T[] f_tmp_353 = top.pos;
			t__T[] __tmp354 = f_tmp_353;
			NodeId<t__T> f_tmp_354 = child.left;
			NodeId<t__T> __tmp355 = f_tmp_354;
			t__T[] f_tmp_355 = __tmp355.pos;
			t__T[] __tmp356 = f_tmp_355;
			t__T[] __tmp357 = intLib.mux(__tmp356, __tmp354,__tmp303);
			__tmp355.pos = __tmp357;
			PriorityQueueNode<t__T, T> __tmp358 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(ret.getBits(), child.getBits(),__tmp303));
			ret = __tmp358;
		} else {
		}
		return ret;

	}
	public void insert(KeyValue<t__T, T> kv, t__T dummy_bit) throws Exception {
		KeyValue<t__T, T> parent_kv = new KeyValue<t__T, T>(env, m, factoryT);
		int f_tmp_358 = 1;
		int __tmp359 = f_tmp_358;
		int f_tmp_359 = 15;
		int __tmp360 = f_tmp_359;
		int f_tmp_360 = 1;
		int __tmp361 = f_tmp_360;
		int f_tmp_361 = __tmp360 - __tmp361;
		int __tmp362 = f_tmp_361;
		int f_tmp_362 = __tmp359 << __tmp362;
		int __tmp363 = f_tmp_362;
		t__T[] f_tmp_363 = env.inputOfAlice(Utils.fromInt(__tmp363, 32));
		parent_kv.key = f_tmp_363;
		t__T __tmp365 = dummy_bit;
		t__T[] f_tmp_364 = this.size;
		t__T[] __tmp366 = f_tmp_364;
		int f_tmp_365 = 1;
		int __tmp367 = f_tmp_365;
		t__T[] f_tmp_367 = env.inputOfAlice(Utils.fromInt(__tmp367, m));
		t__T[] f_tmp_366 = intLib.add(__tmp366,f_tmp_367);
		t__T[] __tmp368 = f_tmp_366;
		t__T[] f_tmp_368 = this.size;
		t__T[] __tmp369 = f_tmp_368;
		t__T[] __tmp370 = intLib.mux(__tmp369, __tmp368,__tmp365);
		this.size = __tmp370;
		NodeId<t__T> f_tmp_370 = this.root;
		NodeId<t__T> __tmp371 = f_tmp_370;
		t__T[] f_tmp_371 = __tmp371.id;
		t__T[] __tmp372 = f_tmp_371;
		NodeId<t__T> f_tmp_372 = this.root;
		NodeId<t__T> __tmp373 = f_tmp_372;
		t__T[] f_tmp_373 = __tmp373.pos;
		t__T[] __tmp374 = f_tmp_373;
		int f_tmp_374 = 1;
		int __tmp375 = f_tmp_374;
		t__T[] f_tmp_375 = this.insert_internal(kv, parent_kv, __tmp372, __tmp374, __tmp375, dummy_bit);
		t__T[] __tmp376 = f_tmp_375;
		NodeId<t__T> f_tmp_376 = this.root;
		NodeId<t__T> __tmp377 = f_tmp_376;
		t__T[] f_tmp_377 = __tmp377.pos;
		t__T[] __tmp378 = f_tmp_377;
		t__T[] __tmp379 = intLib.mux(__tmp378, __tmp376,__tmp365);
		__tmp377.pos = __tmp379;

	}
	public t__T[] insert_internal(KeyValue<t__T, T> kv, KeyValue<t__T, T> parent_kv, t__T[] iter_id, t__T[] iter_pos, int level, t__T dummy_bit) throws Exception {
		t__T[] ret = intLib.randBools(m);
		t__T newdummy_bit = env.inputOfAlice(false);
		PriorityQueueNode<t__T, T> node = new PriorityQueueNode<t__T, T>(env, m, factoryT);
		t__T go_left = env.inputOfAlice(false);
		NodeId<t__T> next = new NodeId<t__T>(env, m);
		t__T[] newId = intLib.randBools(m);
		boolean f_tmp_379 = false;
		boolean __tmp380 = f_tmp_379;
		newdummy_bit = env.inputOfAlice(__tmp380);
		int __tmp381 = m;
		boolean f_tmp_380 = level < __tmp381;
		boolean __tmp382 = f_tmp_380;
		if(__tmp382) {
			t__T __tmp384 = dummy_bit;
			t__T[] f_tmp_381 = this.size;
			t__T[] __tmp385 = f_tmp_381;
			t__T f_tmp_382 = intLib.leq(iter_id, __tmp385);
			t__T __tmp386 = f_tmp_382;
			t__T f_tmp_383 = intLib.and(__tmp384,__tmp386);
			t__T __tmp387 = f_tmp_383;
			t__T[] f_tmp_384 = this.size;
			t__T[] __tmp388 = f_tmp_384;
			t__T f_tmp_385 = intLib.eq(iter_id, __tmp388);
			t__T __tmp389 = f_tmp_385;
			t__T f_tmp_386 = intLib.and(__tmp387,__tmp389);
			t__T __tmp390 = f_tmp_386;
			KeyValue<t__T, T> f_tmp_387 = node.keyvalue;
			KeyValue<t__T, T> __tmp391 = f_tmp_387;
			KeyValue<t__T, T> __tmp392 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(__tmp391.getBits(), kv.getBits(),__tmp390));
			node.keyvalue = __tmp392;
			t__T[] f_tmp_389 = parent_kv.key;
			t__T[] __tmp393 = f_tmp_389;
			t__T[] f_tmp_390 = kv.key;
			t__T[] __tmp394 = f_tmp_390;
			t__T f_tmp_391 = intLib.not(intLib.geq(__tmp393, __tmp394));
			t__T __tmp395 = f_tmp_391;
			t__T f_tmp_392 = intLib.and(__tmp390,__tmp395);
			t__T __tmp396 = f_tmp_392;
			KeyValue<t__T, T> f_tmp_393 = node.keyvalue;
			KeyValue<t__T, T> __tmp397 = f_tmp_393;
			KeyValue<t__T, T> __tmp398 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(__tmp397.getBits(), parent_kv.getBits(),__tmp396));
			node.keyvalue = __tmp398;
			t__T f_tmp_395 = intLib.not(__tmp389);
			t__T __tmp399 = f_tmp_395;
			t__T f_tmp_396 = intLib.and(__tmp387,__tmp399);
			t__T __tmp400 = f_tmp_396;
			CircuitOram<t__T> f_tmp_397 = this.poram;
			CircuitOram<t__T> __tmp401 = f_tmp_397;
			PriorityQueueNode<t__T, T> f_tmp_398 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(__tmp401.conditionalReadAndRemove(iter_id, iter_pos, __tmp400));
			PriorityQueueNode<t__T, T> __tmp402 = f_tmp_398;
			PriorityQueueNode<t__T, T> __tmp403 = new PriorityQueueNode<t__T, T>(env, m, factoryT).newObj(intLib.mux(node.getBits(), __tmp402.getBits(),__tmp400));
			node = __tmp403;
			t__T[] f_tmp_400 = this.size;
			t__T[] __tmp404 = f_tmp_400;
			t__T f_tmp_401 = this.should_go_left(__tmp404, level);
			t__T __tmp405 = f_tmp_401;
			t__T __tmp406 = intLib.mux(go_left, __tmp405,__tmp400);
			go_left = __tmp406;
			NodeId<t__T> f_tmp_403 = node.right;
			NodeId<t__T> __tmp407 = f_tmp_403;
			NodeId<t__T> __tmp408 = new NodeId<t__T>(env, m).newObj(intLib.mux(next.getBits(), __tmp407.getBits(),__tmp400));
			next = __tmp408;
			t__T __tmp410 = go_left;
			t__T f_tmp_405 = intLib.and(__tmp400,__tmp410);
			t__T __tmp411 = f_tmp_405;
			NodeId<t__T> f_tmp_406 = node.left;
			NodeId<t__T> __tmp412 = f_tmp_406;
			NodeId<t__T> __tmp413 = new NodeId<t__T>(env, m).newObj(intLib.mux(next.getBits(), __tmp412.getBits(),__tmp411));
			next = __tmp413;
			t__T __tmp415 = dummy_bit;
			t__T[] f_tmp_408 = this.size;
			t__T[] __tmp416 = f_tmp_408;
			t__T f_tmp_409 = intLib.not(intLib.geq(iter_id, __tmp416));
			t__T __tmp417 = f_tmp_409;
			t__T f_tmp_410 = intLib.and(__tmp415,__tmp417);
			t__T __tmp418 = f_tmp_410;
			t__T f_tmp_411 = intLib.and(__tmp400,__tmp418);
			t__T __tmp419 = f_tmp_411;
			boolean f_tmp_412 = true;
			boolean __tmp420 = f_tmp_412;
			t__T f_tmp_414 = env.inputOfAlice(__tmp420);
			t__T __tmp421 = intLib.mux(newdummy_bit, f_tmp_414,__tmp419);
			newdummy_bit = __tmp421;
			t__T f_tmp_415 = intLib.not(__tmp418);
			t__T __tmp422 = f_tmp_415;
			t__T f_tmp_416 = intLib.and(__tmp400,__tmp422);
			t__T __tmp423 = f_tmp_416;
			boolean f_tmp_417 = false;
			boolean __tmp424 = f_tmp_417;
			t__T f_tmp_419 = env.inputOfAlice(__tmp424);
			t__T __tmp425 = intLib.mux(newdummy_bit, f_tmp_419,__tmp423);
			newdummy_bit = __tmp425;
			KeyValue<t__T, T> f_tmp_420 = node.keyvalue;
			KeyValue<t__T, T> __tmp426 = f_tmp_420;
			t__T[] f_tmp_421 = next.id;
			t__T[] __tmp427 = f_tmp_421;
			t__T[] f_tmp_422 = next.pos;
			t__T[] __tmp428 = f_tmp_422;
			int f_tmp_423 = 1;
			int __tmp429 = f_tmp_423;
			int f_tmp_424 = level + __tmp429;
			int __tmp430 = f_tmp_424;
			t__T[] f_tmp_425 = this.insert_internal(kv, __tmp426, __tmp427, __tmp428, __tmp430, newdummy_bit);
			t__T[] __tmp431 = f_tmp_425;
			t__T[] __tmp432 = intLib.mux(newId, __tmp431,__tmp400);
			newId = __tmp432;
			KeyValue<t__T, T> f_tmp_427 = node.keyvalue;
			KeyValue<t__T, T> __tmp433 = f_tmp_427;
			t__T[] f_tmp_428 = __tmp433.key;
			t__T[] __tmp434 = f_tmp_428;
			t__T[] f_tmp_429 = kv.key;
			t__T[] __tmp435 = f_tmp_429;
			t__T f_tmp_430 = intLib.not(intLib.geq(__tmp434, __tmp435));
			t__T __tmp436 = f_tmp_430;
			t__T f_tmp_431 = intLib.and(__tmp400,__tmp436);
			t__T __tmp437 = f_tmp_431;
			KeyValue<t__T, T> f_tmp_432 = node.keyvalue;
			KeyValue<t__T, T> __tmp438 = f_tmp_432;
			KeyValue<t__T, T> __tmp439 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(__tmp438.getBits(), kv.getBits(),__tmp437));
			node.keyvalue = __tmp439;
			t__T[] f_tmp_434 = kv.key;
			t__T[] __tmp440 = f_tmp_434;
			t__T[] f_tmp_435 = parent_kv.key;
			t__T[] __tmp441 = f_tmp_435;
			t__T f_tmp_436 = intLib.not(intLib.leq(__tmp440, __tmp441));
			t__T __tmp442 = f_tmp_436;
			t__T f_tmp_437 = intLib.and(__tmp437,__tmp442);
			t__T __tmp443 = f_tmp_437;
			KeyValue<t__T, T> f_tmp_438 = node.keyvalue;
			KeyValue<t__T, T> __tmp444 = f_tmp_438;
			KeyValue<t__T, T> __tmp445 = new KeyValue<t__T, T>(env, m, factoryT).newObj(intLib.mux(__tmp444.getBits(), parent_kv.getBits(),__tmp443));
			node.keyvalue = __tmp445;
			t__T __tmp447 = go_left;
			t__T f_tmp_440 = intLib.and(__tmp400,__tmp447);
			t__T __tmp448 = f_tmp_440;
			NodeId<t__T> f_tmp_441 = node.left;
			NodeId<t__T> __tmp449 = f_tmp_441;
			t__T[] f_tmp_442 = __tmp449.pos;
			t__T[] __tmp450 = f_tmp_442;
			t__T[] __tmp451 = intLib.mux(__tmp450, newId,__tmp448);
			__tmp449.pos = __tmp451;
			t__T f_tmp_444 = intLib.not(__tmp447);
			t__T __tmp452 = f_tmp_444;
			t__T f_tmp_445 = intLib.and(__tmp400,__tmp452);
			t__T __tmp453 = f_tmp_445;
			NodeId<t__T> f_tmp_446 = node.right;
			NodeId<t__T> __tmp454 = f_tmp_446;
			t__T[] f_tmp_447 = __tmp454.pos;
			t__T[] __tmp455 = f_tmp_447;
			t__T[] __tmp456 = intLib.mux(__tmp455, newId,__tmp453);
			__tmp454.pos = __tmp456;
			int f_tmp_449 = 1;
			int __tmp457 = f_tmp_449;
			t__T[] f_tmp_450 = intLib.leftPublicShift(iter_id, __tmp457);
			t__T[] __tmp458 = f_tmp_450;
			NodeId<t__T> f_tmp_451 = node.left;
			NodeId<t__T> __tmp459 = f_tmp_451;
			t__T[] f_tmp_452 = __tmp459.id;
			t__T[] __tmp460 = f_tmp_452;
			t__T[] __tmp461 = intLib.mux(__tmp460, __tmp458,__tmp387);
			__tmp459.id = __tmp461;
			NodeId<t__T> f_tmp_454 = node.left;
			NodeId<t__T> __tmp462 = f_tmp_454;
			t__T[] f_tmp_455 = __tmp462.id;
			t__T[] __tmp463 = f_tmp_455;
			int f_tmp_456 = 1;
			int __tmp464 = f_tmp_456;
			t__T[] f_tmp_458 = env.inputOfAlice(Utils.fromInt(__tmp464, m));
			t__T[] f_tmp_457 = intLib.add(__tmp463,f_tmp_458);
			t__T[] __tmp465 = f_tmp_457;
			NodeId<t__T> f_tmp_459 = node.right;
			NodeId<t__T> __tmp466 = f_tmp_459;
			t__T[] f_tmp_460 = __tmp466.id;
			t__T[] __tmp467 = f_tmp_460;
			t__T[] __tmp468 = intLib.mux(__tmp467, __tmp465,__tmp387);
			__tmp466.id = __tmp468;
			int __tmp469 = m;
			t__T[] f_tmp_462 = intLib.randBools(__tmp469);
			t__T[] __tmp470 = f_tmp_462;
			t__T[] __tmp471 = intLib.mux(ret, __tmp470,__tmp387);
			ret = __tmp471;
			CircuitOram<t__T> f_tmp_464 = this.poram;
			CircuitOram<t__T> __tmp472 = f_tmp_464;
			__tmp472.conditionalPutBack(iter_id, ret, node.getBits(), __tmp387);
		} else {
		}
		return ret;

	}
}
