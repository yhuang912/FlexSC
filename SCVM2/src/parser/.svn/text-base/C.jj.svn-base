PARSER_BEGIN(CParser)

package parser;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import util.Pair;
import ast.ASTFunction;
import ast.ASTFunctionDef;
import ast.ASTFunctionNative;
import ast.ASTProgram;
import ast.expr.ASTAndPredicate;
import ast.expr.ASTArrayExpression;
import ast.expr.ASTBinaryExpression;
import ast.expr.ASTBinaryExpression.BOP;
import ast.expr.ASTBinaryPredicate;
import ast.expr.ASTBinaryPredicate.REL_OP;
import ast.expr.ASTConstantExpression;
import ast.expr.ASTExpression;
import ast.expr.ASTFloatConstantExpression;
import ast.expr.ASTFuncExpression;
import ast.expr.ASTLogExpression;
import ast.expr.ASTOrPredicate;
import ast.expr.ASTPredicate;
import ast.expr.ASTRangeExpression;
import ast.expr.ASTRecExpression;
import ast.expr.ASTRecTupleExpression;
import ast.expr.ASTTupleExpression;
import ast.expr.ASTVariableExpression;
import ast.stmt.ASTAssignStatement;
import ast.stmt.ASTFuncStatement;
import ast.stmt.ASTIfStatement;
import ast.stmt.ASTReturnStatement;
import ast.stmt.ASTStatement;
import ast.stmt.ASTWhileStatement;
import ast.type.ASTArrayType;
import ast.type.ASTFloatType;
import ast.type.ASTFunctionType;
import ast.type.ASTIntType;
import ast.type.ASTLabel;
import ast.type.ASTNativeType;
import ast.type.ASTRecType;
import ast.type.ASTRndType;
import ast.type.ASTType;
import ast.type.ASTVariableType;
import ast.type.ASTVoidType;
public class CParser{
    ASTType __type__;
    Map<String, ASTExpression> def = new HashMap<String, ASTExpression>();
    ASTProgram program;
    
	public static ASTProgram parse(String filename) {
		CParser parser = null;
		try {
			parser = new CParser(new java.io.FileInputStream(filename));
			parser.program = new ASTProgram();
			return parser.TranslationUnit();
		}
		catch(java.io.FileNotFoundException e) {
			System.out.println("Error:  File " + filename + " not found.");
			return null;
		} catch (ParseException e) {
			System.out.println("Error: Parsing Error " + e.getMessage());
			return null;
		}
	}
	
  }

PARSER_END(CParser)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*", "/"] (~["*"])* "*")* "/">
//| "#" : PREPROCESSOR_OUTPUT
}

<PREPROCESSOR_OUTPUT> SKIP:
{
     "\n" : DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
 "\\\n"
 |
 "\\\r\n"
 |
 < ~[] >
}


TOKEN : {
 <INTEGER_LITERAL: <DECIMAL_LITERAL> (["l", "L"])? | <HEX_LITERAL> (["l", "L"])? | <OCTAL_LITERAL> (["l", "L"])?>
|  <#DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])*>
|  <#HEX_LITERAL: "0" ["x", "X"] (["0"-"9", "a"-"f", "A"-"F"])+>
|  <INT_TYPE: "int" (["0"-"9"])*>
|  <RND_TYPE: "rnd" (["0"-"9"])*>
|  <FLOAT_TYPE: "float" (["0"-"9"])*>
|  <STRING_TYPE: "string">
|  <#OCTAL_LITERAL: "0" (["0"-"7"])*>
|  <FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f", "F", "d", "D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"]>
|  <#EXPONENT: ["e", "E"] (["+", "-"])? (["0"-"9"])+>
|  <CHARACTER_LITERAL: "\'" (~["\'", "\\", "\n", "\r"] | "\\" (["n", "t", "b", "r", "f", "\\", "\'", "\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'">
|  <STRING_LITERAL: "\"" ( ~["\"", "\\", "\n", "\r"] | "\\" ( ["n", "t", "b", "r", "f", "\\", "\'", "\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n", "\r"] | "\r\n")))* "\"">
}

TOKEN : {
	<WHILE: "while"> |
	<ELSE: "else"> |
	<VOID: "void"> |
	<ALICE: "alice"> |
	<BOB: "bob"> |
	<SECURE: "secure"> |
	<PUBLIC: "public"> |
	<STRUCT: "struct"> |
	<NATIVE: "native"> |
	<DUMMY: "dummy"> |
	<TYPEDEF: "typedef"> |
	<FOR: "for"> |
	<BOT: "bot"> |
	<LOG: "log"> |
	<IF: "if"> |
	<RETURN : "return">
}

TOKEN : {
 <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <#LETTER: ["A"-"Z", "_", "a"-"z"]>
|  <#DIGIT: ["0"-"9"]>
}


ASTExpression RangeAtomicExpression() : 
{
	ASTExpression e;
	Token tok;
}
{	
	e = ConstantExpression() { return e; }
	| LOOKAHEAD(2) "(" e = RangeExpression() ")" { return e; }
 	| tok = <IDENTIFIER> { return new ASTVariableExpression(tok.image); } 
 	| <LOG> "(" e = RangeExpression() ")" { return new ASTLogExpression(e); }
}

ASTExpression AtomicExpression() : 
{
	ASTExpression e, idx, par, bit, rangel, ranger;
	Token v;
	List<ASTType> var;
	List<ASTExpression> bits;
	ASTRecType rt;
}
{	
	e = ConstantExpression() { return e; }
	| LOOKAHEAD(2) "(" e = BIExpression() ")" { return e; }
 	| e = VariableExpression() { var = null; bits = null; }
		(  
			"." v = <IDENTIFIER> { e = new ASTRecExpression(e, v.image); }
			| "[" idx = BIExpression() "]" { e = new ASTArrayExpression(e, idx); }
			| LOOKAHEAD(2)
				(
					"@" { if (bits == null) bits = new ArrayList<ASTExpression>(); }
				      ( v = <IDENTIFIER> { bits.add(new ASTVariableExpression(v.image)); }
					    | "(" bit = BIExpression() ")" { bits.add(bit); }
					    | <LOG>
					    	"(" bit = BIExpression() ")" { bits.add(new ASTLogExpression(bit)); }
					  )
				)*
				[ var = TypeVariablesInExp() ]
			  "(" { e = new ASTFuncExpression(e, bits, var); }
				[
					(
						LOOKAHEAD(2) v = <IDENTIFIER> "=" par = BIExpression()
						{ ((ASTFuncExpression)e).addInputs(v.image, par); }
						| 
						par = BIExpression() 
						{ 
							((ASTFuncExpression)e).addInputs(par); 
						}
					)
					( ","
						(LOOKAHEAD(2) v = <IDENTIFIER> "=" par = BIExpression()
						{
							((ASTFuncExpression)e).addInputs(v.image, par);
						}
						| par = BIExpression() { ((ASTFuncExpression)e).addInputs(par); })
					)*
				]
				")" { bits = null; }
		)* 
	[ 
		LOOKAHEAD(2) "$" { rangel = ranger = null; } rangel = RangeExpression() 
			["~" ranger = RangeExpression()] "$"
			{
				e = new ASTRangeExpression(e, rangel, ranger);
			}
		| ".(" par = Expression() 
			{ 
				if (!(par instanceof ASTTupleExpression)) 
					par = new ASTTupleExpression(par); 
			} 
		  ")" { e = new ASTRecTupleExpression(e, (ASTTupleExpression)par); }
	]
	{ return e; }
}

ASTProgram TranslationUnit() : 
{
	Token name;
	ASTType t;
	ASTFunction f, b; 
}
{
	{
		program = new ASTProgram();	
		def.clear(); 
	}
	(PreDefine())*
	( TypeDefinition() | FunctionDefinition() )* 
	{
		return program;
	}
}

void PreDefine() : 
{
	Token v;
	ASTExpression exp;
}
{
	"#define" v = <IDENTIFIER> exp = Expression()
	{
		System.out.println(v.image+"\t=\t"+exp);
		def.put(v.image, exp);
	}
}

void TypeDefinition() : { }
{
	StructDef()	| TypeDef()
}

List<ASTType> TypeVariablesInExp() :
{
	ASTType tyVar;
	List<ASTType> ret = new ArrayList<ASTType>();
}
{
	"{" tyVar = Type(ASTLabel.Secure) { ret.add(tyVar); } 
		(LOOKAHEAD(2) "," tyVar = Type(ASTLabel.Secure) { ret.add(tyVar); } )* "}" { return ret; }
}

List<ASTType> TypeVariables() :
{
	ASTType tyVar;
	List<ASTType> ret = new ArrayList<ASTType>();
}
{
	"<" tyVar = Type(ASTLabel.Secure) { ret.add(tyVar); } 
		(LOOKAHEAD(2) "," tyVar = Type(ASTLabel.Secure) { ret.add(tyVar); } )* ">" { return ret; }
}

int Constant() : 
{
	Token n;
}
{
 	n = <INTEGER_LITERAL> { return util.Helper.parseInt(n.image); }
}

double FloatConstant() : 
{
	Token n;
}
{
 	n = <FLOATING_POINT_LITERAL> { return Double.parseDouble(n.image); }
}

void StructDef() : 
{
	Token v;
	ASTRecType type;
	ASTType tyVar;
	List<ASTType> var;
}
{
	<STRUCT> v = <IDENTIFIER> { type = new ASTRecType(v.image, ASTLabel.Secure); }
	( "@" v = <IDENTIFIER> { 
							type.bitVariables.add(new ASTVariableExpression(v.image));
							if(!program.typeBitVarDef.containsKey(type.name))
								program.typeBitVarDef.put(type.name, new ArrayList<ASTExpression>());
							program.typeBitVarDef.get(type.name).add(new ASTVariableExpression(v.image)); 
							} )* 
	[ var = TypeVariables() 
		{ type.typeVariables = var; 
		  program.typeVarDef.put(type.name, var); } ] 
	"{" (tyVar = Type(ASTLabel.Secure) v = <IDENTIFIER> 
			{ 
				type.fields.add(v.image); 
				type.fieldsType.put(v.image, tyVar);
			} 
			(
				"," v = <IDENTIFIER> 
				{ 
					type.fields.add(v.image); 
					type.fieldsType.put(v.image, tyVar);
				}
			)* ";" )* 
	"}" ";" { this.program.typeDef.add(new Pair<String, ASTType>(type.name, type)); }
}

void TypeDef() :
{
	String name;
	Token v;
	ASTVariableType type;
	ASTType tmp;
	List<ASTType> inputs = null;
	List<ASTType> var = null;
	ASTLabel label = ASTLabel.Secure;
}
{
	<TYPEDEF> v = <IDENTIFIER> { name = v.image; type = new ASTVariableType(v.image); }
    	( "@" v = <IDENTIFIER> {
							type.bitVars.add(new ASTVariableExpression(v.image)); 
							} )* 
	    (var = TypeVariables() { type.typeVars = var; })?
	[ { name = null; } [ v = <IDENTIFIER> { name = v.image; } { var = null; } 
	    (var = TypeVariables() { type.typeVars = var; })? ]
	  "(" {inputs = new ArrayList<ASTType>(); } [tmp = Type(ASTLabel.Secure) { inputs.add(tmp); } ("," tmp = Type(ASTLabel.Secure) { inputs.add(tmp); } )*] ")"]
	"=" tmp = Type(ASTLabel.Secure) {
		if(tmp instanceof ASTNativeType) {
			for (int w = 0; w < type.bitVars.size(); ++ w) {
				((ASTNativeType)tmp).bitVariables.add(((ASTVariableExpression)type.bitVars.get(w)).var);
			}
		}
		if(inputs == null) {
			program.typeBitVarDef.put(name, type.bitVars);
			program.typeVarDef.put(name, type.typeVars);
			program.typeDef.add(new Pair<String, ASTType>(name, tmp));
		} else {
			ASTFunctionType fty = new ASTFunctionType(type, name, inputs, true);
			if(var != null) {
				for(ASTType ty : var) {
					fty.typeParameter.add(ty);
				}
			}
			program.functionTypeMapping.add(new Pair<ASTFunctionType, ASTType>(fty, tmp));
		} 
		}
	";" 
}

ASTLabel Label() : {}
{
	  <ALICE> { return ASTLabel.Alice; }
	| <BOB> { return ASTLabel.Bob; }
	| <SECURE> { return ASTLabel.Secure; }
	| <PUBLIC> { return ASTLabel.Pub; }
}

ASTType Type(ASTLabel defaultLabel) : 
{
	ASTType type;
	ASTLabel lab = defaultLabel;
	Token v; 
	int bit;
	Token bitVar;
	ASTExpression bitExp = null;
	List<ASTExpression> dim = new ArrayList<ASTExpression>();
	List<ASTLabel> labs = new ArrayList<ASTLabel>();
	ASTExpression number;
	List<ASTType> var;
}
{
	<NATIVE> v = <IDENTIFIER> { return new ASTNativeType(v.image, new ArrayList<String>()); } 
	| ( [ lab = Label() ] ( v = <INT_TYPE> 
			[ "@"  (  bit = Constant() {bitExp = new ASTConstantExpression(bit); }
					| bitVar = <IDENTIFIER> { bitExp = new ASTVariableExpression(bitVar.image); } 
					| "(" bitExp = BIExpression() ")"  
				    | <LOG> "(" bitExp = BIExpression() ")" { bitExp = new ASTLogExpression(bitExp); }
				   ) ]
	  	{
	  		if(v.image.length() > 3) 
	  			bit = Integer.parseInt(v.image.substring(3));
	  		else
	  			bit = -1;
	  		if(bit >= 0 && bitExp != null)
	  			throw new RuntimeException("too many bit information!");
	  		if(bit >= 0) bitExp = new ASTConstantExpression(bit);
			type = ASTIntType.get(bitExp, lab); 
	  	} 
		| v = <FLOAT_TYPE> 
			[ "@"  (  bit = Constant() {bitExp = new ASTConstantExpression(bit); }
					| bitVar = <IDENTIFIER> { bitExp = new ASTVariableExpression(bitVar.image); } 
					| "(" bitExp = BIExpression() ")" 
				    | <LOG> "(" bitExp = BIExpression() ")" { bitExp = new ASTLogExpression(bitExp); }
				   ) ]
	  	{
	  		if(v.image.length() > 5) 
	  			bit = Integer.parseInt(v.image.substring(5));
	  		else
	  			bit = -1;
	  		if(bit >= 0 && bitExp != null)
	  			throw new RuntimeException("too many bit information!");
	  		if(bit >= 0) bitExp = new ASTConstantExpression(bit);
	  		type = ASTFloatType.get(bitExp, lab); 
	  	} 
		| v = <RND_TYPE> 
			[ "@"  (  bit = Constant() {bitExp = new ASTConstantExpression(bit); }
					| bitVar = <IDENTIFIER> { bitExp = new ASTVariableExpression(bitVar.image); } 
					| "(" bitExp = BIExpression() ")" 
				    | <LOG> "(" bitExp = BIExpression() ")" { bitExp = new ASTLogExpression(bitExp); }
				   ) ]
	  	{
	  		if(v.image.length() > 3) 
	  			bit = Integer.parseInt(v.image.substring(3));
	  		else
	  			bit = -1;
	  		if(bit >= 0 && bitExp != null)
	  			throw new RuntimeException("too many bit information!");
	  		if(bit >= 0) bitExp = new ASTConstantExpression(bit);
			type = ASTRndType.get(bitExp, lab); 
	  	} )
		| v = <IDENTIFIER> { type = new ASTVariableType(v.image); }
		  ( "@"  (  bit = Constant() {bitExp = new ASTConstantExpression(bit); }
					| bitVar = <IDENTIFIER> { bitExp = new ASTVariableExpression(bitVar.image); } 
					| "(" bitExp = BIExpression() ")" 
				    | <LOG> "(" bitExp = BIExpression() ")" { bitExp = new ASTLogExpression(bitExp); }
				   )
		  	{ ((ASTVariableType)type).bitVars.add(bitExp); } 
		  )* 
	  )
	  [ var = TypeVariables() { ((ASTVariableType)type).typeVars = var; } ]
	  ("[" { lab = defaultLabel; } ( lab = Label() )? number = BIExpression() 
	  		{ dim.add(number); labs.add(lab); } 
	  	"]")*
	  {
	  	for (int i = dim.size() - 1; i>=0; --i) {
	  		ASTExpression num = dim.get(i);
	  		ASTLabel l = labs.get(i);
	  		type = new ASTArrayType(type, num, l);
	  	}
	  	return type;
	  }
}

void FunctionDefinition() :
{
	boolean isDummy = false;
	ASTType retType;
	ASTType baseType = null;
	Token v, v1, v2;
	String name;
	List<Pair<ASTType, String>> inputs = new ArrayList<Pair<ASTType, String>>();
	Pair<ASTType, String> arg;
	ASTType ty;
	List<ASTStatement> stmt;
	List<String> typeVariables = new ArrayList<String>();
	List<ASTType> var1 = null, var2;
	
	List<String> bitParameter = new ArrayList<String>();
	
	String nativeName;
}
{
	(<DUMMY> { isDummy = true; })?
	
	( <VOID> { retType = ASTVoidType.get(); }
	 | retType = Type(ASTLabel.Secure)
	)
		[ LOOKAHEAD(10) baseType = Type(ASTLabel.Secure) "." ]
		v = <IDENTIFIER> { name = v.image; }
		( "@" v = <IDENTIFIER> { bitParameter.add(v.image); } )*
		[ "<" v = <IDENTIFIER> { typeVariables.add(v.image); } ("," v = <IDENTIFIER> { typeVariables.add(v.image); } )* ">" ]
		"(" 
			[ 
				arg = Argument() { inputs.add(arg); }	
				(
					"," arg = Argument() { inputs.add(arg); }
				)* 
			] 
		")"
	(
		"=" <NATIVE> v = <IDENTIFIER> { nativeName = v.image; } ("." v = <IDENTIFIER> { nativeName += "." + v.image; } )*
		{
			ASTFunctionNative nfunc = 
				new ASTFunctionNative(isDummy, name, retType, baseType, typeVariables, inputs);
			nfunc.nativeName = nativeName;
			program.functionDef.add(nfunc);
		} ";"
		| "{" 
		{
			ASTFunctionDef dfunc =
				new ASTFunctionDef(isDummy, name, retType, baseType,
					bitParameter, 
					typeVariables, inputs);
		}
		stmt = Statements(dfunc) "}"
		{
			dfunc.body = stmt;
			program.functionDef.add(dfunc);
		} 
	) 
}

Pair<ASTType, String> Argument() :
{
	ASTType ty;
	ASTFunctionType fty;
	Token v;
	List<ASTType> tyVar = null;
}
{
	ty = Type(ASTLabel.Secure) v = <IDENTIFIER>
	[ [ tyVar = TypeVariablesInExp() ] "(" { fty = new ASTFunctionType(ty, v.image, false); }
		 [ ty = Type(ASTLabel.Secure) { fty.inputTypes.add(ty); }
		 	("," ty = Type(ASTLabel.Secure) { fty.inputTypes.add(ty); } )*
		 ]
	")" { ty = fty; fty.typeParameter = tyVar; } ]
	{ return new Pair<ASTType, String>(ty, v.image); }
}

List<ASTStatement> Statements(ASTFunctionDef func) :
{
	List<ASTStatement> stmt = new ArrayList<ASTStatement>();
	List<ASTStatement> tmps; 
}
{
	(tmps = Statement(func) { stmt.addAll(tmps); })*
	{ return stmt; }
}

List<ASTStatement> Statement(ASTFunctionDef func) : 
{
	List<ASTStatement> stmt = new ArrayList<ASTStatement>();
	List<ASTStatement> init;
	List<ASTStatement> incre;
	ASTType ty;
	Token v;
	ASTExpression exp;
	ASTExpression var;
	ASTPredicate cond; 
	ASTIfStatement ifStmt;
	ASTWhileStatement whileStmt;
}
{
	(
		 LOOKAHEAD(10) ty = Type(ASTLabel.Secure) 
		 v = <IDENTIFIER> 
		 {
		 	func.localVariables.add(new Pair<ASTType, String>(ty, v.image)); 
		 } 
		 [
		 	"=" exp = BIExpression() 
		 	{ 
		 		stmt.add(new ASTAssignStatement(new ASTVariableExpression(v.image), exp)); 
		 	} 
		 ]
		 ("," v = <IDENTIFIER> {func.localVariables.add(new Pair<ASTType, String>(ty, v.image)); } 
		 	[
		 		"=" exp = BIExpression() 
		 		{ 
		 			stmt.add(new ASTAssignStatement(new ASTVariableExpression(v.image), exp)); 
		 		} 
		 	]
		 )* ";"
		| var = Expression() { exp = null; } 
			[ "=" exp = Expression() ] ";" 
			{
				if(exp != null)
					stmt.add(new ASTAssignStatement(var, exp));
				else {
					if (!(var instanceof ASTFuncExpression)) 
						throw new RuntimeException("Function call required!");
					else
						stmt.add(new ASTFuncStatement((ASTFuncExpression)var));
				}
			} 
		| <IF> "(" cond = Predicate() ")" { ifStmt = new ASTIfStatement(cond); } 
			ifStmt.trueBranch = Statement(func) [ LOOKAHEAD(2) <ELSE> ifStmt.falseBranch = Statement(func) ]
			{ stmt.add(ifStmt); }
		| <WHILE> "(" cond = Predicate() ")" { whileStmt = new ASTWhileStatement(cond); } 
			whileStmt.body = Statement(func)
			{ stmt.add(whileStmt); }
		| <FOR> "(" init = Statement(func) cond = Predicate() ";"
			{ incre = new ArrayList<ASTStatement>(); } 
			var = Expression() "=" exp = Expression()
			{ incre.add(new ASTAssignStatement(var, exp)); }
			")" 
			{ 
				stmt.addAll(init); 
				whileStmt = new ASTWhileStatement(cond); 
			} 
			whileStmt.body = Statement(func)
			{
				whileStmt.body.addAll(incre);
				stmt.add(whileStmt); 
			}
		| <RETURN> exp = Expression() ";" { stmt.add(new ASTReturnStatement(exp)); }
		| "{" stmt = Statements(func) "}"
	)
	{ return stmt; }
}

ASTExpression Expression() : 
{
	ASTExpression e, e2;
}
{
	e = BIExpression() ("," e2 = BIExpression() 
	{ 
		if (!(e instanceof ASTTupleExpression)) {
			e = new ASTTupleExpression(e, e2);
		} else {
			((ASTTupleExpression)e).exps.add(e2);
		}
	})*
	{ return e; }
}

ASTExpression BIExpression() : 
{
	ASTExpression e;
	ASTExpression n;
}
{
	e = ShiftExpression() 
		(
			"&" n = ShiftExpression() { e = new ASTBinaryExpression(e, BOP.AND, n); }
			| "|" n = ShiftExpression() { e = new ASTBinaryExpression(e, BOP.OR, n); }
			| "^" n = ShiftExpression() { e = new ASTBinaryExpression(e, BOP.XOR, n); }
		)* { return e; }
}

ASTExpression ShiftExpression() : 
{
	ASTExpression e;
	ASTExpression n;
}
{
	e = AdditiveExpression() 
		(
			"<<" n = AdditiveExpression() 
			{ 
				e = new ASTBinaryExpression(e, BOP.SHL, n); 
			}
			| 
			">>" n = AdditiveExpression()
			{ 
				e = new ASTBinaryExpression(e, BOP.SHR, n); 
			}
		)* { return e; }
}


ASTExpression RangeExpression() :
{
	ASTExpression e;
	ASTExpression n;
}
{
	e = RangeShiftExpression()
	(
		"&" n = RangeShiftExpression() { e = new ASTBinaryExpression(e, BOP.AND, n); }
		| "|" n = RangeShiftExpression() { e = new ASTBinaryExpression(e, BOP.OR, n); }
		| "^" n = RangeShiftExpression() { e = new ASTBinaryExpression(e, BOP.XOR, n); }
	)* { return e; }
}

ASTExpression RangeShiftExpression() : 
{
	ASTExpression e;
	ASTExpression n;
}
{
	e = RangeAdditiveExpression() 
		(
			"<<" n = RangeAdditiveExpression() 
			{ 
				e = new ASTBinaryExpression(e, BOP.SHL, n); 
			}
			| 
			">>" n = RangeAdditiveExpression()
			{ 
				e = new ASTBinaryExpression(e, BOP.SHR, n); 
			}
		)* { return e; }
}

ASTExpression ConstantExpression() : 
{
	int n;
	double v;
}
{
	n = Constant() { return new ASTConstantExpression(n); }
	| v = FloatConstant() { return new ASTFloatConstantExpression(v); }
}

ASTExpression VariableExpression() : 
{
	Token v;
}
{
	v = <IDENTIFIER> 
	{ 
		if (def.containsKey(v.image))
			return def.get(v.image);
		else
			return new ASTVariableExpression(v.image); }
	|
	<LOG>
	{
		return new ASTVariableExpression("log");
	}
}

ASTExpression AdditiveExpression() : 
{
	ASTExpression e1, e2;
}
{
	e1 = MultiplictiveExpression() 
	( "+" e2 = MultiplictiveExpression() { e1 = new ASTBinaryExpression(e1, BOP.ADD, e2); } 
	| "-" e2 = MultiplictiveExpression() { e1 = new ASTBinaryExpression(e1, BOP.SUB, e2); } )*
	{
		return e1;
	}
} 


ASTExpression RangeAdditiveExpression() : 
{
	ASTExpression e1, e2;
}
{
	e1 = RangeMultiplictiveExpression() 
	( "+" e2 = RangeMultiplictiveExpression() { e1 = new ASTBinaryExpression(e1, BOP.ADD, e2); } 
	| "-" e2 = RangeMultiplictiveExpression() { e1 = new ASTBinaryExpression(e1, BOP.SUB, e2); } )*
	{
		return e1;
	}
} 


ASTExpression MultiplictiveExpression() : 
{
	ASTExpression e1, e2;
}
{
	e1 = AtomicExpression() 
	( "*" e2 = AtomicExpression() { e1 = new ASTBinaryExpression(e1, BOP.MUL, e2); } 
	| "/" e2 = AtomicExpression() { e1 = new ASTBinaryExpression(e1, BOP.DIV, e2); } 
	| "%" e2 = AtomicExpression() { e1 = new ASTBinaryExpression(e1, BOP.MOD, e2); } )*
	{
		return e1;
	}
}

ASTExpression RangeMultiplictiveExpression() : 
{
	ASTExpression e1, e2;
}
{
	e1 = RangeAtomicExpression() 
	( "*" e2 = RangeAtomicExpression() { e1 = new ASTBinaryExpression(e1, BOP.MUL, e2); } 
	| "/" e2 = RangeAtomicExpression() { e1 = new ASTBinaryExpression(e1, BOP.DIV, e2); } 
	| "%" e2 = RangeAtomicExpression() { e1 = new ASTBinaryExpression(e1, BOP.MOD, e2); } )*
	{
		return e1;
	}
}

ASTPredicate Predicate() : 
{
	ASTPredicate e;
}
{
	e = OrPredicate() { return e; }
}

ASTPredicate OrPredicate() : 
{
	ASTPredicate e1, e2 = null;
}
{
	e1 = AndPredicate() ( LOOKAHEAD(2) "||" e2 = OrPredicate() 
	{
		if(e2 != null)
			e1 = new ASTOrPredicate(e1, e2); 
	} ) *
	{
		return e1;
	}
}


ASTPredicate AndPredicate() : 
{
	ASTPredicate e1, e2 = null;
}
{
	e1 = AtomicPredicate() ( LOOKAHEAD(2) "&&" e2 = AndPredicate() 
	{
		if(e2 != null)
			e1 = new ASTAndPredicate(e1, e2); 
	} )*
	{ return e1; }
}

ASTPredicate AtomicPredicate() : 
{
	ASTPredicate p;
}
{
	LOOKAHEAD(3) p = BinaryPredicate() { return p; }
	| "(" p = Predicate() ")" { return p; }
}

ASTPredicate BinaryPredicate() :
{
	ASTExpression e1, e2;
	REL_OP op;
}
{
	e1 = BIExpression()
	( "==" { op = REL_OP.EQ; }
		e2 = BIExpression() 
	| "!=" { op = REL_OP.NEQ; }
		e2 = BIExpression() 
	| ">" { op = REL_OP.GT; }
		e2 = BIExpression() 
	| ">=" { op = REL_OP.GET; }
		e2 = BIExpression() 
	| "<" { op = REL_OP.LT; }
		e2 = BIExpression() 
	| "<=" { op = REL_OP.LET; }
		e2 = BIExpression() 
	) 
	{ return new ASTBinaryPredicate(e1, op, e2); }
}
